<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.152.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>正确即是废话，废话亦是正确</title><meta name=description content><meta name=author content><link rel=canonical href=https://litjohn.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://litjohn.github.io/index.xml title=rss><link rel=alternate hreflang=en href=https://litjohn.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/"><meta property="og:site_name" content="正确即是废话，废话亦是正确"><meta property="og:title" content="正确即是废话，废话亦是正确"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="正确即是废话，废话亦是正确"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"正确即是废话，废话亦是正确","url":"https://litjohn.github.io/","description":"","logo":"https://litjohn.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="正确即是废话，废话亦是正确 (Alt + H)">正确即是废话，废话亦是正确</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2 class=entry-hint-parent>可以吗，总司令？</h2></header><div class=entry-content><p>一个由不可以总司令想到的有趣概率/期望题。
题面 一套卷子上有 $n$ 道判断题。你不知道它们的答案，但是你知道存在一个常数 $p \in [0, 1]$，对任意一道题，它的答案是“正确”的概率为 $p$。
你决定采用一种策略来答题：选择一个常数 $p’ \in [0, 1]$，对于任意一道题，你以 $p’$ 的概率选择“正确”。
求问：
若要使得期望做对题数最多，应该选择怎样的 $p’$？期望做对题数是多少？ 若要使得期望全对概率最大，应当选择怎样的 $p’$？期望全对概率是多大？ 解答 这是一个非常棒的问题！它涉及了期望、概率和优化策略，我们来一步步分解它。
首先，我们来明确一下变量和事件：
$n$: 题目的总数。 $p$: 任意一道题的真实答案是“正确”的概率。 $1-p$: 任意一道题的真实答案是“错误”的概率。 $p’$: 你回答任意一道题为“正确”的概率。 $1-p’$: 你回答任意一道题为“错误”的概率。 你的回答策略和你不知道的真实答案是相互独立的。
1) 使得期望做对题数最多 我们要计算做对题数的期望值，并找到使这个期望值最大的 $p’$。
计算单题做对的概率
首先，我们考虑只做对一道题的概率。有两种情况可以做对一道题：
题目的真实答案是“正确”（概率为 $p$），你也回答“正确”（概率为 $p’$）。这件事情发生的概率是 $p \cdot p’$。 题目的真实答案是“错误”（概率为 $1-p$），你也回答“错误”（概率为 $1-p’$）。这件事情发生的概率是 $(1-p) \cdot (1-p’)$。 由于这两种情况是互斥的，所以做对任意一道题的概率 $P(\text{单题正确})$ 是两者之和： $P(\text{单题正确}) = p p’ + (1-p)(1-p’)$
计算期望做对题数
设 $X$ 为你做对的总题数。$X$ 可以看作是 $n$ 个独立的伯努利试验的和，其中每次试验“成功”（即做对题）的概率为 $P(\text{单题正确})$。
...</p></div><footer class=entry-footer><span title='2025-10-22 16:47:24 +0800 +0800'>October 22, 2025</span></footer><a class=entry-link aria-label="post link to 可以吗，总司令？" href=https://litjohn.github.io/posts/answer-the-paper-randomly/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>和角公式证明</h2></header><div class=entry-content><p>从上一篇文章 https://www.luogu.com.cn/article/a0rd1bxx 的线性代数大学习中，我们知道旋转可以视为乘以一个矩阵。
那么，记 $R_\theta$ 是旋转 $\theta$ 对应的矩阵。
设旋转 $\alpha$ 的变换 $f_\alpha (P) = R_\alpha P$，以及相应的旋转 $\beta$ 角的变换 $f_\beta (P) = R_\beta P$。
显然有旋转 $\alpha + \beta$ 角等于先转 $\alpha$ 再转 $\beta$，也就是说 $f_{\alpha+\beta}(P) = f_\alpha(f_\beta(P))$ 恒成立。那么，代入函数的定义：
$R_{\alpha+\beta}P = R_\alpha (R_\beta P)$
用结合律，就有
$R_{\alpha+\beta}P = (R_\alpha R_\beta) P$
既然对任意向量两个矩阵的变换结果相同，那么它们肯定是相同的。有
$R_{\alpha+\beta} = R_\alpha R_\beta$
这样，由于我们知道 $R_{\alpha+\beta}$ 中包含 $\sin (\alpha+\beta)$ 和 $\cos (\alpha+\beta)$ 项，我们就可以用矩阵乘法算出来 $R_{\alpha+\beta}$，然后从中取出相应的项。
计算过程如下：
$R_{\alpha+\beta} = R_\alpha R_\beta = \begin{pmatrix} \cos\alpha & -\sin\alpha \\ \sin\alpha & \cos\alpha \end{pmatrix} \begin{pmatrix} \cos\beta & -\sin\beta \\ \sin\beta & \cos\beta \end{pmatrix}$
...</p></div><footer class=entry-footer><span title='2025-10-21 21:08:07 +0800 +0800'>October 21, 2025</span></footer><a class=entry-link aria-label="post link to 和角公式证明" href=https://litjohn.github.io/posts/proof-of-the-sum-and-difference-formula/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>瓜豆原理学习笔记/线性代数大学习</h2></header><div class=entry-content><p>瓜豆原理 一个图形经过任意旋转、缩放、平移、对称之后，与原图形保持相似，且相似比等于缩放比。
非常强大而泛用的定理。可以用来解决一整类初中的几何题。
这篇文章的目的是证明它，从地基开始重构这整套工具箱。所以默认读者已经会了这些东西，主要进行推式子。
定义 1：线性变换与仿射变换 线性变换 我们常常听说，“某某变换（比如缩放，旋转）是线性变换”。那么什么是“线性变换”？
我们称一个对 $n$ 维点的变换是线性变换，当且仅当存在一组 $\R^n \to \R$ 的线性变换 ${g_i}(1\le i \le n)$ 使得：
$$f((x_1, x_2, \cdots x_n)) = (g_1((x_1, x_2, \cdots x_n)), g_2((x_1, x_2, \cdots x_n)), \cdots g_n((x_1, x_2, \cdots x_n)))$$
这里的“$\R^n\to \R$ 的线性变换”指满足以下两条性质的变换：
可加性。对于变换 $f$，当且仅当 $\forall x\in \R^n, y\in \R^n; f(x + y) = f(x)+f(y)$ 时它满足这条性质。 齐性。对于变换 $f$，当且仅当 $\forall x\in \R^n, c\in \R; f(cx) = cf(x)$ 时它满足这条性质。 容易发现，这样的变换一定是形如 $f((x_1, \cdots x_n)) = \sum_{i = 1}^n a_ix_i$ 的变换，其中 $a_i$ 是常数。
...</p></div><footer class=entry-footer><span title='2025-10-21 21:05:06 +0800 +0800'>October 21, 2025</span></footer><a class=entry-link aria-label="post link to 瓜豆原理学习笔记/线性代数大学习" href=https://litjohn.github.io/posts/studying-linear-algebra/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>24 Points</h2></header><div class=entry-content><p>一个自动的 24 点求解器。输入四个数字就会自动输出所有解。
目前还有一点局限性：它会输出许多本质相同的解，比如 a 和 -(-a)。所以下一步可以实现表达式正则化和去重。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #lang racket (define a (make-vector 4)) (let read-a ([i 0]) (when (&lt; i 4) (vector-set! a i (read)) (when (not (number? (vector-ref a i))) (error "Invalid input!")) (read-a (+ i 1))) (vector-sort! a &lt;)) (struct node (val op1 op2 e1 e2) #:transparent #:mutable) (define (print-ans p) (if (eq? (node-e1 p) (void)) (display (node-val p)) (begin (display #\() ; (display #\() (when (eq? (node-op1 p) '-) (display (node-op1 p))) (print-ans (node-e1 p)) (display (node-op2 p)) ; (display #\() (print-ans (node-e2 p)) ; (display #\)) (display #\))))) (define operators (list (cons '+ +) (cons '- -) (cons '* *) (cons '/ /))) (define (solve l r) (if (= l r) (list (node (vector-ref a l) (void) (void) (void) (void))) (let ([res '()]) (let loop ([i l]) (when (&lt; i r) (let ([p1 (solve l i)] [p2 (solve (+ i 1) r)]) (for* ([op1 operators] [op2 operators] [e1 p1] [e2 p2]) (unless (or (and (= (node-val e2) 0) (eq? (car op2) '/)) (eq? (car op1) '*) (eq? (car op1) '/)) (let ([val ((cdr op2) ((cdr op1) (node-val e1)) (node-val e2))]) (set! res (cons (node val (car op1) (car op2) e1 e2) res)))))) (loop (+ i 1)))) res))) (define ans (void)) ; Helper function to reverse a subarray of vector `v` from `start` to `end` inclusive. (define (reverse-subarray v start end) (let loop ([i start] [j end]) (when (&lt; i j) ; Swap elements at index i and j (let ([temp (vector-ref v i)]) (vector-set! v i (vector-ref v j)) (vector-set! v j temp)) (loop (+ i 1) (- j 1))))) ; Implements the C++ std::next_permutation algorithm. ; Mutates global vector 'a' in place to the next lexicographical permutation. ; Returns #t if a next permutation was found, #f if it wrapped around to the first permutation. (define (next-permutation a) (let ([n (vector-length a)]) ; Step 1: Find pivot point 'i' (find first element a[i] &lt; a[i+1] from right) (let loop-find-pivot ([i (- n 2)]) (cond ; Case 1: No pivot found (vector is in reverse order) [(&lt; i 0) ; Reverse the whole vector to get the first permutation. (reverse-subarray a 0 (- n 1)) ; (displayln "!!!!!!!\n") #f] ; Return #f to indicate we wrapped around. ; Case 2: Found pivot point 'i' [(&lt; (vector-ref a i) (vector-ref a (+ i 1))) ; (displayln i) ; Step 2: Find swap element 'j' (find first element a[j] > a[i] from right) (let loop-find-swap ([j (- n 1)]) (if (> (vector-ref a j) (vector-ref a i)) ; Step 3: Swap elements at i and j (let ([temp (vector-ref a i)]) (vector-set! a i (vector-ref a j)) (vector-set! a j temp)) (loop-find-swap (- j 1)))) ; Step 4: Reverse suffix starting from i + 1 (reverse-subarray a (+ i 1) (- n 1)) #t] ; Return #t to indicate a next permutation was found. ; Case 3: Continue searching for pivot point 'i' to the left [else (loop-find-pivot (- i 1))])))) (define (print-a) (let loop ([i 0]) (when (&lt; i 4) (display (vector-ref a i)) (display #\space) (loop (+ i 1)))) (newline)) (let loop ([i 0]) (when (&lt; i 24) ; (print-a) (set! ans (solve 0 3)) (for ([p ans]) (when (= (node-val p) 24) (print-ans p) (newline) #; (exit))) (when (next-permutation a) (loop (+ i 1)))))</p></div><footer class=entry-footer><span title='2025-10-15 09:57:03 +0800 +0800'>October 15, 2025</span></footer><a class=entry-link aria-label="post link to 24 Points" href=https://litjohn.github.io/posts/24-points/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Start to Build a Compiler</h2></header><div class=entry-content><p>光剑的后日谈 #1. 在文艺复兴之后，FP 也要大胜利！
在这篇文章的讨论区中，我进行了引流。为了报答作者，我写了这篇文章。
上面那篇文章中使用了一种伪代码语法来表示 lambda calculus。不过这种语法并不能直接运行。怎么办呢？让我们来构建一个源到源编译器！
要写一种语言的编译器，显然我们需要知道它的语法和词法。这是第一步。另外还有语义，但是它是 lambda 的一种表示法，所以语义已经被 lambda 定义了，无需考虑。
首先是词法。这种语言会出现哪些 tokens？
分类一下。lambda 的核心是函数抽象和函数应用。函数抽象用到哪些 tokens？
func 关键字。 冒号。 return 关键字。 参数列表和括号。 函数应用？
括号 另外还有一个扩展语法，绑定创建。
等号（赋值运算符） 然后我们需要定义它的语法。这篇文章使用的是单参数的原始 lambda，方便了我们的实现。
1 2 3 4 5 6 identifier ::= symbol abstract-exp ::= func : (identifier) { return val-exp } apply-exp ::= val-exp(val-exp) bind-exp ::= identifier = val-exp val-exp ::= identifier | abstract-exp | apply-exp lc-exp ::= val-exp | bind-exp 看来挺简单的。
...</p></div><footer class=entry-footer><span title='2025-10-13 20:51:18 +0800 +0800'>October 13, 2025</span></footer><a class=entry-link aria-label="post link to Start to Build a Compiler" href=https://litjohn.github.io/posts/start-to-build-a-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>调用栈、de Bruijn 索引与堆栈的内存模型</h2></header><div class=entry-content><p>光剑系列的第六作！
（放一个 Gemini 生成的欧比旺的图来解释一下光剑是什么） 前五作：
第一篇：Let’s build our mathematics by using lambda calculus && church encoding! 第二篇：惰性求值、无穷流与发生的魔法 第三篇：协程、生成器与 call/cc 的控制流 第四篇：动态作用域、词法作用域与表达式求值的环境模型 第五篇：基于环境模型的解释器 我们上篇文章写了解释器。在评论区里面可以看到一个非常神秘的东西：https://www.zhihu.com/question/30262900/answer/1943149381147660845
1 2 3 4 5 6 7 8 9 10 11 12 ; 嵌套的括号不是 scheme 标准语法。表示定义柯里化的函数，和嵌套 lambda 等价。racket 支持这一扩展语法。 (define (Z env) (car env)) (define ((S vp) env) (vp (cdr env))) (define ((Lam e) env) (lambda (x) (e (cons x env)))) (define ((App e1 e2) env) ((e1 env) (e2 env))) ; (define global-env '()) 顺便，还有人问我为什么不再布置一道习题，那么这就是习题！
...</p></div><footer class=entry-footer><span title='2025-10-13 15:22:34 +0800 +0800'>October 13, 2025</span></footer><a class=entry-link aria-label="post link to 调用栈、de Bruijn 索引与堆栈的内存模型" href=https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>基于环境模型的解释器</h2></header><div class=entry-content><p>光剑系列的第五作！前四篇：
第一篇：Let’s build our mathematics by using lambda calculus && church encoding!
第二篇：惰性求值、无穷流与发生的魔法
第三篇：协程、生成器与 call/cc 的控制流
第四篇：动态作用域、词法作用域与表达式求值的环境模型
前言 又见面了！上一篇文章中我将动态作用域的实现留作了习题，一定非常恶心吧！毕竟我尝试了两天枚举了各种不用宏和用宏的解决方案都没有任何成果，只能看着看不懂的编译错误或者不期望的展开结果发呆。
如果有哪位读者做出了那个习题，请务必通过本文评论区联系我。
不过，其实只要自己实现一个解释器，就能够轻松而优雅地完成这个习题。
恰好，上一篇文章中介绍了环境模型，这将是我们解释器的原理。
我们将选择 scheme 实现解释器。因为 scheme 的解释器特别好写而作者太菜了只会这个。
实现 在实现一个具有比较多特性的 scheme 子集之前，我们将先实现一个更简单的 lambda 演算解释器。
看过第一作的读者们想必还记得 lambda 演算吧？它只含有函数一种对象，函数抽象和函数应用两种操作，已经是图灵完备的。
那么我们来实现它，使用环境模型和闭包。
预备工作 · 函数 lambda 只有函数一种核心对象。实现函数自然成为了我们的重要任务。
在环境模型下，想要实现词法作用域肯定要用闭包。所以我们的函数也将被表示为一个闭包。
它含有四个字段：第一个是符号 closure，用于标识身份。后面三个字段分别是形式参数、函数体和保存的环境。这些是闭包的核心要素。
我们可以先实现单参数的函数。因为具有一等公民函数的特性，我们可以通过柯里化实现多参数函数。
对于闭包的存储，随便用什么都行。我用的是一个 vector（定长数组）。
1 2 (define (make-closure params body env) (vector 'closure params body env)) 有了函数的数据结构标识，我们还需要有对于闭包的操作：
1 2 3 4 5 6 (define (closure? obj) (and (vector? obj) (eq? (vector-ref obj 0) 'closure))) (define (closure-param closure) (vector-ref closure 1)) (define (closure-body closure) (vector-ref closure 2)) (define (closure-env closure) (vector-ref closure 3)) 然后，为了支持对于函数的应用和抽象，我们需要一些关于环境的操作。
...</p></div><footer class=entry-footer><span title='2025-10-13 15:21:50 +0800 +0800'>October 13, 2025</span></footer><a class=entry-link aria-label="post link to 基于环境模型的解释器" href=https://litjohn.github.io/posts/%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>动态作用域、词法作用域与表达式求值的环境模型</h2></header><div class=entry-content><p>光剑系列的第四作！前三篇：
第一篇：Let’s build our mathematics by using lambda calculus && church encoding!
第二篇：惰性求值、无穷流与发生的魔法
第三篇：协程、生成器与 call/cc 的控制流
引子 在惰性求值、无穷流与发生的魔法中，我们使用无参 lambda 构建了一个 thunk。
想必有读者读完之后苦思冥想，最后发现“不对呀！主播，你为什么要用一个 lambda 呢？这里用 quote 不是也可以起到‘冻结计算’的作用？最后用一次 eval 将被冻结的原始表达式求值就可以得到真实值了。”
比如说，我们使用过的这个示例：
1 2 3 > (define x (lambda () (+ 1 2))) > (x) 3 就可以转化为下面的形式：
1 2 3 > (define x '(+ 1 2)) > (eval x) 3 如果你这么想了，恭喜你！你自己发现了一条通向本文核心内容，函数抽象的动态作用域与词法作用域区别的道路。
接下来，请容我解释动态作用域、词法作用域，它们的区别以及 thunk 两种构建方法与它们的联系。在本文中，我们还将手动在 scheme 中构建一套动态作用域的函数抽象/应用体系。最终成果如下：
1 2 3 4 5 6 7 8 ;; 假设使用支持 SRFI-39 的实现（chez 等很多支持） (define x (make-parameter 10)) (define (f y) (+ (x) y)) (f 5) ; => 15 (parameterize ([x 100]) (f 5)) ; => 105 ; x 按调用链动态解析 分道扬镳——当自由变量出现 上面的两种方法看似都能实现对计算的“冻结”，但是它们的作用真的完全一样吗？
...</p></div><footer class=entry-footer><span title='2025-10-13 15:20:24 +0800 +0800'>October 13, 2025</span></footer><a class=entry-link aria-label="post link to 动态作用域、词法作用域与表达式求值的环境模型" href=https://litjohn.github.io/posts/%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>协程、生成器与 call/cc 的控制流</h2></header><div class=entry-content><p>上期回顾 光剑系列的第三作！前两篇：
第一篇：Let’s build our mathematics by using lambda calculus && church encoding!
第二篇：惰性求值、无穷流与发生的魔法
前言与一个震撼的 demo 在上一篇文章中，我们探讨并实现了惰性求值与无穷流。希望你们还对自然数流印象深刻。
自然数流也可以视为一个不断生成新的自然数的生成器。那么，从这个意义上，我们有更简洁而强大的实现方式。
（还是一贯的 scheme 代码）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (define (nature-gen return) (let loop ((i 0)) (set! return (call/cc (lambda (state) (return (cons state i))))) (loop (+ i 1)))) (define nature-numbers (let ((k nature-gen)) (define (tmp-interface) (let ((result (call/cc k))) (set! k (car result)) (cdr result))) tmp-interface)) 这就是一个自然数的生成器！每次调用 nature-numbers，它都会返回一个新的自然数。
...</p></div><footer class=entry-footer><span title='2025-10-13 15:19:20 +0800 +0800'>October 13, 2025</span></footer><a class=entry-link aria-label="post link to 协程、生成器与 call/cc 的控制流" href=https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call-cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>惰性求值、无穷流与发生的魔法</h2></header><div class=entry-content><p>光剑第二作！
前言：什么是魔法？ （注：这个前言可以跳过。它是最终成果展示。感到迷惑很正常，请先阅读正文。）
什么是魔法？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 (define-syntax delay (syntax-rules () ((delay x) (lambda () x)))) (define (lazy-variable thunk) (cons #f thunk)) (define (is-calculated? variable) (car variable)) (define (force variable) (if (is-calculated? variable) (cdr variable) (begin (set-car! variable #t) (set-cdr! variable ((cdr variable))) (cdr variable)))) (define-syntax stream-cons (syntax-rules () ((stream-cons a b) (cons a (lazy-variable (delay b)))))) (define (stream-car x) (car x)) (define (stream-cdr x) (force (cdr x))) (define (int-from n) (stream-cons n (int-from (+ n 1)))) (define nature-numbers (int-from 1)) 真成四十行代码了。感兴趣的读者可以数一数，刚好 39 行。
...</p></div><footer class=entry-footer><span title='2025-10-13 15:15:17 +0800 +0800'>October 13, 2025</span></footer><a class=entry-link aria-label="post link to 惰性求值、无穷流与发生的魔法" href=https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://litjohn.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>正确即是废话，废话亦是正确</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>