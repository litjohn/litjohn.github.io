<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>正确&amp;废话 on 正确即是废话，废话亦是正确</title><link>https://litjohn.github.io/tags/%E6%AD%A3%E7%A1%AE%E5%BA%9F%E8%AF%9D/</link><description>Recent content in 正确&amp;废话 on 正确即是废话，废话亦是正确</description><generator>Hugo -- 0.154.3</generator><language>zh-cn</language><lastBuildDate>Wed, 31 Dec 2025 21:16:38 +0800</lastBuildDate><atom:link href="https://litjohn.github.io/tags/%E6%AD%A3%E7%A1%AE%E5%BA%9F%E8%AF%9D/index.xml" rel="self" type="application/rss+xml"/><item><title>同学你是做什么工作的</title><link>https://litjohn.github.io/posts/%E5%90%8C%E5%AD%A6%E4%BD%A0%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</link><pubDate>Wed, 31 Dec 2025 21:16:38 +0800</pubDate><guid>https://litjohn.github.io/posts/%E5%90%8C%E5%AD%A6%E4%BD%A0%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid><description>&lt;p&gt;（这篇文章经过了我与 Gemini 3 的讨论之后对观点有所补充。现在的文本不再是我的原文，而是 Gemini 3 将我的新观点加入原文后的新版本）&lt;/p&gt;
&lt;p&gt;省流：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“你总要知道自己要做些什么吧？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;程序员到底在做什么？&lt;/p&gt;
&lt;p&gt;有时候我甚至觉得，这个行业里只有两种工作：一种是不怎么考验智力的“搬砖”，另一种是极其考验智力但往往被视为“无意义”的“造轮子”。&lt;/p&gt;
&lt;p&gt;大部分人都在做前者。每天处理具体的业务逻辑，写写 CRUD，修修边角料。这种工作与其说是在搞“技术”，不如说是在做“翻译”——把产品经理的人话，翻译成机器能跑的代码。&lt;/p&gt;
&lt;p&gt;于是有人不甘心，想去做后者。去研究底层，去造轮子，去搞基础架构。但这又陷入了另一个怪圈：所谓的“硬核技术”，如果没有人用，那就是孤芳自赏的抽象废话。基础研究如同攀登珠峰，那是极少数天才的游戏；而对于大多数想靠代码吃饭的人来说，如果不通过“应用”落地，技术本身甚至无法产生供你生存的价值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这就触及到了计算机科学（CS）一个让人尴尬的本质：&lt;strong&gt;CS 本身是空心的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想想看，程序员这一职业，最核心的“独占技能”是什么？是写程序。&lt;br&gt;
但这就像“会写字”一样。你会写字，不代表你是作家；你会写字，甚至不代表你能写好一份通知。&lt;br&gt;
如果你只会编程语言的语法，只会调库，那你充其量是一个精通语法的“语言学家”。&lt;/p&gt;
&lt;p&gt;但是，语言是为了表达而存在的。如果你脑子里没有“内容”，光有语言有什么用？&lt;br&gt;
很多程序员的迷茫正源于此：我们花了大量精力去学习“怎么说话”（学各种语言、框架、模式），却很少去想“我们要说什么”。&lt;/p&gt;
&lt;p&gt;所以你会发现，真正牛逼的成果，往往是“计算机 + X”。&lt;br&gt;
前端开发，本质是“程序员 + 设计师/心理学”；&lt;br&gt;
科学计算，本质是“程序员 + 数学/物理”；&lt;br&gt;
推荐算法，本质是“程序员 + 统计学/商业逻辑”；&lt;br&gt;
哪怕是做编译器、做云平台的那些大牛，他们的“X”是“系统工程”——他们的目标非常明确：我要让这一千万行代码跑得更快，让那一万台机器不至于因为一根网线断了就全盘崩溃。&lt;/p&gt;
&lt;p&gt;王垠以前说过，CS 的本质是 PLT（编程语言理论）。这话乍一听像自吹自擂，但细想有几分道理。剥离掉所有应用层的东西，CS 剩下的确实就只有关于“计算”本身的抽象逻辑。但这玩意儿太冷清了，就像纯数学一样，容不下这个世界上几千万的从业者。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;所以，别再被“计算机专业”这个名字骗了。&lt;/p&gt;
&lt;p&gt;我们可能真的不该把“计算机”视为一个独立的、封闭的堡垒。计算机不是目的，它是手段。它是赋能万物的工具，是新时代的“笔和纸”。&lt;/p&gt;
&lt;p&gt;这就能解释为什么很多科班出身的人最终活成了“码农”。因为他们真的只会计算机，只会摆弄这支笔，却不知道该用它画什么画，写什么书。&lt;/p&gt;
&lt;p&gt;这行没什么前途吗？&lt;br&gt;
如果你把自己定义为“写代码的人”，那确实没前途，因为 AI 写得比你快。&lt;br&gt;
但如果你把自己定义为“用计算机解决问题的人”，那前途才刚刚开始。&lt;/p&gt;
&lt;p&gt;我们要避免的窘境，是手里拿着锤子，却看不见钉子，最后只能在那研究锤子的金属成分。&lt;br&gt;
真正的程序员，心里装的不该只是代码，而应该是一个他想要构建的、运行在现实世界里的系统。&lt;/p&gt;
&lt;p&gt;不管这个系统是用来算核聚变的，还是用来送外卖的。
知道自己要“构建什么”，远比知道“怎么写代码”重要。&lt;/p&gt;</description></item></channel></rss>