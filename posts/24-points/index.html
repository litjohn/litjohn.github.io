<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>24 Points | litjohn's blog</title><meta name=keywords content="archive"><meta name=description content="一个自动的 24 点求解器。输入四个数字就会自动输出所有解。
目前还有一点局限性：它会输出许多本质相同的解，比如 a 和 -(-a)。所以下一步可以实现表达式正则化和去重。


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133


#lang racket

(define a (make-vector 4))

(let read-a ([i 0])
    (when (< i 4)
        (vector-set! a i (read))

        (when (not (number? (vector-ref a i)))
            (error &#34;Invalid input!&#34;))

        (read-a (+ i 1)))
        
    (vector-sort! a <))

(struct node (val op1 op2 e1 e2) #:transparent #:mutable)

(define (print-ans p)
    (if (eq? (node-e1 p) (void))
        (display (node-val p))
        (begin
            (display #\()
            ; (display #\()
            (when (eq? (node-op1 p) '-)
                (display (node-op1 p)))

            (print-ans (node-e1 p))

            (display (node-op2 p))
            ; (display #\()
            (print-ans (node-e2 p))
            ; (display #\))
            (display #\)))))

(define operators (list (cons '+ +) (cons '- -) (cons '* *) (cons '/ /)))

(define (solve l r)
    (if (= l r)
        (list (node (vector-ref a l) (void) (void) (void) (void)))
        (let ([res '()])
            (let loop ([i l])
                (when (< i r)
                    (let ([p1 (solve l i)]
                          [p2 (solve (+ i 1) r)])
                          
                        (for* ([op1 operators]
                               [op2 operators]
                               [e1 p1]
                               [e2 p2])
                            
                            (unless (or 
                                        (and (= (node-val e2) 0)
                                             (eq? (car op2) '/))

                                        (eq? (car op1) '*)
                                        (eq? (car op1) '/))

                                (let ([val ((cdr op2) ((cdr op1) (node-val e1)) (node-val e2))])
                                    (set! res (cons (node val (car op1) (car op2) e1 e2) res))))))
                    
                    (loop (+ i 1))))
                    
            res)))

(define ans (void))

; Helper function to reverse a subarray of vector `v` from `start` to `end` inclusive.
(define (reverse-subarray v start end)
  (let loop ([i start] [j end])
    (when (< i j)
      ; Swap elements at index i and j
      (let ([temp (vector-ref v i)])
        (vector-set! v i (vector-ref v j))
        (vector-set! v j temp))
      (loop (+ i 1) (- j 1)))))

; Implements the C++ std::next_permutation algorithm.
; Mutates global vector 'a' in place to the next lexicographical permutation.
; Returns #t if a next permutation was found, #f if it wrapped around to the first permutation.
(define (next-permutation a)
  (let ([n (vector-length a)])
    ; Step 1: Find pivot point 'i' (find first element a[i] < a[i+1] from right)
    (let loop-find-pivot ([i (- n 2)])
      (cond
        ; Case 1: No pivot found (vector is in reverse order)
        [(< i 0)
         ; Reverse the whole vector to get the first permutation.
         (reverse-subarray a 0 (- n 1))
         ; (displayln &#34;!!!!!!!\n&#34;)
         #f] ; Return #f to indicate we wrapped around.
        
        ; Case 2: Found pivot point 'i'
        [(< (vector-ref a i) (vector-ref a (+ i 1)))
            ; (displayln i)
         ; Step 2: Find swap element 'j' (find first element a[j] > a[i] from right)
         (let loop-find-swap ([j (- n 1)])
           (if (> (vector-ref a j) (vector-ref a i))
             ; Step 3: Swap elements at i and j
             (let ([temp (vector-ref a i)])
               (vector-set! a i (vector-ref a j))
               (vector-set! a j temp))
               
            (loop-find-swap (- j 1))))
         
         ; Step 4: Reverse suffix starting from i + 1
         (reverse-subarray a (+ i 1) (- n 1))
         #t] ; Return #t to indicate a next permutation was found.

        ; Case 3: Continue searching for pivot point 'i' to the left
        [else (loop-find-pivot (- i 1))]))))

(define (print-a)
    (let loop ([i 0])
        (when (< i 4)
            (display (vector-ref a i))
            (display #\space)
            (loop (+ i 1))))
            
    (newline))

(let loop ([i 0])
    (when (< i 24)
        ; (print-a)

        (set! ans (solve 0 3))
        (for ([p ans])
            (when (= (node-val p) 24)
                (print-ans p)
                (newline)
                #; (exit)))
            
        (when (next-permutation a)
            (loop (+ i 1)))))


"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/24-points/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/24-points/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/24-points/"><meta property="og:site_name" content="litjohn's blog"><meta property="og:title" content="24 Points"><meta property="og:description" content="一个自动的 24 点求解器。输入四个数字就会自动输出所有解。
目前还有一点局限性：它会输出许多本质相同的解，比如 a 和 -(-a)。所以下一步可以实现表达式正则化和去重。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #lang racket (define a (make-vector 4)) (let read-a ([i 0]) (when (< i 4) (vector-set! a i (read)) (when (not (number? (vector-ref a i))) (error &#34;Invalid input!&#34;)) (read-a (+ i 1))) (vector-sort! a <)) (struct node (val op1 op2 e1 e2) #:transparent #:mutable) (define (print-ans p) (if (eq? (node-e1 p) (void)) (display (node-val p)) (begin (display #\() ; (display #\() (when (eq? (node-op1 p) '-) (display (node-op1 p))) (print-ans (node-e1 p)) (display (node-op2 p)) ; (display #\() (print-ans (node-e2 p)) ; (display #\)) (display #\))))) (define operators (list (cons '+ +) (cons '- -) (cons '* *) (cons '/ /))) (define (solve l r) (if (= l r) (list (node (vector-ref a l) (void) (void) (void) (void))) (let ([res '()]) (let loop ([i l]) (when (< i r) (let ([p1 (solve l i)] [p2 (solve (+ i 1) r)]) (for* ([op1 operators] [op2 operators] [e1 p1] [e2 p2]) (unless (or (and (= (node-val e2) 0) (eq? (car op2) '/)) (eq? (car op1) '*) (eq? (car op1) '/)) (let ([val ((cdr op2) ((cdr op1) (node-val e1)) (node-val e2))]) (set! res (cons (node val (car op1) (car op2) e1 e2) res)))))) (loop (+ i 1)))) res))) (define ans (void)) ; Helper function to reverse a subarray of vector `v` from `start` to `end` inclusive. (define (reverse-subarray v start end) (let loop ([i start] [j end]) (when (< i j) ; Swap elements at index i and j (let ([temp (vector-ref v i)]) (vector-set! v i (vector-ref v j)) (vector-set! v j temp)) (loop (+ i 1) (- j 1))))) ; Implements the C++ std::next_permutation algorithm. ; Mutates global vector 'a' in place to the next lexicographical permutation. ; Returns #t if a next permutation was found, #f if it wrapped around to the first permutation. (define (next-permutation a) (let ([n (vector-length a)]) ; Step 1: Find pivot point 'i' (find first element a[i] < a[i+1] from right) (let loop-find-pivot ([i (- n 2)]) (cond ; Case 1: No pivot found (vector is in reverse order) [(< i 0) ; Reverse the whole vector to get the first permutation. (reverse-subarray a 0 (- n 1)) ; (displayln &#34;!!!!!!!\n&#34;) #f] ; Return #f to indicate we wrapped around. ; Case 2: Found pivot point 'i' [(< (vector-ref a i) (vector-ref a (+ i 1))) ; (displayln i) ; Step 2: Find swap element 'j' (find first element a[j] > a[i] from right) (let loop-find-swap ([j (- n 1)]) (if (> (vector-ref a j) (vector-ref a i)) ; Step 3: Swap elements at i and j (let ([temp (vector-ref a i)]) (vector-set! a i (vector-ref a j)) (vector-set! a j temp)) (loop-find-swap (- j 1)))) ; Step 4: Reverse suffix starting from i + 1 (reverse-subarray a (+ i 1) (- n 1)) #t] ; Return #t to indicate a next permutation was found. ; Case 3: Continue searching for pivot point 'i' to the left [else (loop-find-pivot (- i 1))])))) (define (print-a) (let loop ([i 0]) (when (< i 4) (display (vector-ref a i)) (display #\space) (loop (+ i 1)))) (newline)) (let loop ([i 0]) (when (< i 24) ; (print-a) (set! ans (solve 0 3)) (for ([p ans]) (when (= (node-val p) 24) (print-ans p) (newline) #; (exit))) (when (next-permutation a) (loop (+ i 1))))) "><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-15T09:57:03+08:00"><meta property="article:modified_time" content="2025-10-15T09:57:03+08:00"><meta property="article:tag" content="Archive"><meta name=twitter:card content="summary"><meta name=twitter:title content="24 Points"><meta name=twitter:description content="一个自动的 24 点求解器。输入四个数字就会自动输出所有解。
目前还有一点局限性：它会输出许多本质相同的解，比如 a 和 -(-a)。所以下一步可以实现表达式正则化和去重。


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133


#lang racket

(define a (make-vector 4))

(let read-a ([i 0])
    (when (< i 4)
        (vector-set! a i (read))

        (when (not (number? (vector-ref a i)))
            (error &#34;Invalid input!&#34;))

        (read-a (+ i 1)))
        
    (vector-sort! a <))

(struct node (val op1 op2 e1 e2) #:transparent #:mutable)

(define (print-ans p)
    (if (eq? (node-e1 p) (void))
        (display (node-val p))
        (begin
            (display #\()
            ; (display #\()
            (when (eq? (node-op1 p) '-)
                (display (node-op1 p)))

            (print-ans (node-e1 p))

            (display (node-op2 p))
            ; (display #\()
            (print-ans (node-e2 p))
            ; (display #\))
            (display #\)))))

(define operators (list (cons '+ +) (cons '- -) (cons '* *) (cons '/ /)))

(define (solve l r)
    (if (= l r)
        (list (node (vector-ref a l) (void) (void) (void) (void)))
        (let ([res '()])
            (let loop ([i l])
                (when (< i r)
                    (let ([p1 (solve l i)]
                          [p2 (solve (+ i 1) r)])
                          
                        (for* ([op1 operators]
                               [op2 operators]
                               [e1 p1]
                               [e2 p2])
                            
                            (unless (or 
                                        (and (= (node-val e2) 0)
                                             (eq? (car op2) '/))

                                        (eq? (car op1) '*)
                                        (eq? (car op1) '/))

                                (let ([val ((cdr op2) ((cdr op1) (node-val e1)) (node-val e2))])
                                    (set! res (cons (node val (car op1) (car op2) e1 e2) res))))))
                    
                    (loop (+ i 1))))
                    
            res)))

(define ans (void))

; Helper function to reverse a subarray of vector `v` from `start` to `end` inclusive.
(define (reverse-subarray v start end)
  (let loop ([i start] [j end])
    (when (< i j)
      ; Swap elements at index i and j
      (let ([temp (vector-ref v i)])
        (vector-set! v i (vector-ref v j))
        (vector-set! v j temp))
      (loop (+ i 1) (- j 1)))))

; Implements the C++ std::next_permutation algorithm.
; Mutates global vector 'a' in place to the next lexicographical permutation.
; Returns #t if a next permutation was found, #f if it wrapped around to the first permutation.
(define (next-permutation a)
  (let ([n (vector-length a)])
    ; Step 1: Find pivot point 'i' (find first element a[i] < a[i+1] from right)
    (let loop-find-pivot ([i (- n 2)])
      (cond
        ; Case 1: No pivot found (vector is in reverse order)
        [(< i 0)
         ; Reverse the whole vector to get the first permutation.
         (reverse-subarray a 0 (- n 1))
         ; (displayln &#34;!!!!!!!\n&#34;)
         #f] ; Return #f to indicate we wrapped around.
        
        ; Case 2: Found pivot point 'i'
        [(< (vector-ref a i) (vector-ref a (+ i 1)))
            ; (displayln i)
         ; Step 2: Find swap element 'j' (find first element a[j] > a[i] from right)
         (let loop-find-swap ([j (- n 1)])
           (if (> (vector-ref a j) (vector-ref a i))
             ; Step 3: Swap elements at i and j
             (let ([temp (vector-ref a i)])
               (vector-set! a i (vector-ref a j))
               (vector-set! a j temp))
               
            (loop-find-swap (- j 1))))
         
         ; Step 4: Reverse suffix starting from i + 1
         (reverse-subarray a (+ i 1) (- n 1))
         #t] ; Return #t to indicate a next permutation was found.

        ; Case 3: Continue searching for pivot point 'i' to the left
        [else (loop-find-pivot (- i 1))]))))

(define (print-a)
    (let loop ([i 0])
        (when (< i 4)
            (display (vector-ref a i))
            (display #\space)
            (loop (+ i 1))))
            
    (newline))

(let loop ([i 0])
    (when (< i 24)
        ; (print-a)

        (set! ans (solve 0 3))
        (for ([p ans])
            (when (= (node-val p) 24)
                (print-ans p)
                (newline)
                #; (exit)))
            
        (when (next-permutation a)
            (loop (+ i 1)))))


"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"24 Points","item":"https://litjohn.github.io/posts/24-points/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"24 Points","name":"24 Points","description":"一个自动的 24 点求解器。输入四个数字就会自动输出所有解。\n目前还有一点局限性：它会输出许多本质相同的解，比如 a 和 -(-a)。所以下一步可以实现表达式正则化和去重。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #lang racket (define a (make-vector 4)) (let read-a ([i 0]) (when (\u0026lt; i 4) (vector-set! a i (read)) (when (not (number? (vector-ref a i))) (error \u0026#34;Invalid input!\u0026#34;)) (read-a (+ i 1))) (vector-sort! a \u0026lt;)) (struct node (val op1 op2 e1 e2) #:transparent #:mutable) (define (print-ans p) (if (eq? (node-e1 p) (void)) (display (node-val p)) (begin (display #\\() ; (display #\\() (when (eq? (node-op1 p) \u0026#39;-) (display (node-op1 p))) (print-ans (node-e1 p)) (display (node-op2 p)) ; (display #\\() (print-ans (node-e2 p)) ; (display #\\)) (display #\\))))) (define operators (list (cons \u0026#39;+ +) (cons \u0026#39;- -) (cons \u0026#39;* *) (cons \u0026#39;/ /))) (define (solve l r) (if (= l r) (list (node (vector-ref a l) (void) (void) (void) (void))) (let ([res \u0026#39;()]) (let loop ([i l]) (when (\u0026lt; i r) (let ([p1 (solve l i)] [p2 (solve (+ i 1) r)]) (for* ([op1 operators] [op2 operators] [e1 p1] [e2 p2]) (unless (or (and (= (node-val e2) 0) (eq? (car op2) \u0026#39;/)) (eq? (car op1) \u0026#39;*) (eq? (car op1) \u0026#39;/)) (let ([val ((cdr op2) ((cdr op1) (node-val e1)) (node-val e2))]) (set! res (cons (node val (car op1) (car op2) e1 e2) res)))))) (loop (+ i 1)))) res))) (define ans (void)) ; Helper function to reverse a subarray of vector `v` from `start` to `end` inclusive. (define (reverse-subarray v start end) (let loop ([i start] [j end]) (when (\u0026lt; i j) ; Swap elements at index i and j (let ([temp (vector-ref v i)]) (vector-set! v i (vector-ref v j)) (vector-set! v j temp)) (loop (+ i 1) (- j 1))))) ; Implements the C++ std::next_permutation algorithm. ; Mutates global vector \u0026#39;a\u0026#39; in place to the next lexicographical permutation. ; Returns #t if a next permutation was found, #f if it wrapped around to the first permutation. (define (next-permutation a) (let ([n (vector-length a)]) ; Step 1: Find pivot point \u0026#39;i\u0026#39; (find first element a[i] \u0026lt; a[i+1] from right) (let loop-find-pivot ([i (- n 2)]) (cond ; Case 1: No pivot found (vector is in reverse order) [(\u0026lt; i 0) ; Reverse the whole vector to get the first permutation. (reverse-subarray a 0 (- n 1)) ; (displayln \u0026#34;!!!!!!!\\n\u0026#34;) #f] ; Return #f to indicate we wrapped around. ; Case 2: Found pivot point \u0026#39;i\u0026#39; [(\u0026lt; (vector-ref a i) (vector-ref a (+ i 1))) ; (displayln i) ; Step 2: Find swap element \u0026#39;j\u0026#39; (find first element a[j] \u0026gt; a[i] from right) (let loop-find-swap ([j (- n 1)]) (if (\u0026gt; (vector-ref a j) (vector-ref a i)) ; Step 3: Swap elements at i and j (let ([temp (vector-ref a i)]) (vector-set! a i (vector-ref a j)) (vector-set! a j temp)) (loop-find-swap (- j 1)))) ; Step 4: Reverse suffix starting from i + 1 (reverse-subarray a (+ i 1) (- n 1)) #t] ; Return #t to indicate a next permutation was found. ; Case 3: Continue searching for pivot point \u0026#39;i\u0026#39; to the left [else (loop-find-pivot (- i 1))])))) (define (print-a) (let loop ([i 0]) (when (\u0026lt; i 4) (display (vector-ref a i)) (display #\\space) (loop (+ i 1)))) (newline)) (let loop ([i 0]) (when (\u0026lt; i 24) ; (print-a) (set! ans (solve 0 3)) (for ([p ans]) (when (= (node-val p) 24) (print-ans p) (newline) #; (exit))) (when (next-permutation a) (loop (+ i 1))))) ","keywords":["archive"],"articleBody":"一个自动的 24 点求解器。输入四个数字就会自动输出所有解。\n目前还有一点局限性：它会输出许多本质相同的解，比如 a 和 -(-a)。所以下一步可以实现表达式正则化和去重。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #lang racket (define a (make-vector 4)) (let read-a ([i 0]) (when (\u003c i 4) (vector-set! a i (read)) (when (not (number? (vector-ref a i))) (error \"Invalid input!\")) (read-a (+ i 1))) (vector-sort! a \u003c)) (struct node (val op1 op2 e1 e2) #:transparent #:mutable) (define (print-ans p) (if (eq? (node-e1 p) (void)) (display (node-val p)) (begin (display #\\() ; (display #\\() (when (eq? (node-op1 p) '-) (display (node-op1 p))) (print-ans (node-e1 p)) (display (node-op2 p)) ; (display #\\() (print-ans (node-e2 p)) ; (display #\\)) (display #\\))))) (define operators (list (cons '+ +) (cons '- -) (cons '* *) (cons '/ /))) (define (solve l r) (if (= l r) (list (node (vector-ref a l) (void) (void) (void) (void))) (let ([res '()]) (let loop ([i l]) (when (\u003c i r) (let ([p1 (solve l i)] [p2 (solve (+ i 1) r)]) (for* ([op1 operators] [op2 operators] [e1 p1] [e2 p2]) (unless (or (and (= (node-val e2) 0) (eq? (car op2) '/)) (eq? (car op1) '*) (eq? (car op1) '/)) (let ([val ((cdr op2) ((cdr op1) (node-val e1)) (node-val e2))]) (set! res (cons (node val (car op1) (car op2) e1 e2) res)))))) (loop (+ i 1)))) res))) (define ans (void)) ; Helper function to reverse a subarray of vector `v` from `start` to `end` inclusive. (define (reverse-subarray v start end) (let loop ([i start] [j end]) (when (\u003c i j) ; Swap elements at index i and j (let ([temp (vector-ref v i)]) (vector-set! v i (vector-ref v j)) (vector-set! v j temp)) (loop (+ i 1) (- j 1))))) ; Implements the C++ std::next_permutation algorithm. ; Mutates global vector 'a' in place to the next lexicographical permutation. ; Returns #t if a next permutation was found, #f if it wrapped around to the first permutation. (define (next-permutation a) (let ([n (vector-length a)]) ; Step 1: Find pivot point 'i' (find first element a[i] \u003c a[i+1] from right) (let loop-find-pivot ([i (- n 2)]) (cond ; Case 1: No pivot found (vector is in reverse order) [(\u003c i 0) ; Reverse the whole vector to get the first permutation. (reverse-subarray a 0 (- n 1)) ; (displayln \"!!!!!!!\\n\") #f] ; Return #f to indicate we wrapped around. ; Case 2: Found pivot point 'i' [(\u003c (vector-ref a i) (vector-ref a (+ i 1))) ; (displayln i) ; Step 2: Find swap element 'j' (find first element a[j] \u003e a[i] from right) (let loop-find-swap ([j (- n 1)]) (if (\u003e (vector-ref a j) (vector-ref a i)) ; Step 3: Swap elements at i and j (let ([temp (vector-ref a i)]) (vector-set! a i (vector-ref a j)) (vector-set! a j temp)) (loop-find-swap (- j 1)))) ; Step 4: Reverse suffix starting from i + 1 (reverse-subarray a (+ i 1) (- n 1)) #t] ; Return #t to indicate a next permutation was found. ; Case 3: Continue searching for pivot point 'i' to the left [else (loop-find-pivot (- i 1))])))) (define (print-a) (let loop ([i 0]) (when (\u003c i 4) (display (vector-ref a i)) (display #\\space) (loop (+ i 1)))) (newline)) (let loop ([i 0]) (when (\u003c i 24) ; (print-a) (set! ans (solve 0 3)) (for ([p ans]) (when (= (node-val p) 24) (print-ans p) (newline) #; (exit))) (when (next-permutation a) (loop (+ i 1))))) ","wordCount":"682","inLanguage":"en","datePublished":"2025-10-15T09:57:03+08:00","dateModified":"2025-10-15T09:57:03+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/24-points/"},"publisher":{"@type":"Organization","name":"litjohn's blog","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="litjohn's blog (Alt + H)">litjohn's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">24 Points</h1><div class=post-meta><span title='2025-10-15 09:57:03 +0800 +0800'>October 15, 2025</span></div></header><div class=post-content><p>一个自动的 24 点求解器。输入四个数字就会自动输出所有解。</p><p>目前还有一点局限性：它会输出许多本质相同的解，比如 a 和 -(-a)。所以下一步可以实现表达式正则化和去重。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>a</span> <span class=p>(</span><span class=nb>make-vector</span> <span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>let</span> <span class=n>read-a</span> <span class=p>([</span><span class=n>i</span> <span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>vector-set!</span> <span class=n>a</span> <span class=n>i</span> <span class=p>(</span><span class=nb>read</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>number?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>i</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Invalid input!&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>read-a</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>vector-sort!</span> <span class=n>a</span> <span class=nb>&lt;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>node</span> <span class=p>(</span><span class=n>val</span> <span class=n>op1</span> <span class=n>op2</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=kd>#:transparent</span> <span class=kd>#:mutable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>print-ans</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=n>node-e1</span> <span class=n>p</span><span class=p>)</span> <span class=p>(</span><span class=nb>void</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>display</span> <span class=p>(</span><span class=n>node-val</span> <span class=n>p</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>begin</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>display</span> <span class=sc>#\(</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>; (display #\()</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=n>node-op1</span> <span class=n>p</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>-</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nb>display</span> <span class=p>(</span><span class=n>node-op1</span> <span class=n>p</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>print-ans</span> <span class=p>(</span><span class=n>node-e1</span> <span class=n>p</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>display</span> <span class=p>(</span><span class=n>node-op2</span> <span class=n>p</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1>; (display #\()</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>print-ans</span> <span class=p>(</span><span class=n>node-e2</span> <span class=n>p</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1>; (display #\))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>display</span> <span class=sc>#\)</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>operators</span> <span class=p>(</span><span class=nb>list</span> <span class=p>(</span><span class=nb>cons</span> <span class=o>&#39;</span><span class=ss>+</span> <span class=nb>+</span><span class=p>)</span> <span class=p>(</span><span class=nb>cons</span> <span class=o>&#39;</span><span class=ss>-</span> <span class=nb>-</span><span class=p>)</span> <span class=p>(</span><span class=nb>cons</span> <span class=o>&#39;</span><span class=ss>*</span> <span class=nb>*</span><span class=p>)</span> <span class=p>(</span><span class=nb>cons</span> <span class=o>&#39;</span><span class=ss>/</span> <span class=nb>/</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>solve</span> <span class=n>l</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>=</span> <span class=n>l</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>list</span> <span class=p>(</span><span class=n>node</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>l</span><span class=p>)</span> <span class=p>(</span><span class=nb>void</span><span class=p>)</span> <span class=p>(</span><span class=nb>void</span><span class=p>)</span> <span class=p>(</span><span class=nb>void</span><span class=p>)</span> <span class=p>(</span><span class=nb>void</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>res</span> <span class=o>&#39;</span><span class=p>()])</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=n>l</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>p1</span> <span class=p>(</span><span class=n>solve</span> <span class=n>l</span> <span class=n>i</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>                          <span class=p>[</span><span class=n>p2</span> <span class=p>(</span><span class=n>solve</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)</span> <span class=n>r</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>                          
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=k>for*</span> <span class=p>([</span><span class=n>op1</span> <span class=n>operators</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                               <span class=p>[</span><span class=n>op2</span> <span class=n>operators</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                               <span class=p>[</span><span class=n>e1</span> <span class=n>p1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                               <span class=p>[</span><span class=n>e2</span> <span class=n>p2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                            
</span></span><span class=line><span class=cl>                            <span class=p>(</span><span class=k>unless</span> <span class=p>(</span><span class=k>or</span> 
</span></span><span class=line><span class=cl>                                        <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>=</span> <span class=p>(</span><span class=n>node-val</span> <span class=n>e2</span><span class=p>)</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                             <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>car</span> <span class=n>op2</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>/</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                        <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>car</span> <span class=n>op1</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                        <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>car</span> <span class=n>op1</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>/</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>val</span> <span class=p>((</span><span class=nb>cdr</span> <span class=n>op2</span><span class=p>)</span> <span class=p>((</span><span class=nb>cdr</span> <span class=n>op1</span><span class=p>)</span> <span class=p>(</span><span class=n>node-val</span> <span class=n>e1</span><span class=p>))</span> <span class=p>(</span><span class=n>node-val</span> <span class=n>e2</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>                                    <span class=p>(</span><span class=k>set!</span> <span class=n>res</span> <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=n>node</span> <span class=n>val</span> <span class=p>(</span><span class=nb>car</span> <span class=n>op1</span><span class=p>)</span> <span class=p>(</span><span class=nb>car</span> <span class=n>op2</span><span class=p>)</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=n>res</span><span class=p>))))))</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>            <span class=n>res</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>ans</span> <span class=p>(</span><span class=nb>void</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; Helper function to reverse a subarray of vector `v` from `start` to `end` inclusive.</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>reverse-subarray</span> <span class=n>v</span> <span class=n>start</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=n>start</span><span class=p>]</span> <span class=p>[</span><span class=n>j</span> <span class=n>end</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=c1>; Swap elements at index i and j</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>temp</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>v</span> <span class=n>i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>vector-set!</span> <span class=n>v</span> <span class=n>i</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>v</span> <span class=n>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>vector-set!</span> <span class=n>v</span> <span class=n>j</span> <span class=n>temp</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=nb>-</span> <span class=n>j</span> <span class=mi>1</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; Implements the C++ std::next_permutation algorithm.</span>
</span></span><span class=line><span class=cl><span class=c1>; Mutates global vector &#39;a&#39; in place to the next lexicographical permutation.</span>
</span></span><span class=line><span class=cl><span class=c1>; Returns #t if a next permutation was found, #f if it wrapped around to the first permutation.</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>next-permutation</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>n</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>a</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=c1>; Step 1: Find pivot point &#39;i&#39; (find first element a[i] &lt; a[i+1] from right)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=n>loop-find-pivot</span> <span class=p>([</span><span class=n>i</span> <span class=p>(</span><span class=nb>-</span> <span class=n>n</span> <span class=mi>2</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>        <span class=c1>; Case 1: No pivot found (vector is in reverse order)</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=c1>; Reverse the whole vector to get the first permutation.</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>reverse-subarray</span> <span class=n>a</span> <span class=mi>0</span> <span class=p>(</span><span class=nb>-</span> <span class=n>n</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>         <span class=c1>; (displayln &#34;!!!!!!!\n&#34;)</span>
</span></span><span class=line><span class=cl>         <span class=no>#f</span><span class=p>]</span> <span class=c1>; Return #f to indicate we wrapped around.</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>; Case 2: Found pivot point &#39;i&#39;</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=nb>&lt;</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>i</span><span class=p>)</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=c1>; (displayln i)</span>
</span></span><span class=line><span class=cl>         <span class=c1>; Step 2: Find swap element &#39;j&#39; (find first element a[j] &gt; a[i] from right)</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>let</span> <span class=n>loop-find-swap</span> <span class=p>([</span><span class=n>j</span> <span class=p>(</span><span class=nb>-</span> <span class=n>n</span> <span class=mi>1</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>&gt;</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>j</span><span class=p>)</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>             <span class=c1>; Step 3: Swap elements at i and j</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>temp</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nb>vector-set!</span> <span class=n>a</span> <span class=n>i</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nb>vector-set!</span> <span class=n>a</span> <span class=n>j</span> <span class=n>temp</span><span class=p>))</span>
</span></span><span class=line><span class=cl>               
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>loop-find-swap</span> <span class=p>(</span><span class=nb>-</span> <span class=n>j</span> <span class=mi>1</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>         
</span></span><span class=line><span class=cl>         <span class=c1>; Step 4: Reverse suffix starting from i + 1</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>reverse-subarray</span> <span class=n>a</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=nb>-</span> <span class=n>n</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>         <span class=no>#t</span><span class=p>]</span> <span class=c1>; Return #t to indicate a next permutation was found.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>; Case 3: Continue searching for pivot point &#39;i&#39; to the left</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=k>else</span> <span class=p>(</span><span class=n>loop-find-pivot</span> <span class=p>(</span><span class=nb>-</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))]))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>print-a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>display</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>display</span> <span class=sc>#\space</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>newline</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=mi>24</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>; (print-a)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>set!</span> <span class=n>ans</span> <span class=p>(</span><span class=n>solve</span> <span class=mi>0</span> <span class=mi>3</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>for</span> <span class=p>([</span><span class=n>p</span> <span class=n>ans</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>=</span> <span class=p>(</span><span class=n>node-val</span> <span class=n>p</span><span class=p>)</span> <span class=mi>24</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=n>print-ans</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nb>newline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c>#;</span> <span class=p>(</span><span class=nb>exit</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=n>next-permutation</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)))))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/archive/>Archive</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>litjohn's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>