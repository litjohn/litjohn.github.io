<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>函数式随机访问列表（斜二叉树队列） | 正确即是废话，废话亦是正确</title><meta name=keywords content="algorithms"><meta name=description content="如题，一种 lisp 列表的增强版，支持 $O(\log n)$ 级别的随机访问和修改，并且无缝可持久化。


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136


#lang racket/base

(define (length-geq? l n)
  (let loop ([cur l]
             [len 0])

    (cond
      [(>= len n) #t]
      [(null? cur) #f]
      [else (loop (cdr cur) (add1 len))])))

(struct alist (roots) #:transparent)
(struct single-tree (root size) #:transparent)
(struct tree-node (val l r) #:transparent)

(define (alist-cons head l)
  (let ([rt (alist-roots l)])
    (if (length-geq? rt 2)
        (let ([a (car rt)]
              [b (cadr rt)]
              [rest (cddr rt)])

          (if (= (single-tree-size a) (single-tree-size b))
              (alist
               (cons (single-tree
                      (tree-node head (single-tree-root a) (single-tree-root b))
                      (add1 (* 2 (single-tree-size b))))
                     rest))

              (alist (cons (single-tree (tree-node head #f #f) 1) rt))))

        (alist (cons (single-tree (tree-node head #f #f) 1) rt)))))

(define (alist-car l)
  (let ([head (car (alist-roots l))])
    (tree-node-val
     (single-tree-root head))))

(define (alist-cdr l)
  (let ([head (car (alist-roots l))]
        [rest (cdr (alist-roots l))])

    (if (= (single-tree-size head) 1)
        (alist rest)
        (let* ([root (single-tree-root head)]
               [lson (tree-node-l root)]
               [rson (tree-node-r root)]
               [size (arithmetic-shift (single-tree-size head) -1)])

          (alist (cons (single-tree lson size) (cons (single-tree rson size) rest)))))))

(define (get-binary x)
  (define width (integer-length x))
  (define res (make-vector width #f))

  (let loop ([i (sub1 width)])
    (when (>= i 0)
      (when (not (zero? (bitwise-and 1 (arithmetic-shift x (- i)))))
        (vector-set! res i #t))

      (loop (sub1 i))))

  res)

(define (access-in-single-tree p idx)
  (define width (integer-length idx))
  (define bin (get-binary idx))

  (let loop ([i (- width 2)]
             [cur p])
    (if (>= i 0)
        (if (vector-ref bin i)
            (loop (sub1 i) (tree-node-r cur))
            (loop (sub1 i) (tree-node-l cur)))
        (tree-node-val cur))))

(define (random-access l pos)
  (set! pos (add1 pos)) ;; 0-base => 1-base

  (let ([roots (alist-roots l)])
    (let loop ([cur roots]
               [i pos])

      (let ([rt (car cur)])
        (if (> i (single-tree-size rt))
            (loop (cdr cur) (- i (single-tree-size rt)))
            (access-in-single-tree (single-tree-root rt) i))))))

(define (set-in-single-tree p idx v)
  (define width (integer-length idx))
  (define bin (get-binary idx))

  (let loop ([i (- width 2)]
             [cur p])

    (let ([org (tree-node-val cur)]
          [lson (tree-node-l cur)]
          [rson (tree-node-r cur)])

      (if (< i 0)
          (tree-node v lson rson)
          (if (vector-ref bin i)
              (tree-node org lson (loop (sub1 i) rson))
              (tree-node org (loop (sub1 i) lson) rson))))))

(define (random-set l pos v)
  (set! pos (add1 pos))

  (define res
    (let ([roots (alist-roots l)])
      (let loop ([cur roots]
                 [i pos])

        (let ([rt (car cur)])
          (if (> i (single-tree-size rt))
              (cons rt (loop (cdr cur) (- i (single-tree-size rt))))
              (cons (single-tree (set-in-single-tree (single-tree-root rt) i v) (single-tree-size rt)) (cdr cur)))))))
  (alist res))

;; tests

(define a (alist '()))
(set! a (alist-cons 3 a))
(set! a (alist-cons 5 a))

(displayln (random-access a 0))

(set! a (alist-cons 7 a))
(set! a (alist-cons 9 a))

(displayln (random-access a 2))

(set! a (random-set a 2 'a))

(displayln (random-access a 2))
(displayln (random-access (alist-cdr a) 1))


概述
一种基于完美二叉树以及斜二进制分解的结构。lisp 列表的上位替代，支持 $O(1)$ 的 car/cdr/cons，$O(\log n)$ 的随机访问修改。完全可持久化，支持不可变性和结构共享。"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/random-accessable-funtional-list/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/random-accessable-funtional-list/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/random-accessable-funtional-list/"><meta property="og:site_name" content="正确即是废话，废话亦是正确"><meta property="og:title" content="函数式随机访问列表（斜二叉树队列）"><meta property="og:description" content="如题，一种 lisp 列表的增强版，支持 $O(\log n)$ 级别的随机访问和修改，并且无缝可持久化。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #lang racket/base (define (length-geq? l n) (let loop ([cur l] [len 0]) (cond [(>= len n) #t] [(null? cur) #f] [else (loop (cdr cur) (add1 len))]))) (struct alist (roots) #:transparent) (struct single-tree (root size) #:transparent) (struct tree-node (val l r) #:transparent) (define (alist-cons head l) (let ([rt (alist-roots l)]) (if (length-geq? rt 2) (let ([a (car rt)] [b (cadr rt)] [rest (cddr rt)]) (if (= (single-tree-size a) (single-tree-size b)) (alist (cons (single-tree (tree-node head (single-tree-root a) (single-tree-root b)) (add1 (* 2 (single-tree-size b)))) rest)) (alist (cons (single-tree (tree-node head #f #f) 1) rt)))) (alist (cons (single-tree (tree-node head #f #f) 1) rt))))) (define (alist-car l) (let ([head (car (alist-roots l))]) (tree-node-val (single-tree-root head)))) (define (alist-cdr l) (let ([head (car (alist-roots l))] [rest (cdr (alist-roots l))]) (if (= (single-tree-size head) 1) (alist rest) (let* ([root (single-tree-root head)] [lson (tree-node-l root)] [rson (tree-node-r root)] [size (arithmetic-shift (single-tree-size head) -1)]) (alist (cons (single-tree lson size) (cons (single-tree rson size) rest))))))) (define (get-binary x) (define width (integer-length x)) (define res (make-vector width #f)) (let loop ([i (sub1 width)]) (when (>= i 0) (when (not (zero? (bitwise-and 1 (arithmetic-shift x (- i))))) (vector-set! res i #t)) (loop (sub1 i)))) res) (define (access-in-single-tree p idx) (define width (integer-length idx)) (define bin (get-binary idx)) (let loop ([i (- width 2)] [cur p]) (if (>= i 0) (if (vector-ref bin i) (loop (sub1 i) (tree-node-r cur)) (loop (sub1 i) (tree-node-l cur))) (tree-node-val cur)))) (define (random-access l pos) (set! pos (add1 pos)) ;; 0-base => 1-base (let ([roots (alist-roots l)]) (let loop ([cur roots] [i pos]) (let ([rt (car cur)]) (if (> i (single-tree-size rt)) (loop (cdr cur) (- i (single-tree-size rt))) (access-in-single-tree (single-tree-root rt) i)))))) (define (set-in-single-tree p idx v) (define width (integer-length idx)) (define bin (get-binary idx)) (let loop ([i (- width 2)] [cur p]) (let ([org (tree-node-val cur)] [lson (tree-node-l cur)] [rson (tree-node-r cur)]) (if (< i 0) (tree-node v lson rson) (if (vector-ref bin i) (tree-node org lson (loop (sub1 i) rson)) (tree-node org (loop (sub1 i) lson) rson)))))) (define (random-set l pos v) (set! pos (add1 pos)) (define res (let ([roots (alist-roots l)]) (let loop ([cur roots] [i pos]) (let ([rt (car cur)]) (if (> i (single-tree-size rt)) (cons rt (loop (cdr cur) (- i (single-tree-size rt)))) (cons (single-tree (set-in-single-tree (single-tree-root rt) i v) (single-tree-size rt)) (cdr cur))))))) (alist res)) ;; tests (define a (alist '())) (set! a (alist-cons 3 a)) (set! a (alist-cons 5 a)) (displayln (random-access a 0)) (set! a (alist-cons 7 a)) (set! a (alist-cons 9 a)) (displayln (random-access a 2)) (set! a (random-set a 2 'a)) (displayln (random-access a 2)) (displayln (random-access (alist-cdr a) 1)) 概述 一种基于完美二叉树以及斜二进制分解的结构。lisp 列表的上位替代，支持 $O(1)$ 的 car/cdr/cons，$O(\log n)$ 的随机访问修改。完全可持久化，支持不可变性和结构共享。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-30T19:32:24+08:00"><meta property="article:modified_time" content="2025-10-30T19:32:24+08:00"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="函数式随机访问列表（斜二叉树队列）"><meta name=twitter:description content="如题，一种 lisp 列表的增强版，支持 $O(\log n)$ 级别的随机访问和修改，并且无缝可持久化。


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136


#lang racket/base

(define (length-geq? l n)
  (let loop ([cur l]
             [len 0])

    (cond
      [(>= len n) #t]
      [(null? cur) #f]
      [else (loop (cdr cur) (add1 len))])))

(struct alist (roots) #:transparent)
(struct single-tree (root size) #:transparent)
(struct tree-node (val l r) #:transparent)

(define (alist-cons head l)
  (let ([rt (alist-roots l)])
    (if (length-geq? rt 2)
        (let ([a (car rt)]
              [b (cadr rt)]
              [rest (cddr rt)])

          (if (= (single-tree-size a) (single-tree-size b))
              (alist
               (cons (single-tree
                      (tree-node head (single-tree-root a) (single-tree-root b))
                      (add1 (* 2 (single-tree-size b))))
                     rest))

              (alist (cons (single-tree (tree-node head #f #f) 1) rt))))

        (alist (cons (single-tree (tree-node head #f #f) 1) rt)))))

(define (alist-car l)
  (let ([head (car (alist-roots l))])
    (tree-node-val
     (single-tree-root head))))

(define (alist-cdr l)
  (let ([head (car (alist-roots l))]
        [rest (cdr (alist-roots l))])

    (if (= (single-tree-size head) 1)
        (alist rest)
        (let* ([root (single-tree-root head)]
               [lson (tree-node-l root)]
               [rson (tree-node-r root)]
               [size (arithmetic-shift (single-tree-size head) -1)])

          (alist (cons (single-tree lson size) (cons (single-tree rson size) rest)))))))

(define (get-binary x)
  (define width (integer-length x))
  (define res (make-vector width #f))

  (let loop ([i (sub1 width)])
    (when (>= i 0)
      (when (not (zero? (bitwise-and 1 (arithmetic-shift x (- i)))))
        (vector-set! res i #t))

      (loop (sub1 i))))

  res)

(define (access-in-single-tree p idx)
  (define width (integer-length idx))
  (define bin (get-binary idx))

  (let loop ([i (- width 2)]
             [cur p])
    (if (>= i 0)
        (if (vector-ref bin i)
            (loop (sub1 i) (tree-node-r cur))
            (loop (sub1 i) (tree-node-l cur)))
        (tree-node-val cur))))

(define (random-access l pos)
  (set! pos (add1 pos)) ;; 0-base => 1-base

  (let ([roots (alist-roots l)])
    (let loop ([cur roots]
               [i pos])

      (let ([rt (car cur)])
        (if (> i (single-tree-size rt))
            (loop (cdr cur) (- i (single-tree-size rt)))
            (access-in-single-tree (single-tree-root rt) i))))))

(define (set-in-single-tree p idx v)
  (define width (integer-length idx))
  (define bin (get-binary idx))

  (let loop ([i (- width 2)]
             [cur p])

    (let ([org (tree-node-val cur)]
          [lson (tree-node-l cur)]
          [rson (tree-node-r cur)])

      (if (< i 0)
          (tree-node v lson rson)
          (if (vector-ref bin i)
              (tree-node org lson (loop (sub1 i) rson))
              (tree-node org (loop (sub1 i) lson) rson))))))

(define (random-set l pos v)
  (set! pos (add1 pos))

  (define res
    (let ([roots (alist-roots l)])
      (let loop ([cur roots]
                 [i pos])

        (let ([rt (car cur)])
          (if (> i (single-tree-size rt))
              (cons rt (loop (cdr cur) (- i (single-tree-size rt))))
              (cons (single-tree (set-in-single-tree (single-tree-root rt) i v) (single-tree-size rt)) (cdr cur)))))))
  (alist res))

;; tests

(define a (alist '()))
(set! a (alist-cons 3 a))
(set! a (alist-cons 5 a))

(displayln (random-access a 0))

(set! a (alist-cons 7 a))
(set! a (alist-cons 9 a))

(displayln (random-access a 2))

(set! a (random-set a 2 'a))

(displayln (random-access a 2))
(displayln (random-access (alist-cdr a) 1))


概述
一种基于完美二叉树以及斜二进制分解的结构。lisp 列表的上位替代，支持 $O(1)$ 的 car/cdr/cons，$O(\log n)$ 的随机访问修改。完全可持久化，支持不可变性和结构共享。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"函数式随机访问列表（斜二叉树队列）","item":"https://litjohn.github.io/posts/random-accessable-funtional-list/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"函数式随机访问列表（斜二叉树队列）","name":"函数式随机访问列表（斜二叉树队列）","description":"如题，一种 lisp 列表的增强版，支持 $O(\\log n)$ 级别的随机访问和修改，并且无缝可持久化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #lang racket/base (define (length-geq? l n) (let loop ([cur l] [len 0]) (cond [(\u0026gt;= len n) #t] [(null? cur) #f] [else (loop (cdr cur) (add1 len))]))) (struct alist (roots) #:transparent) (struct single-tree (root size) #:transparent) (struct tree-node (val l r) #:transparent) (define (alist-cons head l) (let ([rt (alist-roots l)]) (if (length-geq? rt 2) (let ([a (car rt)] [b (cadr rt)] [rest (cddr rt)]) (if (= (single-tree-size a) (single-tree-size b)) (alist (cons (single-tree (tree-node head (single-tree-root a) (single-tree-root b)) (add1 (* 2 (single-tree-size b)))) rest)) (alist (cons (single-tree (tree-node head #f #f) 1) rt)))) (alist (cons (single-tree (tree-node head #f #f) 1) rt))))) (define (alist-car l) (let ([head (car (alist-roots l))]) (tree-node-val (single-tree-root head)))) (define (alist-cdr l) (let ([head (car (alist-roots l))] [rest (cdr (alist-roots l))]) (if (= (single-tree-size head) 1) (alist rest) (let* ([root (single-tree-root head)] [lson (tree-node-l root)] [rson (tree-node-r root)] [size (arithmetic-shift (single-tree-size head) -1)]) (alist (cons (single-tree lson size) (cons (single-tree rson size) rest))))))) (define (get-binary x) (define width (integer-length x)) (define res (make-vector width #f)) (let loop ([i (sub1 width)]) (when (\u0026gt;= i 0) (when (not (zero? (bitwise-and 1 (arithmetic-shift x (- i))))) (vector-set! res i #t)) (loop (sub1 i)))) res) (define (access-in-single-tree p idx) (define width (integer-length idx)) (define bin (get-binary idx)) (let loop ([i (- width 2)] [cur p]) (if (\u0026gt;= i 0) (if (vector-ref bin i) (loop (sub1 i) (tree-node-r cur)) (loop (sub1 i) (tree-node-l cur))) (tree-node-val cur)))) (define (random-access l pos) (set! pos (add1 pos)) ;; 0-base =\u0026gt; 1-base (let ([roots (alist-roots l)]) (let loop ([cur roots] [i pos]) (let ([rt (car cur)]) (if (\u0026gt; i (single-tree-size rt)) (loop (cdr cur) (- i (single-tree-size rt))) (access-in-single-tree (single-tree-root rt) i)))))) (define (set-in-single-tree p idx v) (define width (integer-length idx)) (define bin (get-binary idx)) (let loop ([i (- width 2)] [cur p]) (let ([org (tree-node-val cur)] [lson (tree-node-l cur)] [rson (tree-node-r cur)]) (if (\u0026lt; i 0) (tree-node v lson rson) (if (vector-ref bin i) (tree-node org lson (loop (sub1 i) rson)) (tree-node org (loop (sub1 i) lson) rson)))))) (define (random-set l pos v) (set! pos (add1 pos)) (define res (let ([roots (alist-roots l)]) (let loop ([cur roots] [i pos]) (let ([rt (car cur)]) (if (\u0026gt; i (single-tree-size rt)) (cons rt (loop (cdr cur) (- i (single-tree-size rt)))) (cons (single-tree (set-in-single-tree (single-tree-root rt) i v) (single-tree-size rt)) (cdr cur))))))) (alist res)) ;; tests (define a (alist \u0026#39;())) (set! a (alist-cons 3 a)) (set! a (alist-cons 5 a)) (displayln (random-access a 0)) (set! a (alist-cons 7 a)) (set! a (alist-cons 9 a)) (displayln (random-access a 2)) (set! a (random-set a 2 \u0026#39;a)) (displayln (random-access a 2)) (displayln (random-access (alist-cdr a) 1)) 概述 一种基于完美二叉树以及斜二进制分解的结构。lisp 列表的上位替代，支持 $O(1)$ 的 car/cdr/cons，$O(\\log n)$ 的随机访问修改。完全可持久化，支持不可变性和结构共享。\n","keywords":["algorithms"],"articleBody":"如题，一种 lisp 列表的增强版，支持 $O(\\log n)$ 级别的随机访问和修改，并且无缝可持久化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #lang racket/base (define (length-geq? l n) (let loop ([cur l] [len 0]) (cond [(\u003e= len n) #t] [(null? cur) #f] [else (loop (cdr cur) (add1 len))]))) (struct alist (roots) #:transparent) (struct single-tree (root size) #:transparent) (struct tree-node (val l r) #:transparent) (define (alist-cons head l) (let ([rt (alist-roots l)]) (if (length-geq? rt 2) (let ([a (car rt)] [b (cadr rt)] [rest (cddr rt)]) (if (= (single-tree-size a) (single-tree-size b)) (alist (cons (single-tree (tree-node head (single-tree-root a) (single-tree-root b)) (add1 (* 2 (single-tree-size b)))) rest)) (alist (cons (single-tree (tree-node head #f #f) 1) rt)))) (alist (cons (single-tree (tree-node head #f #f) 1) rt))))) (define (alist-car l) (let ([head (car (alist-roots l))]) (tree-node-val (single-tree-root head)))) (define (alist-cdr l) (let ([head (car (alist-roots l))] [rest (cdr (alist-roots l))]) (if (= (single-tree-size head) 1) (alist rest) (let* ([root (single-tree-root head)] [lson (tree-node-l root)] [rson (tree-node-r root)] [size (arithmetic-shift (single-tree-size head) -1)]) (alist (cons (single-tree lson size) (cons (single-tree rson size) rest))))))) (define (get-binary x) (define width (integer-length x)) (define res (make-vector width #f)) (let loop ([i (sub1 width)]) (when (\u003e= i 0) (when (not (zero? (bitwise-and 1 (arithmetic-shift x (- i))))) (vector-set! res i #t)) (loop (sub1 i)))) res) (define (access-in-single-tree p idx) (define width (integer-length idx)) (define bin (get-binary idx)) (let loop ([i (- width 2)] [cur p]) (if (\u003e= i 0) (if (vector-ref bin i) (loop (sub1 i) (tree-node-r cur)) (loop (sub1 i) (tree-node-l cur))) (tree-node-val cur)))) (define (random-access l pos) (set! pos (add1 pos)) ;; 0-base =\u003e 1-base (let ([roots (alist-roots l)]) (let loop ([cur roots] [i pos]) (let ([rt (car cur)]) (if (\u003e i (single-tree-size rt)) (loop (cdr cur) (- i (single-tree-size rt))) (access-in-single-tree (single-tree-root rt) i)))))) (define (set-in-single-tree p idx v) (define width (integer-length idx)) (define bin (get-binary idx)) (let loop ([i (- width 2)] [cur p]) (let ([org (tree-node-val cur)] [lson (tree-node-l cur)] [rson (tree-node-r cur)]) (if (\u003c i 0) (tree-node v lson rson) (if (vector-ref bin i) (tree-node org lson (loop (sub1 i) rson)) (tree-node org (loop (sub1 i) lson) rson)))))) (define (random-set l pos v) (set! pos (add1 pos)) (define res (let ([roots (alist-roots l)]) (let loop ([cur roots] [i pos]) (let ([rt (car cur)]) (if (\u003e i (single-tree-size rt)) (cons rt (loop (cdr cur) (- i (single-tree-size rt)))) (cons (single-tree (set-in-single-tree (single-tree-root rt) i v) (single-tree-size rt)) (cdr cur))))))) (alist res)) ;; tests (define a (alist '())) (set! a (alist-cons 3 a)) (set! a (alist-cons 5 a)) (displayln (random-access a 0)) (set! a (alist-cons 7 a)) (set! a (alist-cons 9 a)) (displayln (random-access a 2)) (set! a (random-set a 2 'a)) (displayln (random-access a 2)) (displayln (random-access (alist-cdr a) 1)) 概述 一种基于完美二叉树以及斜二进制分解的结构。lisp 列表的上位替代，支持 $O(1)$ 的 car/cdr/cons，$O(\\log n)$ 的随机访问修改。完全可持久化，支持不可变性和结构共享。\n后面的几点才是真正的优势。如果只是要常数级别头部添加以及高效随机访问，vector 快得多（类似 C++ std::vector 的结构，但是反转过来）。然而我们使用列表时常用的是结构共享和可持久化的功能，也要求不可变性，vector 就无法胜任。\n权值线段树不支持 cons/cdr，而平衡树不支持 $O(1)$ car/cdr/cons。\n原理 维护一组完美二叉树组成的列表。\n我们将列表中的元素存储在这些树中，靠前的树中任意元素的下标小于靠后的树中元素的下标（形式化的，对于任意 $i, j$ 满足 $i","wordCount":"669","inLanguage":"en","datePublished":"2025-10-30T19:32:24+08:00","dateModified":"2025-10-30T19:32:24+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/random-accessable-funtional-list/"},"publisher":{"@type":"Organization","name":"正确即是废话，废话亦是正确","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="正确即是废话，废话亦是正确 (Alt + H)">正确即是废话，废话亦是正确</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">函数式随机访问列表（斜二叉树队列）</h1><div class=post-meta><span title='2025-10-30 19:32:24 +0800 +0800'>October 30, 2025</span></div></header><div class=post-content><p>如题，一种 lisp 列表的增强版，支持 $O(\log n)$ 级别的随机访问和修改，并且无缝可持久化。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket/base</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>length-geq?</span> <span class=n>l</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>cur</span> <span class=n>l</span><span class=p>]</span>
</span></span><span class=line><span class=cl>             <span class=p>[</span><span class=n>len</span> <span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=nb>&gt;=</span> <span class=n>len</span> <span class=n>n</span><span class=p>)</span> <span class=no>#t</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=nb>null?</span> <span class=n>cur</span><span class=p>)</span> <span class=no>#f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=k>else</span> <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>cur</span><span class=p>)</span> <span class=p>(</span><span class=nb>add1</span> <span class=n>len</span><span class=p>))])))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>alist</span> <span class=p>(</span><span class=n>roots</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>single-tree</span> <span class=p>(</span><span class=n>root</span> <span class=n>size</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>tree-node</span> <span class=p>(</span><span class=n>val</span> <span class=n>l</span> <span class=n>r</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>alist-cons</span> <span class=n>head</span> <span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>rt</span> <span class=p>(</span><span class=n>alist-roots</span> <span class=n>l</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>length-geq?</span> <span class=n>rt</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>a</span> <span class=p>(</span><span class=nb>car</span> <span class=n>rt</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>              <span class=p>[</span><span class=n>b</span> <span class=p>(</span><span class=nb>cadr</span> <span class=n>rt</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>              <span class=p>[</span><span class=nb>rest</span> <span class=p>(</span><span class=nb>cddr</span> <span class=n>rt</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>=</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>a</span><span class=p>)</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>alist</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=n>single-tree</span>
</span></span><span class=line><span class=cl>                      <span class=p>(</span><span class=n>tree-node</span> <span class=n>head</span> <span class=p>(</span><span class=n>single-tree-root</span> <span class=n>a</span><span class=p>)</span> <span class=p>(</span><span class=n>single-tree-root</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                      <span class=p>(</span><span class=nb>add1</span> <span class=p>(</span><span class=nb>*</span> <span class=mi>2</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>b</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>                     <span class=nb>rest</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>alist</span> <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=n>single-tree</span> <span class=p>(</span><span class=n>tree-node</span> <span class=n>head</span> <span class=no>#f</span> <span class=no>#f</span><span class=p>)</span> <span class=mi>1</span><span class=p>)</span> <span class=n>rt</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>alist</span> <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=n>single-tree</span> <span class=p>(</span><span class=n>tree-node</span> <span class=n>head</span> <span class=no>#f</span> <span class=no>#f</span><span class=p>)</span> <span class=mi>1</span><span class=p>)</span> <span class=n>rt</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>alist-car</span> <span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>head</span> <span class=p>(</span><span class=nb>car</span> <span class=p>(</span><span class=n>alist-roots</span> <span class=n>l</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>tree-node-val</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=n>single-tree-root</span> <span class=n>head</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>alist-cdr</span> <span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>head</span> <span class=p>(</span><span class=nb>car</span> <span class=p>(</span><span class=n>alist-roots</span> <span class=n>l</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=nb>rest</span> <span class=p>(</span><span class=nb>cdr</span> <span class=p>(</span><span class=n>alist-roots</span> <span class=n>l</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>=</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>head</span><span class=p>)</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>alist</span> <span class=nb>rest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let*</span> <span class=p>([</span><span class=n>root</span> <span class=p>(</span><span class=n>single-tree-root</span> <span class=n>head</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>               <span class=p>[</span><span class=n>lson</span> <span class=p>(</span><span class=n>tree-node-l</span> <span class=n>root</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>               <span class=p>[</span><span class=n>rson</span> <span class=p>(</span><span class=n>tree-node-r</span> <span class=n>root</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>               <span class=p>[</span><span class=n>size</span> <span class=p>(</span><span class=nb>arithmetic-shift</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>head</span><span class=p>)</span> <span class=mi>-1</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>alist</span> <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=n>single-tree</span> <span class=n>lson</span> <span class=n>size</span><span class=p>)</span> <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=n>single-tree</span> <span class=n>rson</span> <span class=n>size</span><span class=p>)</span> <span class=nb>rest</span><span class=p>)))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>get-binary</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>width</span> <span class=p>(</span><span class=nb>integer-length</span> <span class=n>x</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>res</span> <span class=p>(</span><span class=nb>make-vector</span> <span class=n>width</span> <span class=no>#f</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>width</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>&gt;=</span> <span class=n>i</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>zero?</span> <span class=p>(</span><span class=nb>bitwise-and</span> <span class=mi>1</span> <span class=p>(</span><span class=nb>arithmetic-shift</span> <span class=n>x</span> <span class=p>(</span><span class=nb>-</span> <span class=n>i</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>vector-set!</span> <span class=n>res</span> <span class=n>i</span> <span class=no>#t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>i</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>access-in-single-tree</span> <span class=n>p</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>width</span> <span class=p>(</span><span class=nb>integer-length</span> <span class=n>idx</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>bin</span> <span class=p>(</span><span class=n>get-binary</span> <span class=n>idx</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=p>(</span><span class=nb>-</span> <span class=n>width</span> <span class=mi>2</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>             <span class=p>[</span><span class=n>cur</span> <span class=n>p</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>&gt;=</span> <span class=n>i</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>bin</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>i</span><span class=p>)</span> <span class=p>(</span><span class=n>tree-node-r</span> <span class=n>cur</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>i</span><span class=p>)</span> <span class=p>(</span><span class=n>tree-node-l</span> <span class=n>cur</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>tree-node-val</span> <span class=n>cur</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>random-access</span> <span class=n>l</span> <span class=n>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>set!</span> <span class=n>pos</span> <span class=p>(</span><span class=nb>add1</span> <span class=n>pos</span><span class=p>))</span> <span class=c1>;; 0-base =&gt; 1-base</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>roots</span> <span class=p>(</span><span class=n>alist-roots</span> <span class=n>l</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>cur</span> <span class=n>roots</span><span class=p>]</span>
</span></span><span class=line><span class=cl>               <span class=p>[</span><span class=n>i</span> <span class=n>pos</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>rt</span> <span class=p>(</span><span class=nb>car</span> <span class=n>cur</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>&gt;</span> <span class=n>i</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>rt</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>cur</span><span class=p>)</span> <span class=p>(</span><span class=nb>-</span> <span class=n>i</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>rt</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>access-in-single-tree</span> <span class=p>(</span><span class=n>single-tree-root</span> <span class=n>rt</span><span class=p>)</span> <span class=n>i</span><span class=p>))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>set-in-single-tree</span> <span class=n>p</span> <span class=n>idx</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>width</span> <span class=p>(</span><span class=nb>integer-length</span> <span class=n>idx</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>bin</span> <span class=p>(</span><span class=n>get-binary</span> <span class=n>idx</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=p>(</span><span class=nb>-</span> <span class=n>width</span> <span class=mi>2</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>             <span class=p>[</span><span class=n>cur</span> <span class=n>p</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>org</span> <span class=p>(</span><span class=n>tree-node-val</span> <span class=n>cur</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>          <span class=p>[</span><span class=n>lson</span> <span class=p>(</span><span class=n>tree-node-l</span> <span class=n>cur</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>          <span class=p>[</span><span class=n>rson</span> <span class=p>(</span><span class=n>tree-node-r</span> <span class=n>cur</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>tree-node</span> <span class=n>v</span> <span class=n>lson</span> <span class=n>rson</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>bin</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>tree-node</span> <span class=n>org</span> <span class=n>lson</span> <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>i</span><span class=p>)</span> <span class=n>rson</span><span class=p>))</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>tree-node</span> <span class=n>org</span> <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>i</span><span class=p>)</span> <span class=n>lson</span><span class=p>)</span> <span class=n>rson</span><span class=p>))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>random-set</span> <span class=n>l</span> <span class=n>pos</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>set!</span> <span class=n>pos</span> <span class=p>(</span><span class=nb>add1</span> <span class=n>pos</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>res</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>roots</span> <span class=p>(</span><span class=n>alist-roots</span> <span class=n>l</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>cur</span> <span class=n>roots</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                 <span class=p>[</span><span class=n>i</span> <span class=n>pos</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>rt</span> <span class=p>(</span><span class=nb>car</span> <span class=n>cur</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>&gt;</span> <span class=n>i</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>rt</span><span class=p>))</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nb>cons</span> <span class=n>rt</span> <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>cur</span><span class=p>)</span> <span class=p>(</span><span class=nb>-</span> <span class=n>i</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>rt</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=n>single-tree</span> <span class=p>(</span><span class=n>set-in-single-tree</span> <span class=p>(</span><span class=n>single-tree-root</span> <span class=n>rt</span><span class=p>)</span> <span class=n>i</span> <span class=n>v</span><span class=p>)</span> <span class=p>(</span><span class=n>single-tree-size</span> <span class=n>rt</span><span class=p>))</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>cur</span><span class=p>)))))))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>alist</span> <span class=n>res</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; tests</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>a</span> <span class=p>(</span><span class=n>alist</span> <span class=o>&#39;</span><span class=p>()))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>set!</span> <span class=n>a</span> <span class=p>(</span><span class=n>alist-cons</span> <span class=mi>3</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>set!</span> <span class=n>a</span> <span class=p>(</span><span class=n>alist-cons</span> <span class=mi>5</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>random-access</span> <span class=n>a</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>set!</span> <span class=n>a</span> <span class=p>(</span><span class=n>alist-cons</span> <span class=mi>7</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>set!</span> <span class=n>a</span> <span class=p>(</span><span class=n>alist-cons</span> <span class=mi>9</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>random-access</span> <span class=n>a</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>set!</span> <span class=n>a</span> <span class=p>(</span><span class=n>random-set</span> <span class=n>a</span> <span class=mi>2</span> <span class=o>&#39;</span><span class=ss>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>random-access</span> <span class=n>a</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>random-access</span> <span class=p>(</span><span class=n>alist-cdr</span> <span class=n>a</span><span class=p>)</span> <span class=mi>1</span><span class=p>))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h2><p>一种基于完美二叉树以及斜二进制分解的结构。lisp 列表的上位替代，支持 $O(1)$ 的 car/cdr/cons，$O(\log n)$ 的随机访问修改。完全可持久化，支持不可变性和结构共享。</p><p>后面的几点才是真正的优势。如果只是要常数级别头部添加以及高效随机访问，vector 快得多（类似 C++ std::vector 的结构，但是反转过来）。然而我们使用列表时常用的是结构共享和可持久化的功能，也要求不可变性，vector 就无法胜任。</p><p>权值线段树不支持 cons/cdr，而平衡树不支持 $O(1)$ car/cdr/cons。</p><h2 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h2><p>维护一组完美二叉树组成的列表。</p><p>我们将列表中的元素存储在这些树中，靠前的树中任意元素的下标小于靠后的树中元素的下标（形式化的，对于任意 $i, j$ 满足 $i&lt;j$，第 $i$ 棵树中的任意元素的下标小于第 $j$ 棵树中的任意元素的下标。）</p><p>对于一棵树内部，下标最小的元素占据根节点，它的左儿子是下标第二小的，右儿子是第三小的。下标第 $k$ 小的元素的左右儿子分别是下标第 $2k$ 小和第 $2k+1$ 小的节点。（类似于线段树的堆式存储）</p><p>这些二叉树的大小从前往后单调不降，并且除了第一二个可能相等外其余的树大小严格递增。</p><p>不难发现，由于每多一棵树节点总数翻倍，树的总数是 $O(\log n)$ 量级的。</p><h3 id=cons>cons<a hidden class=anchor aria-hidden=true href=#cons>#</a></h3><p>如果原来的前两棵树大小相等，就将这两棵树分别作为新节点的左右儿子组合成一棵更大的树。</p><p>否则造一棵新的大小为 1 的树，插进列表最前面。</p><h3 id=car>car<a hidden class=anchor aria-hidden=true href=#car>#</a></h3><p>取第一棵树的根节点。</p><h3 id=cdr>cdr<a hidden class=anchor aria-hidden=true href=#cdr>#</a></h3><p>cons 的逆过程，如果第一棵树大小为 1，直接删掉。否则删去它的根节点，将它分裂成两棵大小相同的树。</p><h3 id=access>access<a hidden class=anchor aria-hidden=true href=#access>#</a></h3><p>在列表中顺序查找到访问下标所处的树，然后在树中进行访问。</p><p>假设这棵树的根节点的下标是 <code>i</code>，你要访问 <code>x</code>，那么设 <code>idx=x-i+1</code>，将它转为二进制位序列（高位在前，从最高有效位开始。比如 10 对应的序列是 <code>1010</code>）。</p><p>这个序列就是寻找到目标节点的操作步骤指示。假如说你现在在深度为 <code>d</code> 的节点（一开始你在根节点，深度为 0），那么这个序列的第 <code>d+1</code>（0-based）位为 0 代表你应该去当前节点的左儿子，为 1 说明你应该去右儿子。</p><p>而如果 <code>d+1</code> 已经等于序列长度了（也就是说操作全部做完了），你就到达目标节点了。</p><p>复杂度 $O(\log n)+O(\log n)=O(\log n)$。</p><h3 id=set>set<a hidden class=anchor aria-hidden=true href=#set>#</a></h3><p>同样的，在列表中顺序查找到访问下标所处的树，然后对它进行可持久化修改即可。返回新的列表，共用其他没有被修改的树，中间 cons 上修改后返回的新树。</p><p>可持久化修改也很简单：找到你要修改的节点（方法和 access 是一样的），把它换成一个新的节点，上面存的值是你修改后的新值，但是两个儿子和之前一样。</p><p>对于它的所有祖先节点，都重造一个新的节点，存的值以及指向没有被修改的那个子树的指针不变，但指向被修改了的子树的指针指向修改后的新子树节点。</p><p>具体都可以见代码。</p><h2 id=应用场景>应用场景<a hidden class=anchor aria-hidden=true href=#应用场景>#</a></h2><p>没什么应用场景。如果你发现你需要用到大量的 list-ref，可以考虑这个。或者如果你需要一个能够 push_back 的可持久化数组。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/algorithms/>Algorithms</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>正确即是废话，废话亦是正确</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>