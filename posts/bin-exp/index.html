<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>宏，中缀表达式，自定义语法与可编程的编程语言 | 正确即是废话，废话亦是正确</title><meta name=keywords content="PLT,lisp/scheme/racket"><meta name=description content="光剑后日谈 #2.
在 Scheme/Racket 的世界里，我们常说“一切代码皆为 S-expression”。一个函数调用是 (函数名 参数1 参数2)，一个列表是 (元素1 元素2 元素3)，它们都遵循着括号包裹、前缀表示的统一形式。
但细心的你可能会问，'(a b c) 或者 #'(+ 1 stx) 呢？开头的那个 ' 或 #' 字符，怎么看也不像是列表的一部分。它们是如何融入这套 S-expression 体系的？
答案很简单：它们是一种语法糖。我们都知道 'exp 等价于 (quote exp)，#'exp 等价于 (syntax exp)。这个单引号 ' 仿佛是一个别名，在 Racket 读取我们的代码时，就悄无声息地将它转换成了标准的形式。这种在“读取阶段”就生效的转换规则，被称为读取器宏（Reader Macro）。
读取器宏背后，是整个 Lisp 家族语言引以为傲的宏系统。宏是一种强大的元编程工具，它本质上是一个在编译期（或称为“展开时”）执行的函数。这个特殊的函数，它的输入是代码（以语法对象的形式），输出也是代码。它允许我们对代码进行任意复杂的、图灵完备的变换，从而彻底扩展语言本身的语法。
那么，亲手编写一个宏，究竟是怎样的体验呢？
宏之初体验：编写你的第一个宏 when
让我们从一个简单的需求开始。在编程中，我们经常遇到一个场景：“当某个条件成立时，执行一系列操作”。用 Racket 的 if 可以这样写：


1
2
3
4
5


(if (< user-level 5)
    (begin
      (display &#34;权限不足！&#34;)
      (log-warning &#34;Attempted access by low-level user.&#34;))
    #f)


每次都写 (begin ...) 有点繁琐（更何况 Racket 强制 if 有两个分支，那个不需要的分支混淆了语义）。如果我们能创造一个新语法 when，让代码变成下面这样，岂不是更清晰？"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/bin-exp/><link crossorigin=anonymous href=/assets/css/stylesheet.0abe74e9285d02ff17a1d5d9725d52c7a4cbdc65c4e3cad1528047eb09ad5ac9.css integrity="sha256-Cr506ShdAv8XodXZcl1Sx6TL3GXE48rRUoBH6wmtWsk=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/bin-exp/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/bin-exp/"><meta property="og:site_name" content="正确即是废话，废话亦是正确"><meta property="og:title" content="宏，中缀表达式，自定义语法与可编程的编程语言"><meta property="og:description" content="光剑后日谈 #2.
在 Scheme/Racket 的世界里，我们常说“一切代码皆为 S-expression”。一个函数调用是 (函数名 参数1 参数2)，一个列表是 (元素1 元素2 元素3)，它们都遵循着括号包裹、前缀表示的统一形式。
但细心的你可能会问，'(a b c) 或者 #'(+ 1 stx) 呢？开头的那个 ' 或 #' 字符，怎么看也不像是列表的一部分。它们是如何融入这套 S-expression 体系的？
答案很简单：它们是一种语法糖。我们都知道 'exp 等价于 (quote exp)，#'exp 等价于 (syntax exp)。这个单引号 ' 仿佛是一个别名，在 Racket 读取我们的代码时，就悄无声息地将它转换成了标准的形式。这种在“读取阶段”就生效的转换规则，被称为读取器宏（Reader Macro）。
读取器宏背后，是整个 Lisp 家族语言引以为傲的宏系统。宏是一种强大的元编程工具，它本质上是一个在编译期（或称为“展开时”）执行的函数。这个特殊的函数，它的输入是代码（以语法对象的形式），输出也是代码。它允许我们对代码进行任意复杂的、图灵完备的变换，从而彻底扩展语言本身的语法。
那么，亲手编写一个宏，究竟是怎样的体验呢？
宏之初体验：编写你的第一个宏 when 让我们从一个简单的需求开始。在编程中，我们经常遇到一个场景：“当某个条件成立时，执行一系列操作”。用 Racket 的 if 可以这样写：
1 2 3 4 5 (if (< user-level 5) (begin (display &#34;权限不足！&#34;) (log-warning &#34;Attempted access by low-level user.&#34;)) #f) 每次都写 (begin ...) 有点繁琐（更何况 Racket 强制 if 有两个分支，那个不需要的分支混淆了语义）。如果我们能创造一个新语法 when，让代码变成下面这样，岂不是更清晰？"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-22T21:52:41+08:00"><meta property="article:modified_time" content="2025-10-22T21:52:41+08:00"><meta property="article:tag" content="PLT"><meta property="article:tag" content="Lisp/Scheme/Racket"><meta property="og:see_also" content="https://litjohn.github.io/posts/start-to-build-a-compiler/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call-cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/"><meta name=twitter:card content="summary"><meta name=twitter:title content="宏，中缀表达式，自定义语法与可编程的编程语言"><meta name=twitter:description content="光剑后日谈 #2.
在 Scheme/Racket 的世界里，我们常说“一切代码皆为 S-expression”。一个函数调用是 (函数名 参数1 参数2)，一个列表是 (元素1 元素2 元素3)，它们都遵循着括号包裹、前缀表示的统一形式。
但细心的你可能会问，'(a b c) 或者 #'(+ 1 stx) 呢？开头的那个 ' 或 #' 字符，怎么看也不像是列表的一部分。它们是如何融入这套 S-expression 体系的？
答案很简单：它们是一种语法糖。我们都知道 'exp 等价于 (quote exp)，#'exp 等价于 (syntax exp)。这个单引号 ' 仿佛是一个别名，在 Racket 读取我们的代码时，就悄无声息地将它转换成了标准的形式。这种在“读取阶段”就生效的转换规则，被称为读取器宏（Reader Macro）。
读取器宏背后，是整个 Lisp 家族语言引以为傲的宏系统。宏是一种强大的元编程工具，它本质上是一个在编译期（或称为“展开时”）执行的函数。这个特殊的函数，它的输入是代码（以语法对象的形式），输出也是代码。它允许我们对代码进行任意复杂的、图灵完备的变换，从而彻底扩展语言本身的语法。
那么，亲手编写一个宏，究竟是怎样的体验呢？
宏之初体验：编写你的第一个宏 when
让我们从一个简单的需求开始。在编程中，我们经常遇到一个场景：“当某个条件成立时，执行一系列操作”。用 Racket 的 if 可以这样写：


1
2
3
4
5


(if (< user-level 5)
    (begin
      (display &#34;权限不足！&#34;)
      (log-warning &#34;Attempted access by low-level user.&#34;))
    #f)


每次都写 (begin ...) 有点繁琐（更何况 Racket 强制 if 有两个分支，那个不需要的分支混淆了语义）。如果我们能创造一个新语法 when，让代码变成下面这样，岂不是更清晰？"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"宏，中缀表达式，自定义语法与可编程的编程语言","item":"https://litjohn.github.io/posts/bin-exp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"宏，中缀表达式，自定义语法与可编程的编程语言","name":"宏，中缀表达式，自定义语法与可编程的编程语言","description":"光剑后日谈 #2.\n在 Scheme/Racket 的世界里，我们常说“一切代码皆为 S-expression”。一个函数调用是 (函数名 参数1 参数2)，一个列表是 (元素1 元素2 元素3)，它们都遵循着括号包裹、前缀表示的统一形式。\n但细心的你可能会问，'(a b c) 或者 #'(+ 1 stx) 呢？开头的那个 ' 或 #' 字符，怎么看也不像是列表的一部分。它们是如何融入这套 S-expression 体系的？\n答案很简单：它们是一种语法糖。我们都知道 'exp 等价于 (quote exp)，#'exp 等价于 (syntax exp)。这个单引号 ' 仿佛是一个别名，在 Racket 读取我们的代码时，就悄无声息地将它转换成了标准的形式。这种在“读取阶段”就生效的转换规则，被称为读取器宏（Reader Macro）。\n读取器宏背后，是整个 Lisp 家族语言引以为傲的宏系统。宏是一种强大的元编程工具，它本质上是一个在编译期（或称为“展开时”）执行的函数。这个特殊的函数，它的输入是代码（以语法对象的形式），输出也是代码。它允许我们对代码进行任意复杂的、图灵完备的变换，从而彻底扩展语言本身的语法。\n那么，亲手编写一个宏，究竟是怎样的体验呢？\n宏之初体验：编写你的第一个宏 when 让我们从一个简单的需求开始。在编程中，我们经常遇到一个场景：“当某个条件成立时，执行一系列操作”。用 Racket 的 if 可以这样写：\n1 2 3 4 5 (if (\u0026lt; user-level 5) (begin (display \u0026#34;权限不足！\u0026#34;) (log-warning \u0026#34;Attempted access by low-level user.\u0026#34;)) #f) 每次都写 (begin ...) 有点繁琐（更何况 Racket 强制 if 有两个分支，那个不需要的分支混淆了语义）。如果我们能创造一个新语法 when，让代码变成下面这样，岂不是更清晰？\n","keywords":["PLT","lisp/scheme/racket"],"articleBody":"光剑后日谈 #2.\n在 Scheme/Racket 的世界里，我们常说“一切代码皆为 S-expression”。一个函数调用是 (函数名 参数1 参数2)，一个列表是 (元素1 元素2 元素3)，它们都遵循着括号包裹、前缀表示的统一形式。\n但细心的你可能会问，'(a b c) 或者 #'(+ 1 stx) 呢？开头的那个 ' 或 #' 字符，怎么看也不像是列表的一部分。它们是如何融入这套 S-expression 体系的？\n答案很简单：它们是一种语法糖。我们都知道 'exp 等价于 (quote exp)，#'exp 等价于 (syntax exp)。这个单引号 ' 仿佛是一个别名，在 Racket 读取我们的代码时，就悄无声息地将它转换成了标准的形式。这种在“读取阶段”就生效的转换规则，被称为读取器宏（Reader Macro）。\n读取器宏背后，是整个 Lisp 家族语言引以为傲的宏系统。宏是一种强大的元编程工具，它本质上是一个在编译期（或称为“展开时”）执行的函数。这个特殊的函数，它的输入是代码（以语法对象的形式），输出也是代码。它允许我们对代码进行任意复杂的、图灵完备的变换，从而彻底扩展语言本身的语法。\n那么，亲手编写一个宏，究竟是怎样的体验呢？\n宏之初体验：编写你的第一个宏 when 让我们从一个简单的需求开始。在编程中，我们经常遇到一个场景：“当某个条件成立时，执行一系列操作”。用 Racket 的 if 可以这样写：\n1 2 3 4 5 (if (\u003c user-level 5) (begin (display \"权限不足！\") (log-warning \"Attempted access by low-level user.\")) #f) 每次都写 (begin ...) 有点繁琐（更何况 Racket 强制 if 有两个分支，那个不需要的分支混淆了语义）。如果我们能创造一个新语法 when，让代码变成下面这样，岂不是更清晰？\n1 2 3 (when (\u003c user-level 5) (display \"权限不足！\") (log-warning \"Attempted access by low-level user.\")) 这个 when 无法用普通函数实现，因为函数会立即计算所有参数的值，而我们希望只有在条件为真时才执行后面的操作。这正是宏的用武之地。\n在 Racket 中，我们可以用 define-syntax 和 syntax-rules 来定义简单的宏，它的工作方式就像“查找与替换”的模式匹配。\n1 2 3 4 5 6 7 8 #lang racket (define-syntax when (syntax-rules () [(_ condition body ...) (if condition (begin body ...) (void))])) 让我们来拆解这段神奇的代码：\n(define-syntax when ...)：我们声明，when 不是一个函数或变量，而是一个新的语法。 (syntax-rules () ...)：这是一个简单宏的声明，() 表示这个宏里没有特殊的关键字（暂不深究）。 [(_ condition body ...)]：这是匹配模式。 _ (下划线) 是一个占位符，它能够匹配任意单个 S-expression 并忽略它。在这里，它会匹配宏调用中的第一个 S-expression，也就是宏的名字 when 本身。 condition 是一个模式变量，它会匹配 when 后面的第一个表达式。 body ... 是最巧妙的部分。... (省略号) 表示它会匹配接下来零个或多个表达式，并将它们收集到一个序列里。 (if condition (begin body ...) (void))：这是输出模板。 它描述了目标代码的样子。condition 和 body 是上面的模式匹配部分捕获的模式变量。在一个真正的宏调用中，它们会被替换成模式中的实际内容。 所以，当我们写下 (when (\u003c user-level 5) (display \"...\") (log-warning \"...\")) 时，宏展开器会：\n匹配到 condition 是 (\u003c user-level 5)。 匹配到 body ... 是 (display \"...\") 和 (log-warning \"...\") 两个表达式。 然后将它们填充到模板中，最终代码被转换为：(if (\u003c user-level 5) (begin (display \"...\") (log-warning \"...\")) (void))。 编译器真正看到的，永远是转换后的标准 Racket 代码。我们通过宏，成功地为语言添加了一个新的控制结构。\n这就是 define-syntax 和 syntax-rules。它们提供了简单易用的构造新语法的能力。具体的用法是这样的：\n1 2 3 4 5 (define-syntax name (syntax-rules ...)) syntax-rules 的每一个 clause（子句）形如 (pattern template)。用过模式匹配的朋友应该很熟，pattern 部分会匹配宏调用的模式，如果匹配成功就会对其中的模式变量进行绑定，然后将 template 部分中的模式变量替换为它们的值作为宏的输出。syntax-rules 展开时会从上到下依次尝试匹配每条子句，如果没有任何子句能够匹配就报错。syntax-rules 支持 (else ...) 这样的子句，else 能够匹配任何东西。\nspecial-words 列表则指定一些特殊关键字，它们会被精确匹配，而不是作为模式变量名匹配并绑定任意值。你只需要把精确匹配关键字加到列表里就可以了，比如 (syntax-rules (keyword1 keyword2 ...) ...)。\n对于只有一个子句的 syntax-rules，可以用 define-syntax-rule 这个语法糖进一步简化。\n突然发现 Racket 官网上的文档非常好。那我就省去说明的口舌了，大家都去读文档吧。借助 genAI 会很轻松。\n宏之意义：一门可编程的编程语言 通过 when 这个小例子，我们看到了宏如何让我们创造新的语法。但这只是冰山一角。这种“用代码生成代码”的能力，正是 Racket 被誉为“可编程的编程语言（Programmable Programming Language）” 的核心。\n在上一篇文章 https://litjohn.github.io/posts/start-to-build-a-compiler/ 中，我们构建了一个源到源的编译器。其实，宏系统本身就是一个内嵌在语言里的微型编译器。它接受你用扩展语法写成的代码，然后把它转换成标准的 Racket 代码。\n这赋予了我们极大的自由：\n构建领域特定语言（DSL）：当你在解决某个特定领域的问题时（如图形、数据库查询、并发控制），你可以利用宏创造一套专为此领域设计的语法，让代码读起来更像是对问题的直接描述。 抽象样板代码：将复杂的、重复的代码模式封装成一个简洁的宏。 创造新的语言范式：你甚至可以在 Racket 中用宏实现面向对象、逻辑编程等不同的编程范式。 Racket 著名的 #lang 机制，允许我们把整个文件切换成另一种“语言”，其背后也是宏系统的强大支撑。\n宏之进阶：迈向更复杂的变换 syntax-rules 对于简单的模式匹配非常方便，但如果我们的语法转换需要更复杂的逻辑呢？比如，我们想在 Racket 中直接写中缀表达式：\n(bin-exp 1 + (2 + 3 + 4) * 5 + 6)\n我们希望 Racket 能正确理解运算符的优先级，将它转换为标准的前缀表达式 (+ (+ 1 (* (+ 2 3 4) 5)) 6)。\n这个任务无法通过简单的模式匹配完成。我们需要一个真正的解析算法：遍历表达式，找到优先级最低的运算符（在这里是最后的 +），将其作为根节点，然后递归地处理左右两边的子表达式。这是一个计算过程。\n为此，Racket 提供了更强大的宏工具 syntax-case。与 syntax-rules 不同，syntax-case 允许你在宏展开阶段执行任意的 Racket 代码来分析和构建语法。你可以编写辅助函数，在编译期对输入的语法对象进行遍历、判断和重组，最终生成目标代码。\n实现 bin-exp 的过程，本质上就是在 Racket 的宏系统里，为中缀表达式这个“迷你语言”编写一个微型解析器。这完美地展示了宏的图灵完备计算能力。\n当然这个转换的算法大概不用我说。各位身为 OIer 应该都会做这个入门题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #lang racket (begin-for-syntax (define (find-last-add exp-vec l r) (let loop ([i (sub1 r)]) (if (\u003c i l) #f (if (eq? (vector-ref exp-vec i) '+) i (loop (sub1 i))))))) (begin-for-syntax (define (find-last-mul exp-vec l r) (let loop ([i (sub1 r)]) (if (\u003c i l) #f (if (eq? (vector-ref exp-vec i) '*) i (loop (sub1 i))))))) (begin-for-syntax (define (transform exp-vec l r) (if (= (add1 l) r) (let ([tmp (vector-ref exp-vec l)]) (if (not (pair? tmp)) tmp (let ([v (list-\u003evector tmp)]) (transform v 0 (vector-length v))))) (let ([add-pos (find-last-add exp-vec l r)]) (if add-pos `(+ ,(transform exp-vec l add-pos) ,(transform exp-vec (add1 add-pos) r)) (let ([mul-pos (find-last-mul exp-vec l r)]) (if mul-pos `(* ,(transform exp-vec l mul-pos) ,(transform exp-vec (add1 mul-pos) r)) (error \"Invalid input!\")))))))) (define-syntax bin-exp (lambda (stx) (syntax-case stx () [(_ . exp) (let ([exp-vec (list-\u003evector (syntax-\u003edatum #'exp))]) (datum-\u003esyntax #'exp (transform exp-vec 0 (vector-length exp-vec))))]))) 注意上面的几个辅助函数都被 begin-for-syntax 包裹了。这是必要的，如果去掉会编译错误。因为宏和函数的存在时期不一样，函数存在于运行时，但那时宏早已不存在了。宏无法引用更晚才被定义的函数，所以需要使用这个语法。它就像 C++ 的 constexpr 能够标记一个函数在编译期求值一样，标记一个函数是给宏使用的辅助函数，存在于宏展开期。\n以及注意我们寻找运算符是从右到左的。这是实现左结合性的必要操作。对于加法和乘法，左结合或右结合都无所谓，但是一旦引入减法，这就成为了一个必须要注意的细节。\n一个有趣的问题：如果一个被标记为 begin-for-syntax 的函数需要用到一个宏呢？而如果这个函数和宏互相引用呢？\n结论 我们从一个不起眼的单引号 ' 出发，通过亲手实现一个简单的 when 宏，窥见了 Racket 宏系统的基本工作原理。进而，我们理解了宏如何赋予我们创造 DSL、甚至重塑语言的能力，这是“可编程的编程语言”这一称号的底气所在。最后，我们看到了像中缀表达式解析这样的复杂任务，展示了宏系统深不可测的潜力。\nLisp/Scheme/Racket 的宏系统邀请我们从一个语言的“使用者”，转变为一个语言的“设计者”。它给予了我们工具，去打造最适合我们问题的语言。这是一种深刻而强大的编程思想。\n","wordCount":"538","inLanguage":"en","datePublished":"2025-10-22T21:52:41+08:00","dateModified":"2025-10-22T21:52:41+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/bin-exp/"},"publisher":{"@type":"Organization","name":"正确即是废话，废话亦是正确","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="正确即是废话，废话亦是正确 (Alt + H)">正确即是废话，废话亦是正确</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">宏，中缀表达式，自定义语法与可编程的编程语言</h1><div class=post-meta><span title='2025-10-22 21:52:41 +0800 +0800'>October 22, 2025</span></div></header><div class=post-content><p>光剑后日谈 #2.</p><p>在 Scheme/Racket 的世界里，我们常说“一切代码皆为 S-expression”。一个函数调用是 <code>(函数名 参数1 参数2)</code>，一个列表是 <code>(元素1 元素2 元素3)</code>，它们都遵循着括号包裹、前缀表示的统一形式。</p><p>但细心的你可能会问，<code>'(a b c)</code> 或者 <code>#'(+ 1 stx)</code> 呢？开头的那个 <code>'</code> 或 <code>#'</code> 字符，怎么看也不像是列表的一部分。它们是如何融入这套 S-expression 体系的？</p><p>答案很简单：它们是一种语法糖。我们都知道 <code>'exp</code> 等价于 <code>(quote exp)</code>，<code>#'exp</code> 等价于 <code>(syntax exp)</code>。这个单引号 <code>'</code> 仿佛是一个别名，在 Racket 读取我们的代码时，就悄无声息地将它转换成了标准的形式。这种在“读取阶段”就生效的转换规则，被称为<strong>读取器宏（Reader Macro）</strong>。</p><p>读取器宏背后，是整个 Lisp 家族语言引以为傲的宏系统。宏是一种强大的元编程工具，它本质上是一个在<strong>编译期</strong>（或称为“展开时”）执行的函数。这个特殊的函数，它的输入是代码（以语法对象的形式），输出也是代码。它允许我们对代码进行任意复杂的、图灵完备的变换，从而彻底扩展语言本身的语法。</p><p>那么，亲手编写一个宏，究竟是怎样的体验呢？</p><h3 id=宏之初体验编写你的第一个宏-when>宏之初体验：编写你的第一个宏 <code>when</code><a hidden class=anchor aria-hidden=true href=#宏之初体验编写你的第一个宏-when>#</a></h3><p>让我们从一个简单的需求开始。在编程中，我们经常遇到一个场景：“当某个条件成立时，执行一系列操作”。用 Racket 的 <code>if</code> 可以这样写：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>user-level</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>begin</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>display</span> <span class=s2>&#34;权限不足！&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>log-warning</span> <span class=s2>&#34;Attempted access by low-level user.&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=no>#f</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>每次都写 <code>(begin ...)</code> 有点繁琐（更何况 Racket 强制 if 有两个分支，那个不需要的分支混淆了语义）。如果我们能创造一个新语法 <code>when</code>，让代码变成下面这样，岂不是更清晰？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>when</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>user-level</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>display</span> <span class=s2>&#34;权限不足！&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>log-warning</span> <span class=s2>&#34;Attempted access by low-level user.&#34;</span><span class=p>))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这个 <code>when</code> 无法用普通函数实现，因为函数会立即计算所有参数的值，而我们希望只有在条件为真时才执行后面的操作。这正是宏的用武之地。</p><p>在 Racket 中，我们可以用 <code>define-syntax</code> 和 <code>syntax-rules</code> 来定义简单的宏，它的工作方式就像“查找与替换”的模式匹配。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax</span> <span class=k>when</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>syntax-rules</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=k>_</span> <span class=n>condition</span> <span class=n>body</span> <span class=k>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>if</span> <span class=n>condition</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>begin</span> <span class=n>body</span> <span class=k>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=nb>void</span><span class=p>))]))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>让我们来拆解这段神奇的代码：</p><ol><li><strong><code>(define-syntax when ...)</code></strong>：我们声明，<code>when</code> 不是一个函数或变量，而是一个新的<strong>语法</strong>。</li><li><strong><code>(syntax-rules () ...)</code></strong>：这是一个简单宏的声明，<code>()</code> 表示这个宏里没有特殊的关键字（暂不深究）。</li><li><strong><code>[(_ condition body ...)]</code></strong>：这是<strong>匹配模式</strong>。<ul><li><code>_</code> (下划线) 是一个占位符，它能够匹配任意单个 S-expression 并忽略它。在这里，它会匹配宏调用中的第一个 S-expression，也就是宏的名字 <code>when</code> 本身。</li><li><code>condition</code> 是一个模式变量，它会匹配 <code>when</code> 后面的第一个表达式。</li><li><code>body ...</code> 是最巧妙的部分。<code>...</code> (省略号) 表示它会匹配接下来<strong>零个或多个</strong>表达式，并将它们收集到一个序列里。</li></ul></li><li><strong><code>(if condition (begin body ...) (void))</code></strong>：这是<strong>输出模板</strong>。<ul><li>它描述了目标代码的样子。<code>condition</code> 和 <code>body</code> 是上面的模式匹配部分捕获的模式变量。在一个真正的宏调用中，它们会被替换成模式中的实际内容。</li></ul></li></ol><p>所以，当我们写下 <code>(when (&lt; user-level 5) (display "...") (log-warning "..."))</code> 时，宏展开器会：</p><ul><li>匹配到 <code>condition</code> 是 <code>(&lt; user-level 5)</code>。</li><li>匹配到 <code>body ...</code> 是 <code>(display "...")</code> 和 <code>(log-warning "...")</code> 两个表达式。</li><li>然后将它们填充到模板中，最终代码被转换为：<code>(if (&lt; user-level 5) (begin (display "...") (log-warning "...")) (void))</code>。</li></ul><p>编译器真正看到的，永远是转换后的标准 Racket 代码。我们通过宏，成功地为语言添加了一个新的控制结构。</p><p>这就是 <code>define-syntax</code> 和 <code>syntax-rules</code>。它们提供了简单易用的构造新语法的能力。具体的用法是这样的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>syntax-rules</span> <span class=n>&lt;special-words&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>&lt;clause1&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>&lt;clause2&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>...</span><span class=p>))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p><code>syntax-rules</code> 的每一个 clause（子句）形如 <code>(pattern template)</code>。用过模式匹配的朋友应该很熟，<code>pattern</code> 部分会匹配宏调用的模式，如果匹配成功就会对其中的模式变量进行绑定，然后将 <code>template</code> 部分中的模式变量替换为它们的值作为宏的输出。<code>syntax-rules</code> 展开时会从上到下依次尝试匹配每条子句，如果没有任何子句能够匹配就报错。<code>syntax-rules</code> 支持 <code>(else ...)</code> 这样的子句，<code>else</code> 能够匹配任何东西。</p><p>special-words 列表则指定一些特殊关键字，它们会被精确匹配，而不是作为模式变量名匹配并绑定任意值。你只需要把精确匹配关键字加到列表里就可以了，比如 <code>(syntax-rules (keyword1 keyword2 ...) ...)</code>。</p><p>对于只有一个子句的 <code>syntax-rules</code>，可以用 <code>define-syntax-rule</code> 这个语法糖进一步简化。</p><p>突然发现 Racket 官网上的<a href=https://docs.racket-lang.org/guide/macros.html>文档</a>非常好。那我就省去说明的口舌了，大家都去读文档吧。借助 genAI 会很轻松。</p><h3 id=宏之意义一门可编程的编程语言>宏之意义：一门可编程的编程语言<a hidden class=anchor aria-hidden=true href=#宏之意义一门可编程的编程语言>#</a></h3><p>通过 <code>when</code> 这个小例子，我们看到了宏如何让我们创造新的语法。但这只是冰山一角。这种“用代码生成代码”的能力，正是 Racket 被誉为“<strong>可编程的编程语言（Programmable Programming Language）</strong>” 的核心。</p><p>在上一篇文章 <a href=https://litjohn.github.io/posts/start-to-build-a-compiler/>https://litjohn.github.io/posts/start-to-build-a-compiler/</a> 中，我们构建了一个源到源的编译器。其实，宏系统本身就是一个内嵌在语言里的微型编译器。它接受你用扩展语法写成的代码，然后把它转换成标准的 Racket 代码。</p><p>这赋予了我们极大的自由：</p><ul><li><strong>构建领域特定语言（DSL）</strong>：当你在解决某个特定领域的问题时（如图形、数据库查询、并发控制），你可以利用宏创造一套专为此领域设计的语法，让代码读起来更像是对问题的直接描述。</li><li><strong>抽象样板代码</strong>：将复杂的、重复的代码模式封装成一个简洁的宏。</li><li><strong>创造新的语言范式</strong>：你甚至可以在 Racket 中用宏实现面向对象、逻辑编程等不同的编程范式。</li></ul><p>Racket 著名的 <code>#lang</code> 机制，允许我们把整个文件切换成另一种“语言”，其背后也是宏系统的强大支撑。</p><h3 id=宏之进阶迈向更复杂的变换>宏之进阶：迈向更复杂的变换<a hidden class=anchor aria-hidden=true href=#宏之进阶迈向更复杂的变换>#</a></h3><p><code>syntax-rules</code> 对于简单的模式匹配非常方便，但如果我们的语法转换需要更复杂的逻辑呢？比如，我们想在 Racket 中直接写中缀表达式：</p><p><code>(bin-exp 1 + (2 + 3 + 4) * 5 + 6)</code></p><p>我们希望 Racket 能正确理解运算符的优先级，将它转换为标准的前缀表达式 <code>(+ (+ 1 (* (+ 2 3 4) 5)) 6)</code>。</p><p>这个任务无法通过简单的模式匹配完成。我们需要一个真正的解析算法：遍历表达式，找到优先级最低的运算符（在这里是最后的 <code>+</code>），将其作为根节点，然后递归地处理左右两边的子表达式。这是一个计算过程。</p><p>为此，Racket 提供了更强大的宏工具 <code>syntax-case</code>。与 <code>syntax-rules</code> 不同，<code>syntax-case</code> 允许你在宏展开阶段执行<strong>任意的 Racket 代码</strong>来分析和构建语法。你可以编写辅助函数，在编译期对输入的语法对象进行遍历、判断和重组，最终生成目标代码。</p><p>实现 <code>bin-exp</code> 的过程，本质上就是在 Racket 的宏系统里，为中缀表达式这个“迷你语言”编写一个微型解析器。这完美地展示了宏的图灵完备计算能力。</p><p>当然这个转换的算法大概不用我说。各位身为 OIer 应该都会做这个入门题。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>begin-for-syntax</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>find-last-add</span> <span class=n>exp-vec</span> <span class=n>l</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>r</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=no>#f</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>exp-vec</span> <span class=n>i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>+</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=n>i</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>i</span><span class=p>)))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>begin-for-syntax</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>find-last-mul</span> <span class=n>exp-vec</span> <span class=n>l</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>r</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=no>#f</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>exp-vec</span> <span class=n>i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=n>i</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>sub1</span> <span class=n>i</span><span class=p>)))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>begin-for-syntax</span> <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>transform</span> <span class=n>exp-vec</span> <span class=n>l</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>=</span> <span class=p>(</span><span class=nb>add1</span> <span class=n>l</span><span class=p>)</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>tmp</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>exp-vec</span> <span class=n>l</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>not</span> <span class=p>(</span><span class=nb>pair?</span> <span class=n>tmp</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>tmp</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>v</span> <span class=p>(</span><span class=nb>list-&gt;vector</span> <span class=n>tmp</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=n>transform</span> <span class=n>v</span> <span class=mi>0</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>v</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>add-pos</span> <span class=p>(</span><span class=n>find-last-add</span> <span class=n>exp-vec</span> <span class=n>l</span> <span class=n>r</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>if</span> <span class=n>add-pos</span>
</span></span><span class=line><span class=cl>                <span class=o>`</span><span class=p>(</span><span class=ss>+</span> <span class=o>,</span><span class=p>(</span><span class=n>transform</span> <span class=n>exp-vec</span> <span class=n>l</span> <span class=n>add-pos</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>transform</span> <span class=n>exp-vec</span> <span class=p>(</span><span class=nb>add1</span> <span class=n>add-pos</span><span class=p>)</span> <span class=n>r</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>mul-pos</span> <span class=p>(</span><span class=n>find-last-mul</span> <span class=n>exp-vec</span> <span class=n>l</span> <span class=n>r</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=k>if</span> <span class=n>mul-pos</span>
</span></span><span class=line><span class=cl>                        <span class=o>`</span><span class=p>(</span><span class=ss>*</span> <span class=o>,</span><span class=p>(</span><span class=n>transform</span> <span class=n>exp-vec</span> <span class=n>l</span> <span class=n>mul-pos</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>transform</span> <span class=n>exp-vec</span> <span class=p>(</span><span class=nb>add1</span> <span class=n>mul-pos</span><span class=p>)</span> <span class=n>r</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Invalid input!&#34;</span><span class=p>))))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax</span> <span class=n>bin-exp</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=n>stx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>syntax-case</span> <span class=n>stx</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=p>[(</span><span class=k>_</span> <span class=o>.</span> <span class=nb>exp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>exp-vec</span> <span class=p>(</span><span class=nb>list-&gt;vector</span> <span class=p>(</span><span class=nb>syntax-&gt;datum</span> <span class=o>#&#39;</span><span class=nb>exp</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=nb>datum-&gt;syntax</span> 
</span></span><span class=line><span class=cl>                        <span class=o>#&#39;</span><span class=nb>exp</span>
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=n>transform</span> 
</span></span><span class=line><span class=cl>                            <span class=n>exp-vec</span> 
</span></span><span class=line><span class=cl>                            <span class=mi>0</span>
</span></span><span class=line><span class=cl>                            <span class=p>(</span><span class=nb>vector-length</span> <span class=n>exp-vec</span><span class=p>))))])))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>注意上面的几个辅助函数都被 <code>begin-for-syntax</code> 包裹了。这是必要的，如果去掉会编译错误。因为宏和函数的存在时期不一样，函数存在于运行时，但那时宏早已不存在了。宏无法引用更晚才被定义的函数，所以需要使用这个语法。它就像 C++ 的 constexpr 能够标记一个函数在编译期求值一样，标记一个函数是给宏使用的辅助函数，存在于宏展开期。</p><p>以及注意我们寻找运算符是从右到左的。这是实现左结合性的必要操作。对于加法和乘法，左结合或右结合都无所谓，但是一旦引入减法，这就成为了一个必须要注意的细节。</p><p>一个有趣的问题：如果一个被标记为 <code>begin-for-syntax</code> 的函数需要用到一个宏呢？而如果这个函数和宏互相引用呢？</p><h3 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h3><p>我们从一个不起眼的单引号 <code>'</code> 出发，通过亲手实现一个简单的 <code>when</code> 宏，窥见了 Racket 宏系统的基本工作原理。进而，我们理解了宏如何赋予我们创造 DSL、甚至重塑语言的能力，这是“可编程的编程语言”这一称号的底气所在。最后，我们看到了像中缀表达式解析这样的复杂任务，展示了宏系统深不可测的潜力。</p><p>Lisp/Scheme/Racket 的宏系统邀请我们从一个语言的“使用者”，转变为一个语言的“设计者”。它给予了我们工具，去打造最适合我们问题的语言。这是一种深刻而强大的编程思想。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/plt/>PLT</a></li><li><a href=https://litjohn.github.io/tags/lisp/scheme/racket/>Lisp/Scheme/Racket</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>正确即是废话，废话亦是正确</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>