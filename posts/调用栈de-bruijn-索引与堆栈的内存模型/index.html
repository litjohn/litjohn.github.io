<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>调用栈、de Bruijn 索引与堆栈的内存模型 | litjohn's blog</title><meta name=keywords content="PLT,lisp/scheme/racket"><meta name=description content="光剑系列的第六作！
（放一个 Gemini 生成的欧比旺的图来解释一下光剑是什么）

前五作：

第一篇：Let&rsquo;s build our mathematics by using lambda calculus && church encoding!
第二篇：惰性求值、无穷流与发生的魔法
第三篇：协程、生成器与 call/cc 的控制流
第四篇：动态作用域、词法作用域与表达式求值的环境模型
第五篇：基于环境模型的解释器

我们上篇文章写了解释器。在评论区里面可以看到一个非常神秘的东西：https://www.zhihu.com/question/30262900/answer/1943149381147660845


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


; 嵌套的括号不是 scheme 标准语法。表示定义柯里化的函数，和嵌套 lambda 等价。racket 支持这一扩展语法。
(define (Z env)
  (car env))
(define ((S vp) env)
  (vp (cdr env)))
(define ((Lam e) env)
  (lambda (x)
    (e (cons x env))))
(define ((App e1 e2) env)
  ((e1 env) (e2 env)))

; (define global-env '())


顺便，还有人问我为什么不再布置一道习题，那么这就是习题！"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><meta property="og:site_name" content="litjohn's blog"><meta property="og:title" content="调用栈、de Bruijn 索引与堆栈的内存模型"><meta property="og:description" content="光剑系列的第六作！
（放一个 Gemini 生成的欧比旺的图来解释一下光剑是什么） 前五作：
第一篇：Let’s build our mathematics by using lambda calculus && church encoding! 第二篇：惰性求值、无穷流与发生的魔法 第三篇：协程、生成器与 call/cc 的控制流 第四篇：动态作用域、词法作用域与表达式求值的环境模型 第五篇：基于环境模型的解释器 我们上篇文章写了解释器。在评论区里面可以看到一个非常神秘的东西：https://www.zhihu.com/question/30262900/answer/1943149381147660845
1 2 3 4 5 6 7 8 9 10 11 12 ; 嵌套的括号不是 scheme 标准语法。表示定义柯里化的函数，和嵌套 lambda 等价。racket 支持这一扩展语法。 (define (Z env) (car env)) (define ((S vp) env) (vp (cdr env))) (define ((Lam e) env) (lambda (x) (e (cons x env)))) (define ((App e1 e2) env) ((e1 env) (e2 env))) ; (define global-env '()) 顺便，还有人问我为什么不再布置一道习题，那么这就是习题！"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-13T15:22:34+08:00"><meta property="article:modified_time" content="2025-10-13T15:22:34+08:00"><meta property="article:tag" content="PLT"><meta property="article:tag" content="Lisp/Scheme/Racket"><meta property="og:see_also" content="https://litjohn.github.io/posts/start-to-build-a-compiler/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call/cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/"><meta property="og:see_also" content="https://litjohn.github.io/posts/lets-build-our-mathematics-by-using-lambda-calculus--church-encoding/"><meta name=twitter:card content="summary"><meta name=twitter:title content="调用栈、de Bruijn 索引与堆栈的内存模型"><meta name=twitter:description content="光剑系列的第六作！
（放一个 Gemini 生成的欧比旺的图来解释一下光剑是什么）

前五作：

第一篇：Let&rsquo;s build our mathematics by using lambda calculus && church encoding!
第二篇：惰性求值、无穷流与发生的魔法
第三篇：协程、生成器与 call/cc 的控制流
第四篇：动态作用域、词法作用域与表达式求值的环境模型
第五篇：基于环境模型的解释器

我们上篇文章写了解释器。在评论区里面可以看到一个非常神秘的东西：https://www.zhihu.com/question/30262900/answer/1943149381147660845


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


; 嵌套的括号不是 scheme 标准语法。表示定义柯里化的函数，和嵌套 lambda 等价。racket 支持这一扩展语法。
(define (Z env)
  (car env))
(define ((S vp) env)
  (vp (cdr env)))
(define ((Lam e) env)
  (lambda (x)
    (e (cons x env))))
(define ((App e1 e2) env)
  ((e1 env) (e2 env)))

; (define global-env '())


顺便，还有人问我为什么不再布置一道习题，那么这就是习题！"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"调用栈、de Bruijn 索引与堆栈的内存模型","item":"https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"调用栈、de Bruijn 索引与堆栈的内存模型","name":"调用栈、de Bruijn 索引与堆栈的内存模型","description":"光剑系列的第六作！\n（放一个 Gemini 生成的欧比旺的图来解释一下光剑是什么） 前五作：\n第一篇：Let\u0026rsquo;s build our mathematics by using lambda calculus \u0026amp;\u0026amp; church encoding! 第二篇：惰性求值、无穷流与发生的魔法 第三篇：协程、生成器与 call/cc 的控制流 第四篇：动态作用域、词法作用域与表达式求值的环境模型 第五篇：基于环境模型的解释器 我们上篇文章写了解释器。在评论区里面可以看到一个非常神秘的东西：https://www.zhihu.com/question/30262900/answer/1943149381147660845\n1 2 3 4 5 6 7 8 9 10 11 12 ; 嵌套的括号不是 scheme 标准语法。表示定义柯里化的函数，和嵌套 lambda 等价。racket 支持这一扩展语法。 (define (Z env) (car env)) (define ((S vp) env) (vp (cdr env))) (define ((Lam e) env) (lambda (x) (e (cons x env)))) (define ((App e1 e2) env) ((e1 env) (e2 env))) ; (define global-env \u0026#39;()) 顺便，还有人问我为什么不再布置一道习题，那么这就是习题！\n","keywords":["PLT","lisp/scheme/racket"],"articleBody":"光剑系列的第六作！\n（放一个 Gemini 生成的欧比旺的图来解释一下光剑是什么） 前五作：\n第一篇：Let’s build our mathematics by using lambda calculus \u0026\u0026 church encoding! 第二篇：惰性求值、无穷流与发生的魔法 第三篇：协程、生成器与 call/cc 的控制流 第四篇：动态作用域、词法作用域与表达式求值的环境模型 第五篇：基于环境模型的解释器 我们上篇文章写了解释器。在评论区里面可以看到一个非常神秘的东西：https://www.zhihu.com/question/30262900/answer/1943149381147660845\n1 2 3 4 5 6 7 8 9 10 11 12 ; 嵌套的括号不是 scheme 标准语法。表示定义柯里化的函数，和嵌套 lambda 等价。racket 支持这一扩展语法。 (define (Z env) (car env)) (define ((S vp) env) (vp (cdr env))) (define ((Lam e) env) (lambda (x) (e (cons x env)))) (define ((App e1 e2) env) ((e1 env) (e2 env))) ; (define global-env '()) 顺便，还有人问我为什么不再布置一道习题，那么这就是习题！\n这篇文章就是对这个东西的讲解。\n看到这个东西，相信大部分人都做不到一眼看懂。不过应该能够看出一点门道：一个变量不再是我们传统解释器中的那个符号，而是一个函数，这个函数的作用是在环境中查找它对应的值。\n但是，它究竟是怎么查找的呢？\nde Bruijn 索引 答案是，它使用了一种名为 de Bruijn 索引 的技术。\n它的核心思想是：用一个自然数来替代变量名，这个数字代表了变量定义距离其使用位置有多少层 lambda 嵌套。\n0 指代的是最内层（最近）的 lambda 绑定的变量。 1 指代的是往外一层的 lambda 绑定的变量。 以此类推。 举个例子，在 (lambda (x) (lambda (y) (+ x y))) 这个表达式中，对于 + 表达式而言：\n变量 y 是由最内层的 lambda (y) 绑定的，所以它的 de Bruijn 索引是 0。 变量 x 是由外一层的 lambda (x) 绑定的，所以它的索引是 1。 理解了这一点，我们再来审视那份神秘的代码。这里的“环境” env 不再是符号到值的映射，而是一个从内到外排列的实参列表，完美扮演了调用栈的角色。\n(Z env) 就是 (car env)，它获取列表的第一个元素。这正是查找索引为 0 的变量——“调用栈上最近的那个值”。 ((S vp) env) 的作用是 (vp (cdr env))。它将环境 env 去掉一层，再用 vp 去查找。这和邱奇编码中的后继函数非常相似，其效果就是让变量查找向外层移动一格。因此，S 操作符就是将变量的索引加一。S(Z) 就代表索引为 1 的变量，S(S(Z)) 代表索引为 2 的变量。 现在，另外两个函数的含义也清晰了：\n((Lam e) env) 构造了一个 lambda 表达式。它返回一个 Scheme 的 lambda，这个 lambda 接受一个实参 x，然后将 x 通过 cons 压入当前环境 env 的头部，形成一个新的环境，并在这个新环境中执行函数体 e。 ((App e1 e2) env) 实现了函数应用。它在当前环境 env 中分别对 e1 和 e2 求值，然后直接利用 Scheme 底层的函数应用机制完成调用。 这个实现还有一个极其精妙之处：它利用了 Scheme 的闭包。((Lam e) env) 返回的那个 lambda 自然地捕获了它定义时的环境 env。这使得我们的解释器免费地、正确地实现了词法作用域。\n至此，我们用寥寥数行代码，就实现了一个 lambda 演算的解释器。相较于我们在第五作中构建的那个庞大的解释器，这个方案无疑更加简洁、优雅。并且在合理的实现下更加高效。\n调用栈 这种函数式的栈模拟，不仅仅是理论上的奇技淫巧。敏锐的你可能已经发现了，它与汇编语言中的函数调用栈如出一辙。\n在 x86-64 汇编中，你可能会看到类似这样的代码：\n1 2 3 4 5 6 7 8 9 10 ; 函数序言 push rbp ; 保存旧的栈帧基址 mov rbp, rsp ; 设置新的栈帧基址 sub rsp, 16 ; 为局部变量分配16字节空间 ... mov rax, [rbp - 8] ; 访问第一个局部变量 a add rax, 114514 ; a += 114514 mov [rbp - 8], rax ; 写回 a 这里的 rbp 是栈帧基址指针（Base Pointer），而 rsp 是栈顶指针（Stack Pointer）。在一个函数被调用时，通常会建立一个新的栈帧（Stack Frame），rbp 会指向这个栈帧的固定基址，为函数内部的变量访问提供一个稳定的参考点。\n发现了什么？访问局部变量 a 的逻辑 [rbp - 8] 和我们上面的 (S Z) 简直一模一样！\nrbp 就像我们的 env，它为当前函数提供了一个稳定的“环境”基准。 -8 这个固定的偏移量，就如同 S 操作的次数，是在编译期就确定好的、变量相对于环境基准的“索引”。 这是一种深刻的同构。我们的 Scheme 代码，用纯函数式的方式，模拟了底层指令集架构中基于栈帧的变量访问机制。\n理解了这层同构关系后，我们可以进一步探讨一些与调用栈相关的有趣话题。\n逃逸分析 我们上面的 Scheme 解释器不需要手动管理内存，GC 会处理一切。同时，闭包中的自由变量也能得到妥善处置，因为列表天生就是可结构共享的。\n但是，如果我们把模型切换到汇编中那样的、由连续内存段实现的机械栈上，问题就来了：一个变量的生命周期被严格地限制在它的栈帧之内。当函数返回，栈帧被销毁，其中的所有变量也随之灰飞烟灭。\n这在大多数情况下没问题，但当一个变量的生命周期需要比创建它的函数更长时，矛盾就产生了。一个典型的例子是返回闭包：\n1 2 3 4 5 6 (define (make-adder add_val) ; 下面这个 lambda 捕获了外部的 add_val (lambda (x) (+ x add_val))) (define add5 (make-adder 5)) (add5 10) ; 结果是 15 当 make-adder 函数执行完毕并返回时，它的栈帧理应被销毁。但是，它创建并返回的 lambda（现在被 add5 引用）仍然需要访问 add_val 的值（也就是 5）。这意味着 add_val 这个变量的生命周期，必须比创建它的那个栈帧更长。它从自己的作用域中“逃逸”了。\n对于这种情况，简单的栈分配就无能为力了。通用的方法是把 add_val 这样的逃逸变量分配在 堆（Heap） 上，并在闭包中持有指向这块堆内存的引用。\n然而，堆分配和间接访问会带来性能开销。因此，现代编译器会进行逃逸分析（Escape Analysis）：如果编译器能证明一个变量绝不会“逃逸”出它的作用域，就可以安全地将它分配在栈上，从而消除开销，提升效率。\n堆和栈，动态和静态分配 逃逸分析引出了计算机内存管理中一对最核心的概念：栈与堆。\n栈（Stack） 的本质是静态内存布局。编译器在编译时就能精确计算出每个函数需要多少空间，以及每个局部变量相对于栈帧基址 rbp 的偏移量。这使得变量访问极其高效，只需要一次地址运算。但它的代价是死板：大小和生命周期必须在编译时确定。\n堆（Heap） 则是动态内存的舞台。当程序需要在运行时才能确定需要多少内存（例如，读取一个未知大小的文件），或者一个对象的生命周期无法在编译时确定（例如逃逸的闭包变量），就需要从堆上申请。\n为了在动态分配的同时不破坏栈的静态布局，常见的做法是在栈上只保存一个固定大小的指针，这个指针指向堆上那块大小不定的内存。这也是为什么 C++ 的 std::vector 或 Java 的所有对象都采用指针/引用的形式——栈上只存放一个引用，而真正的对象数据存放在堆上。\n函数调用的实现 那么，硬件层面是如何建立和销毁我们一直在讨论的栈帧的呢？我们来看看 call f 这样一个简单的函数调用背后发生了什么。\n调用（call f）：call 指令首先会将返回地址（也就是 call 指令的下一条指令的地址）压入栈顶。然后，它会无条件跳转到函数 f 的代码开头。保存返回地址至关重要，否则函数执行完后就不知道该回到哪里了。\n函数序言（Prologue）：函数 f 的开头通常会执行一系列指令来建立自己的新栈帧：\npush rbp：保存调用者（上一个函数）的 rbp 值。 mov rbp, rsp：将当前的栈顶位置设为新栈帧的基址。从此，rbp 在函数执行期间保持稳定。 sub rsp, N：在栈上为局部变量预留 N 字节的空间。 函数返回（ret）：当函数 f 执行完毕，它会执行函数尾声（Epilogue）和 ret 指令来拆除栈帧并返回：\nmov rsp, rbp（或 leave 指令）：释放局部变量空间，将栈顶指针恢复到栈帧基址。 pop rbp：从栈中恢复调用者的 rbp。 ret：从栈顶弹出之前保存的返回地址，并跳转到该地址，将控制权交还给调用者。 就这样，通过 call 和 ret 的精密配合，以及对 rbp 和 rsp 寄存器的约定用法，程序得以在函数间有序地跳转，同时高效地管理着各自的局部变量。\n总结：从 Lambda 到机器码的同构 从一段看似魔法的 Scheme 代码出发，我们踏上了一段奇妙的旅程。我们看到，lambda 演算中的变量绑定，通过 de Bruijn 索引，被转换成了一种基于相对位置的表达。\n这种相对位置的表达，与现代计算机体系结构中调用栈通过栈帧指针+偏移量来定位变量的方式，形成了惊人的同构。\n进一步地，这个看似简单的内存模型引出了深刻的工程挑战：当函数的生命周期与变量的生命周期不一致时（如闭包导致的变量逃逸），我们就必须引入更灵活的堆内存管理。而栈，作为一种编译期即可确定布局的高效静态模型，则由编译器通过逃逸分析来尽可能地加以利用。\n最终我们发现，无论是高级语言的抽象模型，还是底层的机器指令，都在用各自的方式解决同一个核心问题：如何高效、准确地管理和查找变量。抽象的计算理论与具体的硬件实现，在“调用栈”这一点上，达成了深刻的统一。\n","wordCount":"419","inLanguage":"en","datePublished":"2025-10-13T15:22:34+08:00","dateModified":"2025-10-13T15:22:34+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},"publisher":{"@type":"Organization","name":"litjohn's blog","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="litjohn's blog (Alt + H)">litjohn's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">调用栈、de Bruijn 索引与堆栈的内存模型</h1><div class=post-meta><span title='2025-10-13 15:22:34 +0800 +0800'>October 13, 2025</span></div></header><div class=post-content><p>光剑系列的第六作！</p><p>（放一个 Gemini 生成的欧比旺的图来解释一下光剑是什么）
<img loading=lazy src=https://cdn.luogu.com.cn/upload/image_hosting/76io2hwx.png></p><p>前五作：</p><ul><li>第一篇：<a href=https://www.luogu.com.cn/article/cr6hfiut>Let&rsquo;s build our mathematics by using lambda calculus && church encoding!</a></li><li>第二篇：<a href=https://www.luogu.com.cn/article/uhume1ou>惰性求值、无穷流与发生的魔法</a></li><li>第三篇：<a href=https://www.luogu.com.cn/article/ygxlqlsn>协程、生成器与 call/cc 的控制流</a></li><li>第四篇：<a href=https://www.luogu.com.cn/article/0hxig3i4>动态作用域、词法作用域与表达式求值的环境模型</a></li><li>第五篇：<a href=https://www.luogu.com.cn/article/h0g9paih>基于环境模型的解释器</a></li></ul><p>我们上篇文章写了解释器。在评论区里面可以看到一个非常神秘的东西：<a href=https://www.zhihu.com/question/30262900/answer/1943149381147660845>https://www.zhihu.com/question/30262900/answer/1943149381147660845</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=c1>; 嵌套的括号不是 scheme 标准语法。表示定义柯里化的函数，和嵌套 lambda 等价。racket 支持这一扩展语法。</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>Z</span> <span class=nv>env</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>car </span><span class=nv>env</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>((</span><span class=nf>S</span> <span class=nv>vp</span><span class=p>)</span> <span class=nv>env</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>vp</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>env</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>((</span><span class=nf>Lam</span> <span class=nv>e</span><span class=p>)</span> <span class=nv>env</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>e</span> <span class=p>(</span><span class=nb>cons </span><span class=nv>x</span> <span class=nv>env</span><span class=p>))))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>((</span><span class=nf>App</span> <span class=nv>e1</span> <span class=nv>e2</span><span class=p>)</span> <span class=nv>env</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>((</span><span class=nf>e1</span> <span class=nv>env</span><span class=p>)</span> <span class=p>(</span><span class=nf>e2</span> <span class=nv>env</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; (define global-env &#39;())</span>
</span></span></code></pre></td></tr></table></div></div><p>顺便，还有人问我为什么不再布置一道习题，那么这就是习题！</p><p>这篇文章就是对这个东西的讲解。</p><hr><p>看到这个东西，相信大部分人都做不到一眼看懂。不过应该能够看出一点门道：一个变量不再是我们传统解释器中的那个符号，而是一个函数，这个函数的作用是在环境中查找它对应的值。</p><p>但是，它究竟是怎么查找的呢？</p><h3 id=de-bruijn-索引>de Bruijn 索引<a hidden class=anchor aria-hidden=true href=#de-bruijn-索引>#</a></h3><p>答案是，它使用了一种名为 <strong>de Bruijn 索引</strong> 的技术。</p><p>它的核心思想是：<strong>用一个自然数来替代变量名，这个数字代表了变量定义距离其使用位置有多少层 lambda 嵌套</strong>。</p><ul><li><code>0</code> 指代的是最内层（最近）的 lambda 绑定的变量。</li><li><code>1</code> 指代的是往外一层的 lambda 绑定的变量。</li><li>以此类推。</li></ul><p>举个例子，在 <code>(lambda (x) (lambda (y) (+ x y)))</code> 这个表达式中，对于 <code>+</code> 表达式而言：</p><ul><li>变量 <code>y</code> 是由最内层的 <code>lambda (y)</code> 绑定的，所以它的 de Bruijn 索引是 <code>0</code>。</li><li>变量 <code>x</code> 是由外一层的 <code>lambda (x)</code> 绑定的，所以它的索引是 <code>1</code>。</li></ul><p>理解了这一点，我们再来审视那份神秘的代码。这里的“环境” <code>env</code> 不再是符号到值的映射，而是一个从内到外排列的实参列表，完美扮演了<strong>调用栈</strong>的角色。</p><ul><li><code>(Z env)</code> 就是 <code>(car env)</code>，它获取列表的第一个元素。这正是查找索引为 <code>0</code> 的变量——“调用栈上最近的那个值”。</li><li><code>((S vp) env)</code> 的作用是 <code>(vp (cdr env))</code>。它将环境 <code>env</code> 去掉一层，再用 <code>vp</code> 去查找。这和邱奇编码中的后继函数非常相似，其效果就是让变量查找向外层移动一格。因此，<code>S</code> 操作符就是将变量的索引加一。<code>S(Z)</code> 就代表索引为 <code>1</code> 的变量，<code>S(S(Z))</code> 代表索引为 <code>2</code> 的变量。</li></ul><p>现在，另外两个函数的含义也清晰了：</p><ul><li><code>((Lam e) env)</code> 构造了一个 lambda 表达式。它返回一个 Scheme 的 <code>lambda</code>，这个 <code>lambda</code> 接受一个实参 <code>x</code>，然后将 <code>x</code> 通过 <code>cons</code> 压入当前环境 <code>env</code> 的头部，形成一个新的环境，并在这个新环境中执行函数体 <code>e</code>。</li><li><code>((App e1 e2) env)</code> 实现了函数应用。它在当前环境 <code>env</code> 中分别对 <code>e1</code> 和 <code>e2</code> 求值，然后直接利用 Scheme 底层的函数应用机制完成调用。</li></ul><p>这个实现还有一个极其精妙之处：它利用了 Scheme 的<strong>闭包</strong>。<code>((Lam e) env)</code> 返回的那个 <code>lambda</code> 自然地捕获了它定义时的环境 <code>env</code>。这使得我们的解释器免费地、正确地实现了词法作用域。</p><p>至此，我们用寥寥数行代码，就实现了一个 lambda 演算的解释器。相较于我们在第五作中构建的那个庞大的解释器，这个方案无疑更加简洁、优雅。并且在合理的实现下更加高效。</p><h3 id=调用栈>调用栈<a hidden class=anchor aria-hidden=true href=#调用栈>#</a></h3><p>这种函数式的栈模拟，不仅仅是理论上的奇技淫巧。敏锐的你可能已经发现了，它与汇编语言中的<strong>函数调用栈</strong>如出一辙。</p><p>在 x86-64 汇编中，你可能会看到类似这样的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; 函数序言
</span></span><span class=line><span class=cl>push rbp        ; 保存旧的栈帧基址
</span></span><span class=line><span class=cl>mov rbp, rsp    ; 设置新的栈帧基址
</span></span><span class=line><span class=cl>sub rsp, 16     ; 为局部变量分配16字节空间
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mov rax, [rbp - 8]  ; 访问第一个局部变量 a
</span></span><span class=line><span class=cl>add rax, 114514    ; a += 114514
</span></span><span class=line><span class=cl>mov [rbp - 8], rax ; 写回 a
</span></span></code></pre></td></tr></table></div></div><p>这里的 <code>rbp</code> 是<strong>栈帧基址指针</strong>（Base Pointer），而 <code>rsp</code> 是<strong>栈顶指针</strong>（Stack Pointer）。在一个函数被调用时，通常会建立一个新的栈帧（Stack Frame），<code>rbp</code> 会指向这个栈帧的固定基址，为函数内部的变量访问提供一个稳定的参考点。</p><p>发现了什么？访问局部变量 <code>a</code> 的逻辑 <code>[rbp - 8]</code> 和我们上面的 <code>(S Z)</code> 简直一模一样！</p><ul><li><code>rbp</code> 就像我们的 <code>env</code>，它为当前函数提供了一个稳定的“环境”基准。</li><li><code>-8</code> 这个固定的偏移量，就如同 <code>S</code> 操作的次数，是在编译期就确定好的、变量相对于环境基准的“索引”。</li></ul><p>这是一种深刻的<strong>同构</strong>。我们的 Scheme 代码，用纯函数式的方式，模拟了底层指令集架构中基于栈帧的变量访问机制。</p><p>理解了这层同构关系后，我们可以进一步探讨一些与调用栈相关的有趣话题。</p><h4 id=逃逸分析>逃逸分析<a hidden class=anchor aria-hidden=true href=#逃逸分析>#</a></h4><p>我们上面的 Scheme 解释器不需要手动管理内存，GC 会处理一切。同时，闭包中的自由变量也能得到妥善处置，因为列表天生就是可结构共享的。</p><p>但是，如果我们把模型切换到汇编中那样的、由连续内存段实现的机械栈上，问题就来了：一个变量的生命周期被严格地限制在它的栈帧之内。当函数返回，栈帧被销毁，其中的所有变量也随之灰飞烟灭。</p><p>这在大多数情况下没问题，但当一个变量的生命周期需要比创建它的函数更长时，矛盾就产生了。一个典型的例子是<strong>返回闭包</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>make-adder</span> <span class=nv>add_val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>; 下面这个 lambda 捕获了外部的 add_val</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>x</span> <span class=nv>add_val</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>add5</span> <span class=p>(</span><span class=nf>make-adder</span> <span class=mi>5</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>add5</span> <span class=mi>10</span><span class=p>)</span> <span class=c1>; 结果是 15</span>
</span></span></code></pre></td></tr></table></div></div><p>当 <code>make-adder</code> 函数执行完毕并返回时，它的栈帧理应被销毁。但是，它创建并返回的 <code>lambda</code>（现在被 <code>add5</code> 引用）仍然需要访问 <code>add_val</code> 的值（也就是 5）。这意味着 <code>add_val</code> 这个变量的生命周期，必须比创建它的那个栈帧更长。它从自己的作用域中“<strong>逃逸</strong>”了。</p><p>对于这种情况，简单的栈分配就无能为力了。通用的方法是把 <code>add_val</code> 这样的逃逸变量分配在 <strong>堆（Heap）</strong> 上，并在闭包中持有指向这块堆内存的引用。</p><p>然而，堆分配和间接访问会带来性能开销。因此，现代编译器会进行<strong>逃逸分析（Escape Analysis）</strong>：如果编译器能证明一个变量绝不会“逃逸”出它的作用域，就可以安全地将它分配在栈上，从而消除开销，提升效率。</p><h4 id=堆和栈动态和静态分配>堆和栈，动态和静态分配<a hidden class=anchor aria-hidden=true href=#堆和栈动态和静态分配>#</a></h4><p>逃逸分析引出了计算机内存管理中一对最核心的概念：栈与堆。</p><ul><li><p><strong>栈（Stack）</strong> 的本质是<strong>静态</strong>内存布局。编译器在编译时就能精确计算出每个函数需要多少空间，以及每个局部变量相对于栈帧基址 <code>rbp</code> 的偏移量。这使得变量访问极其高效，只需要一次地址运算。但它的代价是死板：大小和生命周期必须在编译时确定。</p></li><li><p><strong>堆（Heap）</strong> 则是<strong>动态</strong>内存的舞台。当程序需要在运行时才能确定需要多少内存（例如，读取一个未知大小的文件），或者一个对象的生命周期无法在编译时确定（例如逃逸的闭包变量），就需要从堆上申请。</p></li></ul><p>为了在动态分配的同时不破坏栈的静态布局，常见的做法是在栈上只保存一个固定大小的指针，这个指针指向堆上那块大小不定的内存。这也是为什么 C++ 的 <code>std::vector</code> 或 Java 的所有对象都采用指针/引用的形式——栈上只存放一个引用，而真正的对象数据存放在堆上。</p><h4 id=函数调用的实现>函数调用的实现<a hidden class=anchor aria-hidden=true href=#函数调用的实现>#</a></h4><p>那么，硬件层面是如何建立和销毁我们一直在讨论的栈帧的呢？我们来看看 <code>call f</code> 这样一个简单的函数调用背后发生了什么。</p><ol><li><p><strong>调用（<code>call f</code>）</strong>：<code>call</code> 指令首先会将<strong>返回地址</strong>（也就是 <code>call</code> 指令的下一条指令的地址）压入栈顶。然后，它会无条件跳转到函数 <code>f</code> 的代码开头。保存返回地址至关重要，否则函数执行完后就不知道该回到哪里了。</p></li><li><p><strong>函数序言（Prologue）</strong>：函数 <code>f</code> 的开头通常会执行一系列指令来建立自己的新栈帧：</p><ul><li><code>push rbp</code>：保存调用者（上一个函数）的 <code>rbp</code> 值。</li><li><code>mov rbp, rsp</code>：将当前的栈顶位置设为新栈帧的基址。从此，<code>rbp</code> 在函数执行期间保持稳定。</li><li><code>sub rsp, N</code>：在栈上为局部变量预留 <code>N</code> 字节的空间。</li></ul></li><li><p><strong>函数返回（<code>ret</code>）</strong>：当函数 <code>f</code> 执行完毕，它会执行函数尾声（Epilogue）和 <code>ret</code> 指令来拆除栈帧并返回：</p><ul><li><code>mov rsp, rbp</code>（或 <code>leave</code> 指令）：释放局部变量空间，将栈顶指针恢复到栈帧基址。</li><li><code>pop rbp</code>：从栈中恢复调用者的 <code>rbp</code>。</li><li><code>ret</code>：从栈顶弹出之前保存的返回地址，并跳转到该地址，将控制权交还给调用者。</li></ul></li></ol><p>就这样，通过 <code>call</code> 和 <code>ret</code> 的精密配合，以及对 <code>rbp</code> 和 <code>rsp</code> 寄存器的约定用法，程序得以在函数间有序地跳转，同时高效地管理着各自的局部变量。</p><h3 id=总结从-lambda-到机器码的同构>总结：从 Lambda 到机器码的同构<a hidden class=anchor aria-hidden=true href=#总结从-lambda-到机器码的同构>#</a></h3><p>从一段看似魔法的 Scheme 代码出发，我们踏上了一段奇妙的旅程。我们看到，lambda 演算中的变量绑定，通过 <strong>de Bruijn 索引</strong>，被转换成了一种基于相对位置的表达。</p><p>这种相对位置的表达，与现代计算机体系结构中<strong>调用栈</strong>通过<strong>栈帧指针+偏移量</strong>来定位变量的方式，形成了惊人的<strong>同构</strong>。</p><p>进一步地，这个看似简单的内存模型引出了深刻的工程挑战：当函数的生命周期与变量的生命周期不一致时（如闭包导致的变量<strong>逃逸</strong>），我们就必须引入更灵活的<strong>堆</strong>内存管理。而<strong>栈</strong>，作为一种编译期即可确定布局的高效静态模型，则由编译器通过<strong>逃逸分析</strong>来尽可能地加以利用。</p><p>最终我们发现，无论是高级语言的抽象模型，还是底层的机器指令，都在用各自的方式解决同一个核心问题：如何高效、准确地管理和查找变量。抽象的计算理论与具体的硬件实现，在“调用栈”这一点上，达成了深刻的统一。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/plt/>PLT</a></li><li><a href=https://litjohn.github.io/tags/lisp/scheme/racket/>Lisp/Scheme/Racket</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>litjohn's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>