<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>协程、生成器与 call/cc 的控制流 | 正确即是废话，废话亦是正确</title><meta name=keywords content="PLT,lisp/scheme/racket"><meta name=description content="上期回顾
光剑系列的第三作！前两篇：
第一篇：Let&rsquo;s build our mathematics by using lambda calculus && church encoding!
第二篇：惰性求值、无穷流与发生的魔法
前言与一个震撼的 demo
在上一篇文章中，我们探讨并实现了惰性求值与无穷流。希望你们还对自然数流印象深刻。
自然数流也可以视为一个不断生成新的自然数的生成器。那么，从这个意义上，我们有更简洁而强大的实现方式。
（还是一贯的 scheme 代码）


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


(define (nature-gen return)
  (let loop ((i 0))
    (set! return
          (call/cc
            (lambda (state)
              (return (cons state i)))))
    (loop (+ i 1))))

(define nature-numbers

  (let ((k nature-gen))
    (define (tmp-interface)
      (let ((result (call/cc k)))
        (set! k (car result))
        (cdr result)))

  tmp-interface))


这就是一个自然数的生成器！每次调用 nature-numbers，它都会返回一个新的自然数。"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call-cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/><link crossorigin=anonymous href=/assets/css/stylesheet.0abe74e9285d02ff17a1d5d9725d52c7a4cbdc65c4e3cad1528047eb09ad5ac9.css integrity="sha256-Cr506ShdAv8XodXZcl1Sx6TL3GXE48rRUoBH6wmtWsk=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call-cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call-cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"><meta property="og:site_name" content="正确即是废话，废话亦是正确"><meta property="og:title" content="协程、生成器与 call/cc 的控制流"><meta property="og:description" content="上期回顾 光剑系列的第三作！前两篇：
第一篇：Let’s build our mathematics by using lambda calculus && church encoding!
第二篇：惰性求值、无穷流与发生的魔法
前言与一个震撼的 demo 在上一篇文章中，我们探讨并实现了惰性求值与无穷流。希望你们还对自然数流印象深刻。
自然数流也可以视为一个不断生成新的自然数的生成器。那么，从这个意义上，我们有更简洁而强大的实现方式。
（还是一贯的 scheme 代码）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (define (nature-gen return) (let loop ((i 0)) (set! return (call/cc (lambda (state) (return (cons state i))))) (loop (+ i 1)))) (define nature-numbers (let ((k nature-gen)) (define (tmp-interface) (let ((result (call/cc k))) (set! k (car result)) (cdr result))) tmp-interface)) 这就是一个自然数的生成器！每次调用 nature-numbers，它都会返回一个新的自然数。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-13T15:19:20+08:00"><meta property="article:modified_time" content="2025-10-13T15:19:20+08:00"><meta property="article:tag" content="PLT"><meta property="article:tag" content="Lisp/Scheme/Racket"><meta property="og:see_also" content="https://litjohn.github.io/posts/bin-exp/"><meta property="og:see_also" content="https://litjohn.github.io/posts/start-to-build-a-compiler/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/"><meta name=twitter:card content="summary"><meta name=twitter:title content="协程、生成器与 call/cc 的控制流"><meta name=twitter:description content="上期回顾
光剑系列的第三作！前两篇：
第一篇：Let&rsquo;s build our mathematics by using lambda calculus && church encoding!
第二篇：惰性求值、无穷流与发生的魔法
前言与一个震撼的 demo
在上一篇文章中，我们探讨并实现了惰性求值与无穷流。希望你们还对自然数流印象深刻。
自然数流也可以视为一个不断生成新的自然数的生成器。那么，从这个意义上，我们有更简洁而强大的实现方式。
（还是一贯的 scheme 代码）


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


(define (nature-gen return)
  (let loop ((i 0))
    (set! return
          (call/cc
            (lambda (state)
              (return (cons state i)))))
    (loop (+ i 1))))

(define nature-numbers

  (let ((k nature-gen))
    (define (tmp-interface)
      (let ((result (call/cc k)))
        (set! k (car result))
        (cdr result)))

  tmp-interface))


这就是一个自然数的生成器！每次调用 nature-numbers，它都会返回一个新的自然数。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"协程、生成器与 call/cc 的控制流","item":"https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call-cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"协程、生成器与 call/cc 的控制流","name":"协程、生成器与 call\/cc 的控制流","description":"上期回顾 光剑系列的第三作！前两篇：\n第一篇：Let\u0026rsquo;s build our mathematics by using lambda calculus \u0026amp;\u0026amp; church encoding!\n第二篇：惰性求值、无穷流与发生的魔法\n前言与一个震撼的 demo 在上一篇文章中，我们探讨并实现了惰性求值与无穷流。希望你们还对自然数流印象深刻。\n自然数流也可以视为一个不断生成新的自然数的生成器。那么，从这个意义上，我们有更简洁而强大的实现方式。\n（还是一贯的 scheme 代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (define (nature-gen return) (let loop ((i 0)) (set! return (call/cc (lambda (state) (return (cons state i))))) (loop (+ i 1)))) (define nature-numbers (let ((k nature-gen)) (define (tmp-interface) (let ((result (call/cc k))) (set! k (car result)) (cdr result))) tmp-interface)) 这就是一个自然数的生成器！每次调用 nature-numbers，它都会返回一个新的自然数。\n","keywords":["PLT","lisp/scheme/racket"],"articleBody":"上期回顾 光剑系列的第三作！前两篇：\n第一篇：Let’s build our mathematics by using lambda calculus \u0026\u0026 church encoding!\n第二篇：惰性求值、无穷流与发生的魔法\n前言与一个震撼的 demo 在上一篇文章中，我们探讨并实现了惰性求值与无穷流。希望你们还对自然数流印象深刻。\n自然数流也可以视为一个不断生成新的自然数的生成器。那么，从这个意义上，我们有更简洁而强大的实现方式。\n（还是一贯的 scheme 代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (define (nature-gen return) (let loop ((i 0)) (set! return (call/cc (lambda (state) (return (cons state i))))) (loop (+ i 1)))) (define nature-numbers (let ((k nature-gen)) (define (tmp-interface) (let ((result (call/cc k))) (set! k (car result)) (cdr result))) tmp-interface)) 这就是一个自然数的生成器！每次调用 nature-numbers，它都会返回一个新的自然数。\n1 2 3 4 5 6 7 8 9 10 \u003e (nature-numbers) 0 \u003e (nature-numbers) 1 \u003e (nature-numbers) 2 \u003e (nature-numbers) 3 \u003e (nature-numbers) 4 正文 上面的代码虽然简短，但是相当晦涩。下面我们将一步步解开它的秘密。\n生成器：可以“暂停”的函数 我们在文章开头用那段晦涩的 Scheme 代码创造的东西，用一个更广为人知的术语来说，就是一个 “生成器” (Generator)。\n你可以把它想象成一个特殊的函数，它有一种超能力：可以在执行到一半时对自己喊“停！”，然后把一个值“扔”给调用者。当调用者下次再来找它时，它能从上次喊停的地方“满血复活”，继续执行。\n其实，这个概念对很多程序员来说并不陌生。Python 中的 yield 关键字就是实现生成器的经典方式，我们开头的 nature-numbers 就等价于下面这段 Python 代码：\n1 2 3 4 5 def nature_gen(): i = 0 while True: yield i i += 1 回顾我们上一篇文章的无穷流，你会发现它惊人地相似！每次我们从流中取出一个数，计算就会“产出”一个结果，而“剩余的无穷计算”则被巧妙地冻结了。这正是生成器的思想：执行、产出、暂停、等待下一次恢复。\n协程：控制权的对等转移 生成器这种“暂停-恢复”的模式，其实是一种更通用、更强大的编程思想的体现，那就是协程 (Coroutine)。\n普通函数调用是“主仆”关系：主函数调用子函数，子函数必须执行完毕并返回，控制权才能回到主函数。这就像经理给员工派活，员工必须做完才能交差。\n而协程之间是“对等”关系。它们就像两位正在对弈的棋手。你走一步，将控制权（棋盘的使用权）交给我；我走一步，再把控制权交还给你。任何一方都可以主动让出控制权。\n看到这里，你应该明白了：生成器，正是一种非对称的协程！ 它在 yield 时将控制权交还给主程序，主程序下次调用时又将控制权还给它，让它从断点处继续。\n那么，真正的问题来了：这种“控制权的任意转移”是如何实现的？我们要怎样才能在代码中抓住“控制流”这个看不见摸不着的东西，让它暂停，又让它在未来某个时刻精确地恢复呢？要铸造这柄控制流的光剑，我们需要一种终极材料——续延。\n续延：捕获程序的“未来” 想象一下，当程序执行到某个特定点时，我们按下了“暂停”键。此时，“程序接下来要做的所有事情”，就是我们所说的 “续延” (Continuation)。 它就像一个包含了程序未来的“时间胶囊”。比如在这段 C++ 代码中：\n1 2 3 4 5 6 int foo(int x) { x++; x *= 3; // \u003c- 按下暂停键 x \u003c\u003c= 1; return x; } 在注释标记的那一行，续延就是“把当前 x 的值左移一位，然后返回结果”。它封装了当前计算剩下的所有步骤。 续延，就是协程暂停时需要保存的那个“断点”的精确描述。 如果我们能拿到这个“断点”，并能在之后随时回到这里，协程的实现不就迎刃而解了吗？\ncall/cc：铸造控制流的魔法棒 在 Scheme 中，call/cc (全称 call-with-current-continuation) 就是这样一个强大的魔法，它能将抽象的“续延”概念物化成一个我们可以操作的实体。 它的作用正如其名：捕获当前的续延，并将它作为一个函数参数，传递给你指定的另一个函数。\n1 2 3 (call/cc (lambda (k) ; k 就是被捕获的续延 (k 3))) k 就是那个“时间胶囊”，一个代表了“未来”的函数。它和其他函数一样，是一等公民。 当你调用 k 并给它一个参数（例如 (k 3)）时，奇迹发生了：程序会立刻放弃当前的所有计算，瞬移回 call/cc 被调用的那个时间点，并将你给的参数 3 作为整个 call/cc 表达式的返回值。因此，上面表达式的值就是 3。 更神奇的是，这个“时间胶囊”可以被保存起来，反复使用！\n1 2 3 4 5 6 7 8 9 (define saved-k #f) (let ((result (+ 1 (call/cc (lambda (k) (set! saved-k k) ; 把“时间胶囊”存起来 5))))) (display result) (newline)) ;; 第一次执行，call/cc 返回 5，所以 result 是 6，打印 6 ;; 现在，如果你在 REPL 中调用 (saved-k 100) ;; 程序会瞬间回到 let 表达式中，仿佛 call/cc 刚刚返回了 100 ;; 于是 result 变为 101，并再次打印 101！ 这个例子完美地展示了 call/cc 的威力：它不仅能逃出当前的计算，还能让我们在未来任何时候，都能像《命运石之门》一样，一次又一次地回到过去，并带着新的“世界线”参数（返回值）继续执行。\n这样的强大工具可以用于构建任意控制流，也包括协程。你可能已经发现了，协程归还控制权时保存状态可以用续延简单实现。更具体地，我们可以直接返回协程内部用 call/cc 捕获的续延！然后再次调用协程时调用那个续延。\n庖丁解牛：深入代码的魔法核心 现在，我们手握 call/cc 这柄能任意切割、重塑程序时间线的光剑，是时候回到最初那个令人惊叹的 demo，像一位精准的外科医生一样，剖析其运作的每一个细节了。\n整个结构分为两部分：作为“协程引擎”的 nature-gen，以及作为“用户接口”的 nature-numbers。我们将模拟一次完整的“生成-暂停-恢复”流程来理解它们。\n第一步：协程引擎 nature-gen 的内部构造 nature-gen 函数是生成器的核心。它的设计精妙之处在于一场**“双续延之舞”**。\n1 2 3 4 5 6 7 (define (nature-gen return) (let loop ((i 0)) (set! return ; 3. 更新“出口”，为下次恢复做准备 (call/cc (lambda (state) ; 1. 捕获“内部断点” (return (cons state i))))) ; 2. 带着“断点”和值，从“出口”返回 (loop (+ i 1)))) 让我们分解这支舞蹈的三个关键舞步：\nstate：捕获“内部断点” call/cc 在这里捕获了它所在位置的续延，我们称之为 state。这个 state 就是我们心心念念的“时间胶囊”，它精确地封装了 nature-gen 暂停时的一切：位于 loop 循环内，变量 i 的当前值，以及接下来要执行 (loop (+ i 1)) 这个步骤的“未来”。\nreturn：从指定的“出口”返回 return 参数是什么？它并不是一个普通的变量，而是主调程序（nature-numbers）的续延。可以把它想象成一个传送门，调用 (return ...) 就会立即将控制权和括号里的值一起“传送”回主调程序。 所以 (return (cons state i)) 这行代码的意义是：\n将我们刚刚捕获的“内部断点” state 和当前要产出的值 i 打包成一个 cons 对。 通过 return 这个“出口”，将这个包含了“未来”与“现在”的包裹，交还给主调程序。 至此，nature-gen 的一次“生成与暂停”就完成了。 set!：为下一次“恢复”更新出口 set! 语句是整个机制能反复运行的关键。当主调程序下一次要“恢复”协程时，它会提供一个新的“出口续延”。(set! return ...) 的作用就是将 nature-gen 内部记录的 return 更新为这个新的出口。否则，如果下次恢复时还使用旧的 return，程序就会陷入真正的时间循环，回到上一次调用的状态，那将是一场灾难！\n第二步：接口 nature-numbers 的封装艺术 如果说 nature-gen 是精密的引擎，那么 nature-numbers 就是驾驶舱，它负责启动引擎、处理引擎返回的状态，并为下一次启动做好准备。\n1 2 3 4 5 6 7 (define nature-numbers (let ((k nature-gen)) ; `k` 是状态存储器，初始为引擎本身 (define (tmp-interface) (let ((result (call/cc k))) ; 使用 call/cc 来启动或恢复引擎 (set! k (car result)) ; 保存引擎返回的新断点 (cdr result))) ; 返回生成的值 tmp-interface)) 让我们来追踪 (nature-numbers) 的前两次调用：\n第一次调用 (nature-numbers)：\n此时，k 的值是 nature-gen 这个函数本身。 执行 (call/cc k)，即 (call/cc nature-gen)。根据 call/cc 的规则，它会调用 nature-gen，并将 call/cc 自身的续延作为参数传进去。这个续延，就是 nature-gen 里的 return 参数！它代表的“未来”是：“拿到一个值，绑定给 result，然后继续执行 let 里的后续代码”。 nature-gen 开始执行，i 为 0。它遇到自己的 call/cc，捕获了内部断点 state。 nature-gen 调用 (return (cons state 0))。控制权立刻返回到 tmp-interface 的 let 表达式中，result 被绑定为 (cons state 0)。 (set! k (car result))：k 被更新为 state，即 nature-gen 的“暂停状态”。 (cdr result)：返回 0。第一次调用成功！ 第二次调用 (nature-numbers)：\n此时，k 的值已经是上一次保存的 state 续延（那个“时间胶囊”）。 再次执行 (call/cc k)。奇迹发生！调用一个续延 k 会让程序立即跳转回 k 被捕获的地方，也就是 nature-gen 内部的 call/cc 表达式处。同时，call/cc 现在的续延（代表着第二次调用的“未来”）会成为 k 的返回值。 也就是说，程序流回到了 nature-gen 中，set! 表达式的右侧部分返回了第二次调用的续延。这个新的续延被赋值给了 return，更新了“出口”。 nature-gen 从断点处继续执行 (loop (+ i 1))，此时 i 变成了 1。 重复第一次调用的流程：捕获新的断点 state'，通过新的 return 出口返回 (cons state' 1)。 tmp-interface 接收到 result，更新 k 为 state'，并返回 1。 就这样，每一次调用 nature-numbers，控制权都在主调程序的续延（return）和生成器的续延（k/state）之间进行一次优雅的交换。k 保存着协程的“过去”，而 call/cc 在调用时则提供了“未来”的去向。这正是协程——控制权的对等转移——最深刻、最本质的实现。一道看似简单的代码，背后却是控制流的绝妙魔法。\n展望：光剑出鞘，协程的应用场景 我们已经铸造了这柄名为续延的控制流“光剑”，并用它剖析了协程的内在机理。那么，这件强大的武器在真实的软件世界里，究竟能用来解决哪些棘手的问题呢？\n协程最广阔的战场，无疑是异步编程，尤其是处理网络请求、文件读写等 I/O 密集型任务。在传统的同步模型中，程序发起一个网络请求就必须“傻等”结果返回，CPU 在此期间完全被浪费。而协程就像一位技艺高超的厨房总管，他让一个任务去烤箱里“烤蛋糕”（等待网络响应），然后无需原地等待，立刻转身去“切菜”（处理其他计算），当烤箱叮咚作响（I/O 完成）时，他又能无缝地回来，继续完成蛋糕的装饰。这种非阻塞的模式极大地提升了程序的并发能力和资源利用率。今天，无数现代语言中的 async/await 语法，其背后正是协程思想的优雅体现。\n除了异步 I/O，协程还在许多领域闪耀着光芒：\n游戏开发：为游戏中的 NPC 编写行为逻辑。一个角色的复杂行动（例如“巡逻30秒”、“发现敌人后追击”、“丢失目标后返回”），可以被写成一个逻辑清晰的协程，而不是一个庞大而混乱的状态机。 数据流管道：构建高效的数据处理流水线。一个协程负责生产数据，另一个协程负责消费和处理，它们协同工作，像一条流畅的工厂传送带，优雅地处理无穷无尽的数据流。 用户界面：在保持 UI 流畅的同时执行耗时操作。将文件下载或图片处理任务放在协程中，可以防止界面冻结，为用户提供丝滑的体验。 总而言之，从我们这个小小的自然数生成器出发，我们窥见的是一种强大的编程范式。协程让我们能够用更符合人类直觉的、线性的方式，去编写本质上非线性的、并发的程序。它将复杂的控制流管理隐藏在优雅的 yield 或 await 之下，让开发者能更专注于业务逻辑本身。\n这柄曾经只属于 Scheme、Lisp 等“魔法师”语言的“光剑”，如今已成为现代软件开发中不可或缺的利器。\n","wordCount":"560","inLanguage":"en","datePublished":"2025-10-13T15:19:20+08:00","dateModified":"2025-10-13T15:19:20+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call-cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"},"publisher":{"@type":"Organization","name":"正确即是废话，废话亦是正确","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="正确即是废话，废话亦是正确 (Alt + H)">正确即是废话，废话亦是正确</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">协程、生成器与 call/cc 的控制流</h1><div class=post-meta><span title='2025-10-13 15:19:20 +0800 +0800'>October 13, 2025</span></div></header><div class=post-content><h2 id=上期回顾>上期回顾<a hidden class=anchor aria-hidden=true href=#上期回顾>#</a></h2><p>光剑系列的第三作！前两篇：</p><p>第一篇：<a href=https://www.luogu.com.cn/article/cr6hfiut>Let&rsquo;s build our mathematics by using lambda calculus && church encoding!</a></p><p>第二篇：<a href=https://www.luogu.com.cn/article/uhume1ou>惰性求值、无穷流与发生的魔法</a></p><h2 id=前言与一个震撼的-demo>前言与一个震撼的 demo<a hidden class=anchor aria-hidden=true href=#前言与一个震撼的-demo>#</a></h2><p>在上一篇文章中，我们探讨并实现了惰性求值与无穷流。希望你们还对自然数流印象深刻。</p><p>自然数流也可以视为一个不断生成新的自然数的生成器。那么，从这个意义上，我们有更简洁而强大的实现方式。</p><p>（还是一贯的 scheme 代码）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>nature-gen</span> <span class=nv>return</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=nv>loop</span> <span class=p>((</span><span class=nf>i</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>set! </span><span class=nv>return</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nf>call/cc</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nf>return</span> <span class=p>(</span><span class=nb>cons </span><span class=nv>state</span> <span class=nv>i</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>loop</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>i</span> <span class=mi>1</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>nature-numbers</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>k</span> <span class=nv>nature-gen</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>tmp-interface</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>result</span> <span class=p>(</span><span class=nb>call/cc </span><span class=nv>k</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>set! </span><span class=nv>k</span> <span class=p>(</span><span class=nb>car </span><span class=nv>result</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>cdr </span><span class=nv>result</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nv>tmp-interface</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>这就是一个自然数的生成器！每次调用 nature-numbers，它都会返回一个新的自然数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>&gt; (nature-numbers)
</span></span><span class=line><span class=cl>0
</span></span><span class=line><span class=cl>&gt; (nature-numbers)
</span></span><span class=line><span class=cl>1
</span></span><span class=line><span class=cl>&gt; (nature-numbers)
</span></span><span class=line><span class=cl>2
</span></span><span class=line><span class=cl>&gt; (nature-numbers)
</span></span><span class=line><span class=cl>3
</span></span><span class=line><span class=cl>&gt; (nature-numbers)
</span></span><span class=line><span class=cl>4
</span></span></code></pre></td></tr></table></div></div><h2 id=正文>正文<a hidden class=anchor aria-hidden=true href=#正文>#</a></h2><p>上面的代码虽然简短，但是相当晦涩。下面我们将一步步解开它的秘密。</p><h3 id=生成器可以暂停的函数>生成器：可以“暂停”的函数<a hidden class=anchor aria-hidden=true href=#生成器可以暂停的函数>#</a></h3><p>我们在文章开头用那段晦涩的 Scheme 代码创造的东西，用一个更广为人知的术语来说，就是一个 <strong>“生成器” (Generator)</strong>。</p><p>你可以把它想象成一个特殊的函数，它有一种超能力：可以在执行到一半时对自己喊“停！”，然后把一个值“扔”给调用者。当调用者下次再来找它时，它能从上次喊停的地方“满血复活”，继续执行。</p><p>其实，这个概念对很多程序员来说并不陌生。Python 中的 <code>yield</code> 关键字就是实现生成器的经典方式，我们开头的 <code>nature-numbers</code> 就等价于下面这段 Python 代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>nature_gen</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><p>回顾我们上一篇文章的<strong>无穷流</strong>，你会发现它惊人地相似！每次我们从流中取出一个数，计算就会“产出”一个结果，而“剩余的无穷计算”则被巧妙地<strong>冻结</strong>了。这正是生成器的思想：<strong>执行、产出、暂停、等待下一次恢复</strong>。</p><h3 id=协程控制权的对等转移>协程：控制权的对等转移<a hidden class=anchor aria-hidden=true href=#协程控制权的对等转移>#</a></h3><p>生成器这种“暂停-恢复”的模式，其实是一种更通用、更强大的编程思想的体现，那就是<strong>协程 (Coroutine)</strong>。</p><p>普通函数调用是“主仆”关系：主函数调用子函数，子函数必须执行完毕并返回，控制权才能回到主函数。这就像经理给员工派活，员工必须做完才能交差。</p><p>而协程之间是“对等”关系。它们就像两位正在对弈的棋手。你走一步，将控制权（棋盘的使用权）交给我；我走一步，再把控制权交还给你。任何一方都可以主动让出控制权。</p><p>看到这里，你应该明白了：<strong>生成器，正是一种非对称的协程！</strong> 它在 <code>yield</code> 时将控制权交还给主程序，主程序下次调用时又将控制权还给它，让它从断点处继续。</p><p>那么，真正的问题来了：这种“控制权的任意转移”是如何实现的？我们要怎样才能在代码中抓住“控制流”这个看不见摸不着的东西，让它暂停，又让它在未来某个时刻精确地恢复呢？要铸造这柄控制流的光剑，我们需要一种终极材料——<strong>续延。</strong></p><h3 id=续延捕获程序的未来>续延：捕获程序的“未来”<a hidden class=anchor aria-hidden=true href=#续延捕获程序的未来>#</a></h3><p>想象一下，当程序执行到某个特定点时，我们按下了“暂停”键。此时，<strong>“程序接下来要做的所有事情”</strong>，就是我们所说的 <strong>“续延” (Continuation)</strong>。
它就像一个包含了程序未来的“时间胶囊”。比如在这段 C++ 代码中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>*=</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// &lt;- 按下暂停键
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x</span> <span class=o>&lt;&lt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在注释标记的那一行，续延就是“把当前 <code>x</code> 的值左移一位，然后返回结果”。它封装了当前计算剩下的所有步骤。
<strong>续延，就是协程暂停时需要保存的那个“断点”的精确描述。</strong> 如果我们能拿到这个“断点”，并能在之后随时回到这里，协程的实现不就迎刃而解了吗？</p><h3 id=callcc铸造控制流的魔法棒>call/cc：铸造控制流的魔法棒<a hidden class=anchor aria-hidden=true href=#callcc铸造控制流的魔法棒>#</a></h3><p>在 Scheme 中，<code>call/cc</code> (全称 <code>call-with-current-continuation</code>) 就是这样一个强大的魔法，它能将抽象的“续延”概念物化成一个我们可以操作的实体。
它的作用正如其名：<strong>捕获当前的续延，并将它作为一个函数参数，传递给你指定的另一个函数。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=nf>call/cc</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>k</span><span class=p>)</span>  <span class=c1>; k 就是被捕获的续延</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>k</span> <span class=mi>3</span><span class=p>)))</span>
</span></span></code></pre></td></tr></table></div></div><p><code>k</code> 就是那个“时间胶囊”，一个代表了“未来”的函数。它和其他函数一样，是一等公民。
当你调用 <code>k</code> 并给它一个参数（例如 <code>(k 3)</code>）时，奇迹发生了：程序会<strong>立刻放弃当前的所有计算，瞬移回 <code>call/cc</code> 被调用的那个时间点</strong>，并将你给的参数 <code>3</code> 作为整个 <code>call/cc</code> 表达式的返回值。因此，上面表达式的值就是 3。
更神奇的是，这个“时间胶囊”可以被保存起来，反复使用！</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>saved-k</span> <span class=no>#f</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>result</span> <span class=p>(</span><span class=nb>+ </span><span class=mi>1</span> <span class=p>(</span><span class=nb>call/cc </span><span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>set! </span><span class=nv>saved-k</span> <span class=nv>k</span><span class=p>)</span> <span class=c1>; 把“时间胶囊”存起来</span>
</span></span><span class=line><span class=cl>    <span class=mi>5</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>display </span><span class=nv>result</span><span class=p>)</span> <span class=p>(</span><span class=nf>newline</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1>;; 第一次执行，call/cc 返回 5，所以 result 是 6，打印 6</span>
</span></span><span class=line><span class=cl><span class=c1>;; 现在，如果你在 REPL 中调用 (saved-k 100)</span>
</span></span><span class=line><span class=cl><span class=c1>;; 程序会瞬间回到 let 表达式中，仿佛 call/cc 刚刚返回了 100</span>
</span></span><span class=line><span class=cl><span class=c1>;; 于是 result 变为 101，并再次打印 101！</span>
</span></span></code></pre></td></tr></table></div></div><p>这个例子完美地展示了 <code>call/cc</code> 的威力：它不仅能逃出当前的计算，还能让我们在未来任何时候，都能像《命运石之门》一样，一次又一次地回到过去，并带着新的“世界线”参数（返回值）继续执行。</p><p>这样的强大工具可以用于构建任意控制流，也包括协程。你可能已经发现了，协程归还控制权时保存状态可以用续延简单实现。更具体地，我们可以直接返回协程内部用 call/cc 捕获的续延！然后再次调用协程时调用那个续延。</p><h3 id=庖丁解牛深入代码的魔法核心>庖丁解牛：深入代码的魔法核心<a hidden class=anchor aria-hidden=true href=#庖丁解牛深入代码的魔法核心>#</a></h3><p>现在，我们手握 <code>call/cc</code> 这柄能任意切割、重塑程序时间线的光剑，是时候回到最初那个令人惊叹的 demo，像一位精准的外科医生一样，剖析其运作的每一个细节了。</p><p>整个结构分为两部分：作为“协程引擎”的 <code>nature-gen</code>，以及作为“用户接口”的 <code>nature-numbers</code>。我们将模拟一次完整的“生成-暂停-恢复”流程来理解它们。</p><h4 id=第一步协程引擎-nature-gen-的内部构造>第一步：协程引擎 <code>nature-gen</code> 的内部构造<a hidden class=anchor aria-hidden=true href=#第一步协程引擎-nature-gen-的内部构造>#</a></h4><p><code>nature-gen</code> 函数是生成器的核心。它的设计精妙之处在于一场**“双续延之舞”**。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>nature-gen</span> <span class=nv>return</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=nv>loop</span> <span class=p>((</span><span class=nf>i</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>set! </span><span class=nv>return</span>  <span class=c1>; 3. 更新“出口”，为下次恢复做准备</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nf>call/cc</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>state</span><span class=p>)</span> <span class=c1>; 1. 捕获“内部断点”</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nf>return</span> <span class=p>(</span><span class=nb>cons </span><span class=nv>state</span> <span class=nv>i</span><span class=p>)))))</span> <span class=c1>; 2. 带着“断点”和值，从“出口”返回</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>loop</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>i</span> <span class=mi>1</span><span class=p>))))</span>
</span></span></code></pre></td></tr></table></div></div><p>让我们分解这支舞蹈的三个关键舞步：</p><ol><li><p><strong><code>state</code>：捕获“内部断点”</strong>
<code>call/cc</code> 在这里捕获了它所在位置的续延，我们称之为 <code>state</code>。这个 <code>state</code> 就是我们心心念念的“时间胶囊”，它精确地封装了 <code>nature-gen</code> 暂停时的一切：位于 <code>loop</code> 循环内，变量 <code>i</code> 的当前值，以及接下来要执行 <code>(loop (+ i 1))</code> 这个步骤的“未来”。</p></li><li><p><strong><code>return</code>：从指定的“出口”返回</strong>
<code>return</code> 参数是什么？它并不是一个普通的变量，而是<strong>主调程序（<code>nature-numbers</code>）的续延</strong>。可以把它想象成一个传送门，调用 <code>(return ...)</code> 就会立即将控制权和括号里的值一起“传送”回主调程序。
所以 <code>(return (cons state i))</code> 这行代码的意义是：</p><ul><li>将我们刚刚捕获的“内部断点” <code>state</code> 和当前要产出的值 <code>i</code> 打包成一个 <code>cons</code> 对。</li><li>通过 <code>return</code> 这个“出口”，将这个包含了“未来”与“现在”的包裹，交还给主调程序。
至此，<code>nature-gen</code> 的一次“生成与暂停”就完成了。</li></ul></li><li><p><strong><code>set!</code>：为下一次“恢复”更新出口</strong>
<code>set!</code> 语句是整个机制能反复运行的关键。当主调程序下一次要“恢复”协程时，它会提供一个新的“出口续延”。<code>(set! return ...)</code> 的作用就是将 <code>nature-gen</code> 内部记录的 <code>return</code> 更新为这个新的出口。否则，如果下次恢复时还使用旧的 <code>return</code>，程序就会陷入真正的时间循环，回到上一次调用的状态，那将是一场灾难！</p></li></ol><h4 id=第二步接口-nature-numbers-的封装艺术>第二步：接口 <code>nature-numbers</code> 的封装艺术<a hidden class=anchor aria-hidden=true href=#第二步接口-nature-numbers-的封装艺术>#</a></h4><p>如果说 <code>nature-gen</code> 是精密的引擎，那么 <code>nature-numbers</code> 就是驾驶舱，它负责启动引擎、处理引擎返回的状态，并为下一次启动做好准备。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>nature-numbers</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>k</span> <span class=nv>nature-gen</span><span class=p>))</span> <span class=c1>; `k` 是状态存储器，初始为引擎本身</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>tmp-interface</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>result</span> <span class=p>(</span><span class=nb>call/cc </span><span class=nv>k</span><span class=p>)))</span> <span class=c1>; 使用 call/cc 来启动或恢复引擎</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>set! </span><span class=nv>k</span> <span class=p>(</span><span class=nb>car </span><span class=nv>result</span><span class=p>))</span>     <span class=c1>; 保存引擎返回的新断点</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>cdr </span><span class=nv>result</span><span class=p>)))</span>            <span class=c1>; 返回生成的值</span>
</span></span><span class=line><span class=cl>    <span class=nv>tmp-interface</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>让我们来追踪 <code>(nature-numbers)</code> 的前两次调用：</p><ul><li><p><strong>第一次调用 <code>(nature-numbers)</code>：</strong></p><ol><li>此时，<code>k</code> 的值是 <code>nature-gen</code> 这个函数本身。</li><li>执行 <code>(call/cc k)</code>，即 <code>(call/cc nature-gen)</code>。根据 <code>call/cc</code> 的规则，它会调用 <code>nature-gen</code>，并将 <code>call/cc</code> <strong>自身的续延</strong>作为参数传进去。这个续延，就是 <code>nature-gen</code> 里的 <code>return</code> 参数！它代表的“未来”是：“拿到一个值，绑定给 <code>result</code>，然后继续执行 <code>let</code> 里的后续代码”。</li><li><code>nature-gen</code> 开始执行，<code>i</code> 为 0。它遇到自己的 <code>call/cc</code>，捕获了内部断点 <code>state</code>。</li><li><code>nature-gen</code> 调用 <code>(return (cons state 0))</code>。控制权立刻返回到 <code>tmp-interface</code> 的 <code>let</code> 表达式中，<code>result</code> 被绑定为 <code>(cons state 0)</code>。</li><li><code>(set! k (car result))</code>：<code>k</code> 被更新为 <code>state</code>，即 <code>nature-gen</code> 的“暂停状态”。</li><li><code>(cdr result)</code>：返回 <code>0</code>。第一次调用成功！</li></ol></li><li><p><strong>第二次调用 <code>(nature-numbers)</code>：</strong></p><ol><li>此时，<code>k</code> 的值已经是上一次保存的 <code>state</code> 续延（那个“时间胶囊”）。</li><li>再次执行 <code>(call/cc k)</code>。奇迹发生！调用一个续延 <code>k</code> 会让程序<strong>立即跳转</strong>回 <code>k</code> 被捕获的地方，也就是 <code>nature-gen</code> 内部的 <code>call/cc</code> 表达式处。同时，<code>call/cc</code> <strong>现在</strong>的续延（代表着第二次调用的“未来”）会成为 <code>k</code> 的返回值。</li><li>也就是说，程序流回到了 <code>nature-gen</code> 中，<code>set!</code> 表达式的右侧部分返回了第二次调用的续延。这个新的续延被赋值给了 <code>return</code>，更新了“出口”。</li><li><code>nature-gen</code> 从断点处继续执行 <code>(loop (+ i 1))</code>，此时 <code>i</code> 变成了 <code>1</code>。</li><li>重复第一次调用的流程：捕获新的断点 <code>state'</code>，通过新的 <code>return</code> 出口返回 <code>(cons state' 1)</code>。</li><li><code>tmp-interface</code> 接收到 <code>result</code>，更新 <code>k</code> 为 <code>state'</code>，并返回 <code>1</code>。</li></ol></li></ul><p>就这样，每一次调用 <code>nature-numbers</code>，控制权都在主调程序的续延（<code>return</code>）和生成器的续延（<code>k</code>/<code>state</code>）之间进行一次优雅的交换。<code>k</code> 保存着协程的“过去”，而 <code>call/cc</code> 在调用时则提供了“未来”的去向。这正是协程——控制权的对等转移——最深刻、最本质的实现。一道看似简单的代码，背后却是控制流的绝妙魔法。</p><h3 id=展望光剑出鞘协程的应用场景>展望：光剑出鞘，协程的应用场景<a hidden class=anchor aria-hidden=true href=#展望光剑出鞘协程的应用场景>#</a></h3><p>我们已经铸造了这柄名为续延的控制流“光剑”，并用它剖析了协程的内在机理。那么，这件强大的武器在真实的软件世界里，究竟能用来解决哪些棘手的问题呢？</p><p>协程最广阔的战场，无疑是<strong>异步编程</strong>，尤其是处理网络请求、文件读写等 I/O 密集型任务。在传统的同步模型中，程序发起一个网络请求就必须“傻等”结果返回，CPU 在此期间完全被浪费。而协程就像一位技艺高超的厨房总管，他让一个任务去烤箱里“烤蛋糕”（等待网络响应），然后无需原地等待，立刻转身去“切菜”（处理其他计算），当烤箱叮咚作响（I/O 完成）时，他又能无缝地回来，继续完成蛋糕的装饰。这种非阻塞的模式极大地提升了程序的并发能力和资源利用率。今天，无数现代语言中的 <code>async/await</code> 语法，其背后正是协程思想的优雅体现。</p><p>除了异步 I/O，协程还在许多领域闪耀着光芒：</p><ul><li><strong>游戏开发</strong>：为游戏中的 NPC 编写行为逻辑。一个角色的复杂行动（例如“巡逻30秒”、“发现敌人后追击”、“丢失目标后返回”），可以被写成一个逻辑清晰的协程，而不是一个庞大而混乱的状态机。</li><li><strong>数据流管道</strong>：构建高效的数据处理流水线。一个协程负责生产数据，另一个协程负责消费和处理，它们协同工作，像一条流畅的工厂传送带，优雅地处理无穷无尽的数据流。</li><li><strong>用户界面</strong>：在保持 UI 流畅的同时执行耗时操作。将文件下载或图片处理任务放在协程中，可以防止界面冻结，为用户提供丝滑的体验。</li></ul><p>总而言之，从我们这个小小的自然数生成器出发，我们窥见的是一种强大的编程范式。协程让我们能够用更符合人类直觉的、线性的方式，去编写本质上非线性的、并发的程序。它将复杂的控制流管理隐藏在优雅的 <code>yield</code> 或 <code>await</code> 之下，让开发者能更专注于业务逻辑本身。</p><p>这柄曾经只属于 Scheme、Lisp 等“魔法师”语言的“光剑”，如今已成为现代软件开发中不可或缺的利器。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/plt/>PLT</a></li><li><a href=https://litjohn.github.io/tags/lisp/scheme/racket/>Lisp/Scheme/Racket</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>正确即是废话，废话亦是正确</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>