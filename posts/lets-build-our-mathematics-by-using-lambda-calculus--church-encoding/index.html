<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Let's Build Our Mathematics by Using Lambda Calculus && Church Encoding! | litjohn's blog</title><meta name=keywords content="PLT,lisp/scheme/racket"><meta name=description content="致谢
Gemini 2.5 Pro 0325 && 0506：文本润色、事实正确性审查，以及帮助我学习、理解和回忆这些内容。
myster1ous： 给予我巨大的启发，帮助我构建出 prev 函数。
前言
本文是光剑系列的第一作，又名《lambda 演算，邱奇编码与优雅的计算模型》。
本文的目的是带领大家踏上一段奇妙的旅程：我们将使用 λ 演算（Lambda Calculus）这一极简的计算模型，并通过丘奇编码（Church Encoding）这一巧妙的技术，一步步构建出我们日常编程中熟悉和依赖的计算体系，例如数字、布尔逻辑乃至更复杂的数据结构。
为了方便演示和实践，本文中的所有代码示例都将使用 Scheme 语言。Scheme 是 Lisp 家族的一员，它的语法是 S-表达式 (Symbolic Expressions)。S-表达式不仅简洁优雅，而且其结构与 λ 演算的表达方式惊人地契合。
在我们开始之前，让我们先快速了解一下 S-表达式：

核心是列表 (List)： S-表达式的基本形式是由圆括号 () 包围起来的列表。
结构：(操作符 参数1 参数2 ...)： 列表中的第一个元素通常是操作符（即要应用的函数），其余元素则是传递给该操作符的参数。
原子 (Atom) 与嵌套： 列表中的元素可以是原子（如数字 123、符号 x、+），也可以是另一个 S-表达式。这种嵌套能力使得 S-表达式可以表示复杂的树状结构。

例如，表达式 (+ 1 (* 2 3)) 在 Scheme 中表示数学上的 1 + (2 * 3)。
这里：

最外层的 (+ 1 (* 2 3)) 是一个 S-表达式。+ 是操作符，1 和 (* 2 3) 是它的参数。
(* 2 3) 本身也是一个 S-表达式。* 是操作符，2 和 3 是它的参数。执行它会得到 6。
所以整个表达式 (+ 1 6) 最终会计算得到 7。

理解了 S-表达式，我们就可以更顺畅地进入 λ 演算的世界了。"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/lets-build-our-mathematics-by-using-lambda-calculus--church-encoding/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/lets-build-our-mathematics-by-using-lambda-calculus--church-encoding/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/lets-build-our-mathematics-by-using-lambda-calculus--church-encoding/"><meta property="og:site_name" content="litjohn's blog"><meta property="og:title" content="Let's Build Our Mathematics by Using Lambda Calculus && Church Encoding!"><meta property="og:description" content="致谢 Gemini 2.5 Pro 0325 && 0506：文本润色、事实正确性审查，以及帮助我学习、理解和回忆这些内容。
myster1ous： 给予我巨大的启发，帮助我构建出 prev 函数。
前言 本文是光剑系列的第一作，又名《lambda 演算，邱奇编码与优雅的计算模型》。
本文的目的是带领大家踏上一段奇妙的旅程：我们将使用 λ 演算（Lambda Calculus）这一极简的计算模型，并通过丘奇编码（Church Encoding）这一巧妙的技术，一步步构建出我们日常编程中熟悉和依赖的计算体系，例如数字、布尔逻辑乃至更复杂的数据结构。
为了方便演示和实践，本文中的所有代码示例都将使用 Scheme 语言。Scheme 是 Lisp 家族的一员，它的语法是 S-表达式 (Symbolic Expressions)。S-表达式不仅简洁优雅，而且其结构与 λ 演算的表达方式惊人地契合。
在我们开始之前，让我们先快速了解一下 S-表达式：
核心是列表 (List)： S-表达式的基本形式是由圆括号 () 包围起来的列表。 结构：(操作符 参数1 参数2 ...)： 列表中的第一个元素通常是操作符（即要应用的函数），其余元素则是传递给该操作符的参数。 原子 (Atom) 与嵌套： 列表中的元素可以是原子（如数字 123、符号 x、+），也可以是另一个 S-表达式。这种嵌套能力使得 S-表达式可以表示复杂的树状结构。 例如，表达式 (+ 1 (* 2 3)) 在 Scheme 中表示数学上的 1 + (2 * 3)。 这里：
最外层的 (+ 1 (* 2 3)) 是一个 S-表达式。+ 是操作符，1 和 (* 2 3) 是它的参数。 (* 2 3) 本身也是一个 S-表达式。* 是操作符，2 和 3 是它的参数。执行它会得到 6。 所以整个表达式 (+ 1 6) 最终会计算得到 7。 理解了 S-表达式，我们就可以更顺畅地进入 λ 演算的世界了。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-13T14:57:18+08:00"><meta property="article:modified_time" content="2025-10-13T14:57:18+08:00"><meta property="article:tag" content="PLT"><meta property="article:tag" content="Lisp/Scheme/Racket"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call/cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/"><meta property="og:see_also" content="https://litjohn.github.io/posts/cps%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E5%9B%9B%E5%8D%81%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%A0%E8%AF%B4/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Let's Build Our Mathematics by Using Lambda Calculus && Church Encoding!"><meta name=twitter:description content="致谢
Gemini 2.5 Pro 0325 && 0506：文本润色、事实正确性审查，以及帮助我学习、理解和回忆这些内容。
myster1ous： 给予我巨大的启发，帮助我构建出 prev 函数。
前言
本文是光剑系列的第一作，又名《lambda 演算，邱奇编码与优雅的计算模型》。
本文的目的是带领大家踏上一段奇妙的旅程：我们将使用 λ 演算（Lambda Calculus）这一极简的计算模型，并通过丘奇编码（Church Encoding）这一巧妙的技术，一步步构建出我们日常编程中熟悉和依赖的计算体系，例如数字、布尔逻辑乃至更复杂的数据结构。
为了方便演示和实践，本文中的所有代码示例都将使用 Scheme 语言。Scheme 是 Lisp 家族的一员，它的语法是 S-表达式 (Symbolic Expressions)。S-表达式不仅简洁优雅，而且其结构与 λ 演算的表达方式惊人地契合。
在我们开始之前，让我们先快速了解一下 S-表达式：

核心是列表 (List)： S-表达式的基本形式是由圆括号 () 包围起来的列表。
结构：(操作符 参数1 参数2 ...)： 列表中的第一个元素通常是操作符（即要应用的函数），其余元素则是传递给该操作符的参数。
原子 (Atom) 与嵌套： 列表中的元素可以是原子（如数字 123、符号 x、+），也可以是另一个 S-表达式。这种嵌套能力使得 S-表达式可以表示复杂的树状结构。

例如，表达式 (+ 1 (* 2 3)) 在 Scheme 中表示数学上的 1 + (2 * 3)。
这里：

最外层的 (+ 1 (* 2 3)) 是一个 S-表达式。+ 是操作符，1 和 (* 2 3) 是它的参数。
(* 2 3) 本身也是一个 S-表达式。* 是操作符，2 和 3 是它的参数。执行它会得到 6。
所以整个表达式 (+ 1 6) 最终会计算得到 7。

理解了 S-表达式，我们就可以更顺畅地进入 λ 演算的世界了。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Let's Build Our Mathematics by Using Lambda Calculus \u0026\u0026 Church Encoding!","item":"https://litjohn.github.io/posts/lets-build-our-mathematics-by-using-lambda-calculus--church-encoding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Let's Build Our Mathematics by Using Lambda Calculus \u0026\u0026 Church Encoding!","name":"Let\u0027s Build Our Mathematics by Using Lambda Calculus \u0026\u0026 Church Encoding!","description":"致谢 Gemini 2.5 Pro 0325 \u0026amp;\u0026amp; 0506：文本润色、事实正确性审查，以及帮助我学习、理解和回忆这些内容。\nmyster1ous： 给予我巨大的启发，帮助我构建出 prev 函数。\n前言 本文是光剑系列的第一作，又名《lambda 演算，邱奇编码与优雅的计算模型》。\n本文的目的是带领大家踏上一段奇妙的旅程：我们将使用 λ 演算（Lambda Calculus）这一极简的计算模型，并通过丘奇编码（Church Encoding）这一巧妙的技术，一步步构建出我们日常编程中熟悉和依赖的计算体系，例如数字、布尔逻辑乃至更复杂的数据结构。\n为了方便演示和实践，本文中的所有代码示例都将使用 Scheme 语言。Scheme 是 Lisp 家族的一员，它的语法是 S-表达式 (Symbolic Expressions)。S-表达式不仅简洁优雅，而且其结构与 λ 演算的表达方式惊人地契合。\n在我们开始之前，让我们先快速了解一下 S-表达式：\n核心是列表 (List)： S-表达式的基本形式是由圆括号 () 包围起来的列表。 结构：(操作符 参数1 参数2 ...)： 列表中的第一个元素通常是操作符（即要应用的函数），其余元素则是传递给该操作符的参数。 原子 (Atom) 与嵌套： 列表中的元素可以是原子（如数字 123、符号 x、+），也可以是另一个 S-表达式。这种嵌套能力使得 S-表达式可以表示复杂的树状结构。 例如，表达式 (+ 1 (* 2 3)) 在 Scheme 中表示数学上的 1 + (2 * 3)。 这里：\n最外层的 (+ 1 (* 2 3)) 是一个 S-表达式。+ 是操作符，1 和 (* 2 3) 是它的参数。 (* 2 3) 本身也是一个 S-表达式。* 是操作符，2 和 3 是它的参数。执行它会得到 6。 所以整个表达式 (+ 1 6) 最终会计算得到 7。 理解了 S-表达式，我们就可以更顺畅地进入 λ 演算的世界了。\n","keywords":["PLT","lisp/scheme/racket"],"articleBody":"致谢 Gemini 2.5 Pro 0325 \u0026\u0026 0506：文本润色、事实正确性审查，以及帮助我学习、理解和回忆这些内容。\nmyster1ous： 给予我巨大的启发，帮助我构建出 prev 函数。\n前言 本文是光剑系列的第一作，又名《lambda 演算，邱奇编码与优雅的计算模型》。\n本文的目的是带领大家踏上一段奇妙的旅程：我们将使用 λ 演算（Lambda Calculus）这一极简的计算模型，并通过丘奇编码（Church Encoding）这一巧妙的技术，一步步构建出我们日常编程中熟悉和依赖的计算体系，例如数字、布尔逻辑乃至更复杂的数据结构。\n为了方便演示和实践，本文中的所有代码示例都将使用 Scheme 语言。Scheme 是 Lisp 家族的一员，它的语法是 S-表达式 (Symbolic Expressions)。S-表达式不仅简洁优雅，而且其结构与 λ 演算的表达方式惊人地契合。\n在我们开始之前，让我们先快速了解一下 S-表达式：\n核心是列表 (List)： S-表达式的基本形式是由圆括号 () 包围起来的列表。 结构：(操作符 参数1 参数2 ...)： 列表中的第一个元素通常是操作符（即要应用的函数），其余元素则是传递给该操作符的参数。 原子 (Atom) 与嵌套： 列表中的元素可以是原子（如数字 123、符号 x、+），也可以是另一个 S-表达式。这种嵌套能力使得 S-表达式可以表示复杂的树状结构。 例如，表达式 (+ 1 (* 2 3)) 在 Scheme 中表示数学上的 1 + (2 * 3)。 这里：\n最外层的 (+ 1 (* 2 3)) 是一个 S-表达式。+ 是操作符，1 和 (* 2 3) 是它的参数。 (* 2 3) 本身也是一个 S-表达式。* 是操作符，2 和 3 是它的参数。执行它会得到 6。 所以整个表达式 (+ 1 6) 最终会计算得到 7。 理解了 S-表达式，我们就可以更顺畅地进入 λ 演算的世界了。\nλ 演算：计算的本质 λ 演算（Lambda Calculus）由阿隆佐·丘奇在 20 世纪 30 年代提出，它是一个极其简洁却具有图灵完备计算能力的数学形式系统。这意味着任何可计算的函数都可以用 λ 演算来表达和计算。\nλ 演算的核心要素出奇地少，主要包括：\n变量 (Variables): 如 x, y, f 等，用作参数名或函数本身的占位符。 函数抽象 (Function Abstraction): 这是定义一个新（通常是匿名的）函数的过程。 函数应用 (Function Application): 这是将一个函数作用于其参数（即调用函数）的过程。 让我们逐一来看。\n1. 函数抽象 (定义函数) 在传统的数学或 λ 演算表示法中，一个接受参数 x 并返回表达式 E 的函数可以写为 $\\lambda x.E$。 在 Scheme (以及本文的 S-表达式) 中，我们这样表示：\n(lambda (x) E) 这里的 lambda 是一个特殊的关键字，表示我们正在定义一个匿名函数。(x) 是参数列表（这里只有一个参数 x），而 E 是函数体，代表函数要执行的计算并返回的结果。\n例如，一个接受参数 x 并简单返回 x 本身的函数 (称为恒等函数)：\n(lambda (x) x) 这是一个非常基础但重要的函数。\n再举一个例子，一个接受参数 x 并期望返回 x+1 的函数：\n(lambda (x) (+ x 1)) 请注意： 在这个例子中，我们暂时借用了 Scheme 中预定义的 + 操作符和数字 1。这有助于我们直观地理解函数定义。然而，在纯粹的 λ 演算中，并不存在预定义的数字或算术运算符。一切——包括数字、布尔值和运算——都需要从最基本的函数抽象和应用来构建。这正是我们稍后将通过“丘奇编码”来实现的迷人之处！现在，请将注意力集中在 lambda 如何定义一个接受输入、进行处理、然后输出结果的“黑盒子”。\n这些用 lambda 定义的函数都是匿名函数，它们没有名字。\n2. 函数应用 (调用函数) 定义了函数，我们自然需要调用它。在传统表示法中，将函数 $f$ 应用于参数 $a$ 通常写作 $f(a)$ 或 $f;a$。 在 S-表达式中，函数应用的形式非常统一：\n(f a) 其中 f 是要应用的函数，a 是传递给函数的参数。\n如果我们想直接应用一个匿名函数，可以这样做：\n((lambda (x) (+ x 1)) 5) 这个表达式的含义是：将匿名函数 (lambda (x) (+ x 1)) 应用于参数 5。计算过程（我们稍后会详细讨论其规则）会得到 6。\n虽然纯粹的 λ 演算主要处理匿名函数，但在像 Scheme 这样的编程语言中，为了代码的清晰和可重用性，我们通常会给函数命名。这可以通过 define 实现：\n(define inc (lambda (x) (+ x 1))) 这里，我们将前面定义的“加一”函数命名为 inc。现在，我们可以通过名字来调用它：\n(inc 5) ; 这将返回 6 (inc 10) ; 这将返回 11 需要强调的是，define 并不是 λ 演算本身的一部分，它是 Scheme 提供的用于绑定名称到值的便利工具。在 λ 演算的理论探讨中，我们更多关注匿名函数及其组合。\n3. 万物皆函数：λ 演算的核心思想 λ 演算最令人着迷的一点或许是它的极简主义哲学：在纯粹的 λ 演算中，一切皆是函数。 我们通常认为理所当然存在的数字 (0, 1, 2…)、布尔值 (真/假)、条件判断 (if-then-else)、数据结构 (如列表) 等等，在 λ 演算的宇宙中，都是通过巧妙地组合和嵌套函数来表达的。\n这意味着，理论上我们只需要“定义函数”和“应用函数”这两个基本操作，就能构建出整个可计算的世界。这听起来可能有些抽象和不可思议，但别担心，本文的后半部分将通过丘奇编码来具体展示如何用函数来表示数字和布尔值，并在此基础上进行运算。\nλ 演算的运算法则 λ 演算有几条基本的变换规则，它们定义了表达式如何被“计算”或“简化”。最重要的规则有：\na. α-变换 (Alpha Conversion / α-renaming) α-变换指的是，在不改变函数行为的前提下，可以对函数定义中的绑定变量（即参数名）进行重命名。\n例如，以下两个函数定义是完全等价的：\n(lambda (x) (+ x 1)) 和\n(lambda (y) (+ y 1)) （用传统符号表示即 $\\lambda x.x+1$ 等价于 $\\lambda y.y+1$）\n只要新的参数名不与函数体内的自由变量（即那些不是由当前 lambda 定义的参数，而是来自外部作用域的变量）冲突，这种重命名就是有效的。α-变换告诉我们，参数的具体名字是什么并不重要，重要的是函数的结构和行为。\nb. β-规约 (Beta Reduction) β-规约是 λ 演算的“引擎”，它描述了函数应用（调用）是如何执行的，其本质就是代入 (substitution)。\n当一个形如 ((lambda (v) E_body) E_arg) 的表达式出现时（即一个 lambda 函数紧接着被一个参数应用），β-规约允许我们将函数体 E_body 中所有出现的绑定变量 v 都替换成实际参数 E_arg 的（经过求值的）副本。\n例如，对于表达式：\n((lambda (x) (+ x 1)) 5) 根据 β-规约：\n找到 lambda 的参数 x 和函数体 (+ x 1)。 找到实际传入的参数 5。 将函数体 (+ x 1) 中的所有（自由出现的）x 替换为 5。 得到新的表达式：(+ 5 1)。 在 Scheme 环境下，这个表达式 (+ 5 1) 会被进一步求值为 6。β-规约是实现计算的核心步骤。\nc. η-变换 (Eta Conversion / η-reduction) η-变换表达了函数外延性的概念：如果两个函数对于所有可能的输入都产生相同的结果，那么它们就是等价的。\n形式上，如果 F 是一个函数，且变量 x 在 F 中不是自由变量 (not free in F)，那么： (lambda (x) (F x)) 等价于 F。 （用传统符号表示即 $\\lambda x.(F;x)$ 等价于 $F$，如果 $x \\notin FV(F)$）\n这意味着，如果一个函数的唯一作用就是将其参数传递给另一个函数 F 并返回结果，那么这个外层包裹的函数实际上就是 F 本身。\n例如，如果我们有函数 inc (定义为 (lambda (z) (+ z 1)))，那么： (lambda (y) (inc y)) 就 η-等价于 inc 本身。\nα-变换、β-规约和（可选的）η-变换共同构成了 λ 演算的计算基础。对于构建我们的计算体系而言，β-规约是最直接相关的“执行”规则。\n柯里化 (Currying)：用一元函数模拟多元函数 你可能已经注意到，在纯粹的 λ 演算定义中，函数抽象（lambda）一次只绑定一个参数。例如我们前面看到的 (lambda (x) x)（$\\lambda x.x$）或 (lambda (x) (+ x 1))（$\\lambda x.x+1$）。那么，我们如何表示需要多个参数的函数呢，比如一个计算两数之积的函数，直觉上可能会写成类似 (lambda (x y) (* x y))（或 $\\lambda xy. x \\times y$）的形式？\n在纯粹的 λ 演算中，函数严格来说只接受一个参数。但是，通过一种称为柯里化 (Currying) 的巧妙技巧（以逻辑学家哈斯凯尔·柯里命名），我们可以用这些一元函数来优雅地实现多元函数的效果。\n这里的关键在于 λ 演算中的一个核心特性：函数是“一等公民”。这意味着函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。能够接受函数作为参数或返回函数的函数，我们称之为高阶函数 (Higher-Order Functions)。\n柯里化的思想很简单： 要模拟一个接受多个参数（比如 n 个）的函数，我们可以：\n定义一个一元函数，它接受第一个参数。 这个函数返回一个新的一元函数，这个新函数接受第二个参数。 这个新函数又返回一个更新的一元函数，接受第三个参数… 如此往复，直到所有 n 个参数都被逐个接受。最后一个返回的函数才会最终计算并返回结果。 让我们看一个例子。假设我们想实现一个两数相乘的函数 multiply(x, y)。通过柯里化，它可以表示为：\n$\\lambda x . (\\lambda y . x \\times y)$\n在 Scheme 中，这对应于：\n(lambda (x) (lambda (y) (* x y))) 这个表达式做了什么？\n它首先定义了一个匿名函数，接受参数 x。 当这个函数被调用（比如传入 3）时，它并不会立即计算乘积，而是返回另一个新的匿名函数。这个新的函数“记住”了 x 的值（比如 3），并且它接受一个参数 y。 当这个返回的新函数被调用（比如传入 4）并传入 y 的值时，它才会执行 (* x y)（即 (* 3 4)），返回最终结果 12。 我们如何使用这个柯里化的乘法函数呢？\n; 定义柯里化的乘法函数 (define curried-mult (lambda (x) (lambda (y) (* x y)))) ; 应用第一个参数 (define times-three (curried-mult 3)) ; (curried-mult 3) 返回的是 (lambda (y) (* 3 y)) ; times-three 现在就是这个新函数 ; 应用第二个参数 (display (times-three 5)) ; 输出 15 ; 或者一步到位地调用 (display ((curried-mult 3) 5)) ; 输出 15 通过柯里化，我们成功地用一系列只接受单个参数的函数模拟了多参数函数的功能。这在 λ 演算的理论框架中至关重要，因为它表明仅用一元函数就足以表达所有计算。在很多函数式编程语言中，虽然它们可能提供了直接定义多参数函数的语法，但其底层有时就是通过柯里化来实现或解释的，或者柯里化本身就是一种推荐的编程范式。\n一层又一层抽象：构建复杂性的阶梯 计算机科学与工程的伟大之处，很大程度上在于其精妙的抽象分层 (Layers of Abstraction)。我们从最底层的物理现象开始：\n我们抽象晶体管的行为，得到逻辑门（与门、或门、非门）。 我们抽象逻辑门的组合，得到算术逻辑单元 (ALU)、存储单元等。 我们抽象这些硬件组件的协同工作，得到完整的计算机体系结构。 然后，我们抽象硬件的细节，得到机器语言。 我们进一步抽象机器语言，得到汇编语言和指令集架构 (ISA)。 再往上，我们抽象汇编指令，得到C、Java、Python等高级编程语言，它们提供了更接近人类思维的表达方式。 甚至在高级语言内部，我们也会构建库、框架，提供更高层次的抽象来解决特定领域的问题。 每一层都依赖于其下一层提供的功能，同时向上一层隐藏了不必要的复杂细节。这使得我们能够专注于当前层次的问题，而不必每次都从最原始的元素（比如电子的运动）开始思考。\n在本文探索 λ 演算和丘奇编码的旅程中，我们也将采用类似的方法。 一旦我们成功地用 λ 演算定义了一个概念（比如布尔值、数字或某个运算），在后续的构造中，我们就会把它当作一个已知的、可以直接使用的“基本构建块”或“新定义的原语 (primitive)”。 我们不会在每次使用时都将其完全展开回最原始的 lambda 表达式形态（除非为了阐释特定原理）。\n例如，一旦我们用 λ 表达式定义了数字 ZERO、ONE 和加法运算 ADD：\n在讨论乘法时，我们就可以直接写 (ADD ONE ONE) 来表示 1+1，而不需要把 ADD, ONE 都展开成它们底层的 lambda 定义。 这样做可以让我们保持思路清晰，逐步构建更复杂的系统，而不至于迷失在无尽的 lambda 嵌套中。\n现在，我们已经了解了 λ 演算的基本规则和柯里化这一重要技巧（它让我们能方便地处理多“参数”的函数），是时候开始用这些积木搭建我们计算世界的第一块基石了！\n构建数学与计算体系的开始：基本元素 正如我们之前讨论的，纯粹的 λ 演算只拥有函数抽象（定义函数）和函数应用（调用函数）这两个基本构建块。我们日常编程中习以为常的“数字”、“自然数”、“加法运算”，乃至“字符”、“布尔值”（真/假）等等，在 λ 演算的原始宇宙中并不直接存在。\n显然，如果缺少这些基本的数据类型和运算，我们很难用常规的思路来编写程序。\n然而，λ 演算的强大之处在于，我们可以完全利用其自身的体系来构造出这些常用的对象。换句话说，我们可以为这些概念找到它们在 λ 演算世界中的函数式对应物 (functional counterparts)。\n这个将数据类型和运算用纯函数来表达和实现的过程，正是丘奇编码 (Church Encoding) 的核心思想，由阿隆佐·丘奇本人开创。\n让我们从最基本、也可能是最简单的概念开始：布尔值 (Booleans)。\n布尔值 (Booleans) 与逻辑运算 布尔逻辑是计算的基石，它处理的是“真”与“假”这两个基本值。在丘奇编码中，这两个值被巧妙地定义为两个不同的选择函数：\ntrue 被定义为一个函数，它接受两个参数，并总是选择并返回第一个参数。 $$ true := \\lambda t . \\lambda f . t $$ 或者，使用我们之前约定的 Scheme 多参数函数抽象（内部通过柯里化实现）：\n(define true (lambda (t f) t)) false 被定义为一个函数，它接受两个参数，并总是选择并返回第二个参数。 $$ false := \\lambda t . \\lambda f . f $$\n(define false (lambda (t f) f)) 这两个定义的神奇之处在于，它们内在地编码了条件选择的行为，这正是 if-then-else 语句的核心！ 如果我们有一个丘奇布尔值 condition，以及两个表达式 then-expr 和 else-expr，那么： (condition then-expr else-expr) 这个表达式本身就会根据 condition 是 true 还是 false 来求值：\n如果 condition 是 true，例如 (true \"苹果\" \"香蕉\")，它会返回 \"苹果\" (第一个参数)。 如果 condition 是 false，例如 (false \"苹果\" \"香蕉\")，它会返回 \"香蕉\" (第二个参数)。 有了 true 和 false 这两个基本构建块，我们就可以定义出标准的逻辑运算符：\n逻辑非 (NOT): (not x) not 应该将 true 变为 false，将 false 变为 true。 我们可以这样定义 not：\n(define (not x) ; x 是一个选择函数，它会从后面两个参数中选一个 ; 如果 x 是 true, 它选择第一个参数 (false)。 ; 如果 x 是 false, 它选择第二个参数 (true)。 (x false true)) 验证：\n(not true) 会展开为 (true false true)，根据 true 的定义，返回 false。 (not false) 会展开为 (false false true)，根据 false 的定义，返回 true。 逻辑与 (AND): (and p q) p AND q 为真，当且仅当 p 和 q 都为真。\n(define (and p q) ; 如果 p 是 true，则 AND 的结果取决于 q (实际上是 q 本身) ; 如果 p 是 false，则 AND 的结果一定是 false (p q false)) ; 注：这里 q 必须也是一个丘奇布尔值 解释：\n如果 p 是 true：表达式变为 (true q false)。true 选择第一个参数，即 q。所以 (and true q) 的结果就是 q。 若 q 是 true，结果是 true。 若 q 是 false，结果是 false。 如果 p 是 false：表达式变为 (false q false)。false 选择第二个参数，即 false。所以 (and false q) 的结果总是 false。 这完全符合 AND 的逻辑。 (你原文中的 (p (q true false) false) 也是完全正确的，它更明确地将 q 的结果约束在 true 或 false 上，如果 q 本身已经是丘奇布尔值， (q true false) 就等价于 q。) 逻辑或 (OR): (or p q) p OR q 为真，只要 p 或 q 中至少一个为真。\n(define (or p q) ; 如果 p 是 true，则 OR 的结果一定是 true ; 如果 p 是 false，则 OR 的结果取决于 q (实际上是 q 本身) (p true q)) ; 注：这里 q 必须也是一个丘奇布尔值 解释：\n如果 p 是 true：表达式变为 (true true q)。true 选择第一个参数，即 true。所以 (or true q) 的结果总是 true。 如果 p 是 false：表达式变为 (false true q)。false 选择第二个参数，即 q。所以 (or false q) 的结果就是 q。 若 q 是 true，结果是 true。 若 q 是 false，结果是 false。 这完美符合 OR 的逻辑。 (同样，你原文的 (p true (q true false)) 也是正确的。) 阿隆佐·丘奇选择用“选择函数”来代表布尔值，这无疑是一个天才般的洞察。“选择”这一行为完美地概括了我们通常使用布尔值所做的核心操作——基于条件做出决策——这也使得后续逻辑运算的定义变得异常简洁和优雅。我们仅仅通过函数定义和应用，就凭空创造出了逻辑系统！\n小扩展：更直观的 if 结构 既然我们的丘奇布尔值 true 和 false 本身就是选择函数，我们自然可以定义一个更符合我们日常编程直觉的 if 控制结构。这个 if 函数将接受三个参数：一个条件 (丘奇布尔值)，一个“then”分支的表达式，以及一个“else”分支的表达式。\n(define (if-then-else condition then-branch else-branch) (condition then-branch else-branch)) 你可能会问，这和直接写 (condition then-branch else-branch) 有什么本质区别呢？确实，通过我们前面讨论过的 η-变换 (Eta Conversion)，(lambda (c t e) (c t e)) 其实就等价于一个直接接受 c, t, e 并应用的结构（在Scheme中，多参数函数可以看作是柯里化的一种语法糖）。 然而，定义这样一个 if-then-else 函数的好处在于：\n可读性： (if-then-else hungry? (eat food) (sleep)) 比 (hungry? (eat food) (sleep)) 更明确地表达了条件判断的意图，尤其是当 hungry? 本身也是一个复杂表达式时。 抽象的体现： 它再次强调了我们可以通过函数封装来构建我们熟悉的编程构造。这更像是一种“语法糖”，它向我们展示了如何将底层的函数式构造包装成更易读、更符合特定编程范式的形式。 这再次提醒我们，λ 演算的表达能力是灵活的，我们可以基于核心规则构建出我们需要的抽象层次。\n自然数 (Natural Numbers)：函数的重复应用 继布尔值之后，下一个重要的基石是自然数 (Natural Numbers)，如 0, 1, 2, … 与布尔值通过“选择”来定义不同，自然数的丘奇编码抓住的是“重复”或“迭代”这一核心概念。\n阿隆佐·丘奇的天才之处在于他意识到，数字可以被表示为高阶函数，其含义是“一个函数被应用的次数”。\n具体来说，一个丘奇数 n 是一个函数，它接受两个参数：\n一个函数 f (代表要被重复应用的操作)。 一个初始值 x (代表该操作的起点，或者说被操作的对象)。 这个丘奇数 n 会将 f 应用到 x 上恰好 n 次。\n“重复应用 n 次”如何用纯函数定义呢？ 我们没有循环语句，也没有内置的计数器。 答案在于巧妙地利用函数本身的结构，类似于数学中从 0 和后继操作构建自然数的皮亚诺公理 (Peano Axioms)。\n数字 零 (ZERO) 数字 零 (ZERO) 就代表“将函数 f 应用零次”。这意味着无论 f 是什么，初始值 x 都原封不动地返回。 其定义如下： $$ ZERO := \\lambda f . \\lambda x . x $$ 在 Scheme 中：\n(define ZERO (lambda (f) ; ZERO 接受一个函数 f (lambda (x) ; 并返回一个新的函数，这个新函数接受 x x))) ; 然后直接返回 x (f 应用了0次) 这里的 ZERO 是一个柯里化的函数。它首先接受一个函数 f，然后返回另一个函数。这个内部函数接受初始值 x 并直接返回 x，完美体现了 f 被应用了零次。\n例如，如果我们有一个函数 inc (加一) 和一个值 10： ((ZERO inc) 10)\n(ZERO inc) 会返回 (lambda (x) x) （因为 f 是 inc，但没有被使用）。 然后 ((lambda (x) x) 10) 会返回 10。 这正是我们期望的“对 10 加一 0 次”的结果。 后继函数 (Successor Function, S) 有了 ZERO，我们如何得到其他数字呢？我们需要一个后继函数 (Successor Function)，通常表示为 S。S 接受一个丘奇数 n 作为输入，并返回代表 n+1 的丘奇数。\n如果丘奇数 n 代表“将 f 应用 n 次”，那么 (S n)（即 n+1）就应该代表“将 f 应用 n+1 次”。 这可以这样理解：要将 f 应用 n+1 次到 x 上，我们可以先将 f 应用 n 次到 x 上得到一个中间结果，然后再对这个中间结果额外应用一次 f。\n形式化地，后继函数 S 定义为： $$ S := \\lambda n . \\lambda f . \\lambda x . f ( (n f) x ) $$ 在 Scheme 中：\n(define S (lambda (n) ; S 接受一个丘奇数 n (lambda (f) ; 返回一个新函数 (代表 n+1)，它接受 f (lambda (x) ; 再返回一个新函数，它接受 x (f ; 将 f 应用于... ((n f) x)))))) ; ...n 将 f 应用于 x 的结果 让我们仔细解读一下 S 的定义：\nS 接受一个丘奇数 n (例如 ZERO)。 它返回一个新的函数，这个函数就是代表 n+1 的丘奇数。这个新函数也遵循丘奇数的规范，所以它也期望接受一个函数 f 和一个值 x。 当这个代表 n+1 的函数被 f 和 x 调用时，它的行为是 (f ((n f) x))： (n f): 首先，我们将输入的丘奇数 n 应用于 f。回忆一下，丘奇数 n 本身是 (lambda (f_inner) (lambda (x_inner) ...)) 的形式。所以 (n f) 会返回一个“准备好对某个 x_inner 应用 f_inner（这里是 f）n 次”的函数。 ((n f) x): 接着，我们将上面返回的函数应用于 x。这就完成了 f 在 x 上的 n 次应用。 (f ((n f) x)): 最后，我们将 f 再额外应用一次到 ((n f) x) 的结果上。这就构成了 f 的 n+1 次应用。 这种从 ZERO 和后继函数 S 出发来构造所有自然数的方法，其思想与数学中的皮亚诺公理 (Peano Axioms) 定义自然数的方式高度相似（皮亚诺公理：① 0 是自然数；② 每个自然数 a 都有一个后继数 S(a)；…）。\n现在，我们可以定义其他数字了：\nONE 就是 (S ZERO) TWO 就是 (S ONE)，也就是 (S (S ZERO)) THREE 就是 (S TWO)，也就是 (S (S (S ZERO)))\n等等。 例如，ONE 的展开会是：\n(define ONE (S ZERO)) ;; ONE 展开为： ;; (lambda (f) ;; (lambda (x) ;; (f ((ZERO f) x)))) ;; 由于 ((ZERO f) x) 会返回 x，所以 ONE 进一步简化为： ;; (lambda (f) ;; (lambda (x) ;; (f x))) 这完美符合“将 f 应用一次到 x”的定义。\n同样，TWO 会展开为 (lambda (f) (lambda (x) (f (f x))))，即 f 应用两次。\n通过 ZERO 和 S，我们已经用纯粹的函数构建了整个自然数体系的“骨架”！下一步，我们将探索如何在这些丘奇数上进行算术运算，比如加法和乘法。\n算术运算 (Arithmetic Operations): 加法与乘法 有了代表自然数的丘奇编码，我们自然想在它们之上定义算术运算，比如加法和乘法。\n熟悉皮亚诺公理 (Peano Axioms) 的朋友可能还记得它们是如何递归定义加法和乘法的：\n加法: 对于任意自然数 $m$, $m + 0 = m$ 对于任意自然数 $m$ 和 $n$, $m + S(n) = S(m+n)$ (其中 $S(n)$ 是 $n$ 的后继，即 $n+1$) 乘法: 对于任意自然数 $m$, $m \\times 0 = 0$ 对于任意自然数 $m$ 和 $n$, $m \\times S(n) = (m \\times n) + m$ 直接将这些递归定义转换为纯 λ 演算（尤其是没有显式递归操作符如 Y 组合子的情况下）会有些棘手，特别是处理像 $S(n)$ 这样需要“分解”参数的模式，或者找到一个数的前驱。\n幸运的是，丘奇编码的本质——“将一个函数应用特定次数”——为我们提供了一条更直接、更优雅的路径。\n加法 (Addition): m + n 思考一下加法 m + n 的含义：它可以被看作是从数字 m 开始，连续应用“加一”（即后继函数 S）操作 n 次。\n这完美契合了丘奇数 n 的定义！回忆一下，丘奇数 n 是一个函数 (lambda (f) (lambda (x) ...))，它会将 f 应用到 x 上 n 次。\n我们想要应用的操作是“后继”函数 S。 我们想要应用这个操作的起点是丘奇数 m。 我们想要应用它的次数是 n 次。 所以，m + n 可以通过将丘奇数 n 应用于后继函数 S 和初始值 m 来实现： ((n S) m)\n因此，我们可以定义一个柯里化的加法函数 PLUS (或者叫 ADD)： $$ PLUS := \\lambda m . \\lambda n . ( (n S) m ) $$ 在 Scheme 中：\n(define PLUS (lambda (m) ; PLUS 接受第一个加数 m (lambda (n) ; 返回一个函数，该函数接受第二个加数 n ((n S) m)))) ; 将 S 应用到 m 上 n 次 让我们来验证一下 (PLUS ONE TWO) 是否等于 THREE：\nPLUS 应用于 ONE：(PLUS ONE) 返回 (lambda (n) ((n S) ONE))。 将此结果应用于 TWO：(((lambda (n) ((n S) ONE)) TWO)) 这会进行 β-规约，得到 ((TWO S) ONE)。 现在我们展开 TWO。TWO 是 (lambda (f) (lambda (x) (f (f x))))。 所以 (TWO S) 返回 (lambda (x) (S (S x)))。 最后，((lambda (x) (S (S x))) ONE) 应用于 ONE： 这得到 (S (S ONE))。 根据后继函数的定义，这正是 THREE！ 加法的定义就是如此简洁！它直接利用了丘奇数 n 作为“迭代器”的特性。\n乘法 (Multiplication): m × n 乘法 m × n 又如何用类似的思想表达呢？ 它可以被看作是将“加 m”这个操作，应用 n 次，并且从 ZERO 开始累加。 也就是说： $m \\times n = \\underbrace{m + m + \\dots + m}_{n \\text{ times}}$。\n我们想要重复应用的操作是 “将 m 加到某个数上”。这个操作本身可以用我们刚定义的 PLUS 来表示：(PLUS m)。回忆一下，(PLUS m) 是一个函数，它接受一个参数 k 并返回 m+k (即 ((k S) m))。 我们想要应用这个操作的起点是 ZERO。 我们想要应用它的次数是 n 次。 所以，m × n 可以通过将丘奇数 n 应用于“加 m”这个函数 (PLUS m) 和初始值 ZERO 来实现： ((n (PLUS m)) ZERO)\n因此，柯里化的乘法函数 TIMES (或者叫 MULTIPLY) 定义为： $$ TIMES := \\lambda m . \\lambda n . ( (n (PLUS \\ m)) ZERO ) $$ 在 Scheme 中：\n(define TIMES (lambda (m) ; TIMES 接受第一个乘数 m (lambda (n) ; 返回一个函数，该函数接受第二个乘数 n ((n (PLUS m)) ; 将 (PLUS m) 这个“加m”的函数... ZERO)))) ; ...应用 n 次到 ZERO 上 这里的 (PLUS m) 是一个函数，它等待另一个参数 k 来计算 m+k。丘奇数 n 正好可以将这个“加 m”的函数重复作用。\n例如，思考 (TIMES TWO THREE):\n(TIMES TWO) 返回 (lambda (n) ((n (PLUS TWO)) ZERO))。 将其应用于 THREE： ((THREE (PLUS TWO)) ZERO)。 THREE 会将 (PLUS TWO) 这个函数应用 3 次到 ZERO 上： 第一次：((PLUS TWO) ZERO) 结果是 TWO (0 + 2 = 2) 第二次：((PLUS TWO) TWO) 结果是 FOUR (2 + 2 = 4) (假设我们已经定义了 FOUR) 第三次：((PLUS TWO) FOUR) 结果是 SIX (4 + 2 = 6) (假设我们已经定义了 SIX) 这正是 $2 \\times 3 = 6$。 通过这些定义，我们看到丘奇编码不仅能表示数字，还能以一种非常优雅和本质的方式来定义它们之间的运算，这一切都仅仅建立在函数抽象和应用之上！\n进入更深层次的构造：比较与减法 我们已经成功地用纯函数定义了布尔逻辑、自然数以及基本的加法和乘法运算。这本身已经是一个了不起的成就，展示了 $\\lambda$ 演算惊人的表达能力。现在，我们将继续沿着这条道路前进，构建更复杂的计算工具，首当其冲的是如何比较两个数字，以及如何定义减法。\n正如你可能预料到的，这些操作的定义会比加法和乘法稍微复杂一些，它们需要我们更深入地挖掘丘奇编码的潜力，并引入一些新的辅助函数。\n减法 · 引入 按照四则运算的顺序，接下来我们要构造的就是减法，它是加法的逆运算。\n面对这个问题，你第一时间的想法是什么？很有可能你会想到“前驱函数”（即找到 $n-1$），然后思考“如何从 $n$ 次函数应用中去除一次”。\n这听起来似乎直接，例如通过求反函数。然而，并非所有函数都拥有反函数，且求取反函数本身也相当复杂。我们需要另辟蹊径。\n从“加法的逆运算”这个角度思考 $n-m$：我们是否可以枚举一个数 $k$ (从 $0$ 到 $n$)，检查 $k+m$ 是否等于 $n$？如果相等，则 $k$ 就是 $n-m$ 的值。如果找不到这样的 $k$，则 $n-m$ 在自然数内无解。\n然而，这又引入了一个新问题：我们如何判断两个丘奇数是否“相等”？这是一个我们尚未定义的关键谓词。\n有人可能会说：“如果 $n-m=0$，那么 $n$ 不就等于 $m$ 了吗？”或者“如果 $n \\ge m$ 且 $n \\le m$，那么 $n=m$。” 但这又会使我们陷入对减法或比较运算的循环定义中。\n别担心，我们将逐步解决这些问题。\n判断是否为零 (ZERO?)：一个重要的边界条件 要判断任意两个自然数是否相等，或者进行更复杂的算术运算，我们至少需要能够判断一个数是否为零。这是许多递归定义和条件判断的基础。\n我们可以通过以下方式巧妙地定义 ZERO? 谓词： $$ \\text{ZERO? predicated} := \\lambda n . (n \\ (\\lambda x . \\text{FALSE})) \\ \\text{TRUE} $$ 在 Scheme 中：\n(define ZERO? (lambda (n) ((n (lambda (x) FALSE)) TRUE))) 这个定义的巧妙之处在于它利用了丘奇数自身的特性：\n回忆一下，丘奇数 ZERO 定义为 $ \\lambda f . \\lambda x . x $。\n如果参数 n 是 ZERO，那么 (ZERO (lambda (x) FALSE)) 会忽略掉 (lambda (x) FALSE) 这个函数，直接返回一个恒等函数 $ \\lambda y . y $。\n于是整个表达式 (ZERO? ZERO) 变为 ((lambda (y) y) TRUE)，其结果自然是 TRUE。\n如果参数 n 是一个非零的丘奇数（比如 ONE, TWO, …），它代表将第一个参数（一个函数）应用若干（非零）次。\n那么 (n (lambda (x) FALSE)) 意味着将 (lambda (x) FALSE) 这个“无论输入是什么都返回 FALSE”的函数至少应用一次到某个初始值上。其最终效果是得到一个“总是返回 FALSE”的函数（可以认为是 $ \\lambda y . \\text{FALSE} $）。\n于是整个表达式 (ZERO? n)（当 n 非零时）变为 ((\\lambda y . FALSE) TRUE)，其结果便是 FALSE。\n这样，我们就得到了一个可靠的 ZERO? 测试。\n构造数据结构的基础——丘奇对 (Church Pairs) 在定义更复杂的操作（如前驱函数）之前，我们需要一种方式来将两个值组合成一个单一的复合数据单元。丘奇对 (Church Pairs) 提供了这样的机制，它类似于许多编程语言中的 pair 或二元元组。\n一个丘奇对通过一个高阶函数来表示，这个高阶函数接受一个“选择器”函数作为参数。当我们用两个值 a 和 b 构造一个序对时，这个序对函数会“包裹”住 a 和 b。当它被一个选择器函数 s 调用时，它会将 a 和 b 传递给 s，即执行 (s a b)。\n构造序对的函数 CONS 定义如下： $$ \\text{CONS} := \\lambda a . \\lambda b . \\lambda s . (s \\ a \\ b) $$ 在 Scheme 中：\n(define CONS (lambda (first-element) (lambda (second-element) (lambda (selector-function) (selector-function first-element second-element))))) 要从序对中提取元素，我们需要合适的选择器。丘奇布尔值 TRUE ($\\lambda t . \\lambda f . t$) 和 FALSE ($\\lambda t . \\lambda f . f$) 正好可以胜任：\nCAR (获取第一个元素): $$ \\text{CAR} := \\lambda p . (p \\ \\text{TRUE}) $$ (define CAR (lambda (a-church-pair) (a-church-pair TRUE))) CDR (获取第二个元素): $$ \\text{CDR} := \\lambda p . (p \\ \\text{FALSE}) $$ (define CDR (lambda (a-church-pair) (a-church-pair FALSE))) 丘奇对是构建更复杂数据结构（如列表）和实现某些算法（如下文的前驱函数）的关键。\n前驱函数 (PRED)：寻找 $n-1$ 前驱函数 PRED 的目标是计算 $n-1$。对于丘奇数 ZERO，其前驱仍然是 ZERO (即 $ \\text{PRED ZERO} = \\text{ZERO} $ )。\n直接从丘奇数“减去”一次函数应用是困难的。但我们有一个巧妙的思路：考虑一个序列，例如 $ (0, 0, 1, 2, 3, \\dots) $。如果我们能通过某种方式定位到这个序列的第 $n$ 项（0-indexed），那么这一项的值恰好是 $n$ 的前驱（当 $n=0$ 时为 $0$，当 $n=1$ 时为 $0$，当 $n=2$ 时为 $1$，以此类推）。\n我们不必实际构造一个无穷列表。关键在于定义一个状态转换函数，该函数接受当前状态（一个序对），并返回序列中的下一个状态。丘奇数 $n$ 可以将这个状态转换函数应用 $n$ 次。\n我们将状态表示为一个序对 (current-predecessor-value, flag):\ncurrent-predecessor-value：表示当前计算到的前驱值。 flag：一个状态标记。ZERO 表示这是迭代的初始步骤（对应输入数字 0 或 1 的情况），ONE 表示是后续的常规步骤。 初始状态为 (CONS ZERO ZERO)。 状态转换函数 PHI_PRED_STEP 定义为： $$ \\Phi_{\\text{PRED_STEP}} := \\lambda p . (\\text{ZERO?} \\ (\\text{CDR}\\ p)) \\ (\\text{CONS}\\ \\text{ZERO}\\ \\text{ONE}) \\ (\\text{CONS}\\ (\\text{S}\\ (\\text{CAR}\\ p))\\ \\text{ONE}) $$ 在 Scheme 中：\n(define PHI_PRED_STEP (lambda (p) ; p 是形如 (current-predecessor-value, flag) 的序对 ((ZERO? (CDR p)) ; 检查 flag 是否为 ZERO (CONS ZERO ONE) ; 如果是，下一个状态是 (ZERO, ONE) (CONS (S (CAR p)) ONE)))) ; 否则，下一个状态是 (S current-predecessor-value, ONE) 这个转换逻辑是：\n如果 flag 是 ZERO（初始状态，意味着我们正在处理输入为 ZERO 或 ONE 的情况的“第一步迭代”）：下一个状态的 current-predecessor-value 保持 ZERO，并将 flag 置为 ONE。 如果 flag 是 ONE（后续状态）：下一个状态的 current-predecessor-value 是前一个值的后继 (S (CAR p))，flag 保持 ONE。 有了初始状态和转换函数，PRED n 就是将 PHI_PRED_STEP 应用 $n$ 次到初始状态 (CONS ZERO ZERO) 上，然后取结果序对的第一个元素： $$ \\text{PRED} := \\lambda n . \\text{CAR} \\ (n \\ \\Phi_{\\text{PRED_STEP}} \\ (\\text{CONS ZERO ZERO})) $$ 在 Scheme 中：\n(define PRED (lambda (n) (CAR ((n PHI_PRED_STEP) (CONS ZERO ZERO))))) 让我们验证一下：\n(PRED ZERO): PHI_PRED_STEP 应用 0 次，结果是 (CAR (CONS ZERO ZERO)) 即 ZERO。 (PRED ONE): 初始状态 p0 = (CONS ZERO ZERO)。 应用一次 PHI_PRED_STEP: (PHI_PRED_STEP p0)。因为 (CDR p0) 是 ZERO，所以结果是 p1 = (CONS ZERO ONE)。 (CAR p1) 是 ZERO。所以 (PRED ONE) 是 ZERO。 (PRED TWO): p0 = (CONS ZERO ZERO)。 第一次应用得到 p1 = (CONS ZERO ONE)。 第二次应用 (PHI_PRED_STEP p1)。因为 (CDR p1) 是 ONE (非 ZERO)，所以结果是 p2 = (CONS (S (CAR p1)) ONE) = (CONS (S ZERO) ONE) = (CONS ONE ONE)。 (CAR p2) 是 ONE。所以 (PRED TWO) 是 ONE。 这完美地实现了前驱函数的功能。\n减法 · 截断减法 (SUB) 有了前驱函数 PRED，定义减法就变得直接了。我们要实现的是截断减法 (Truncating Subtraction)，即 $m-n$。如果 $m \\ge n$，结果是 $m-n$；如果 $m \u003c n$，结果是 $0$（因为我们只处理自然数）。\n$m-n$ 可以看作是对 $m$ 重复应用 PRED 函数 $n$ 次。 $$ \\text{SUB} := \\lambda m . \\lambda n . (n \\ \\text{PRED} \\ m) $$ 在 Scheme 中：\n(define SUB (lambda (m) (lambda (n) ((n PRED) m)))) ; 计算 m - n 例如 (SUB FIVE TWO) 会将 PRED 应用 2 次到 FIVE 上，得到 THREE。而 (SUB TWO FIVE) 会得到 ZERO。\n关系运算符 基于 SUB 和 ZERO?，我们可以构建各种关系运算符：\n小于或等于 (IS_LEQ?): $m \\le n$ 当且仅当 $m-n = 0$ (在截断减法中)。 $$ \\text{IS_LEQ?} := \\lambda m . \\lambda n . \\text{ZERO?} \\ (\\text{SUB}\\ m \\ n) $$\n(define IS_LEQ? (lambda (m) (lambda (n) (ZERO? (SUB m n))))) 大于 (IS_GT?): $m \u003e n$ 当且仅当 $m-n \\neq 0$ (且 $m-n \u003e 0$)，也即 $m \\not\\le n$。 $$ \\text{IS_GT?} := \\lambda m . \\lambda n . \\text{NOT} \\ (\\text{IS_LEQ?}\\ m \\ n) $$ 或者，更直接地：$m \u003e n$ 当且仅当 $m-n$ 的结果不是 $ZERO$ (在我们的自然数和截断减法定义下，这意味着 $m-n$ 是一个正数)。 $$ \\text{IS_GT?}{\\text{alt}} := \\lambda m . \\lambda n . \\text{NOT} \\ (\\text{ZERO?} \\ (\\text{SUB}\\ m \\ n)) $$ *(注：使用 $\\text{IS_GT?}{\\text{alt}}$ 定义，则 $m\u003en$ 为真。若 $m \\le n$, $\\text{SUB}\\ m\\ n$ 为 $\\text{ZERO}$, $ZERO?$ 为 $\\text{TRUE}$, $\\text{NOT}$ 为 $\\text{FALSE}$)*\n等于 (IS_EQ?): $m = n$ 当且仅当 $m \\le n$ 并且 $n \\le m$。 $$ \\text{IS_EQ?} := \\lambda m . \\lambda n . \\text{AND} \\ (\\text{IS_LEQ?}\\ m \\ n) \\ (\\text{IS_LEQ?}\\ n \\ m) $$\n(define IS_EQ? (lambda (m) (lambda (n) (AND (IS_LEQ? m n) (IS_LEQ? n m))))) 另一种思路是：$m=n$ 当且仅当 $m-n=0$ 且 $n-m=0$。所以 $(\\text{SUB } m n)$ 和 $(\\text{SUB } n m)$ 都必须是 ZERO。\n小于 (IS_LT?): $m \u003c n$ 当且仅当 $n \u003e m$。 $$ \\text{IS_LT?} := \\lambda m . \\lambda n . \\text{IS_GT?}\\ n \\ m $$ 或者 $m \u003c n$ 当且仅当 $m \\not\\ge n$ (即 $\\neg(n \\le m)$)。 $$ \\text{IS_LT?}_{\\text{alt}} := \\lambda m . \\lambda n . \\text{NOT} \\ (\\text{IS_LEQ?}\\ n \\ m) $$\n大于或等于 (IS_GEQ?): $m \\ge n$ 当且仅当 $n \\le m$。 $$ \\text{IS_GEQ?} := \\lambda m . \\lambda n . \\text{IS_LEQ?}\\ n \\ m $$\n通过这些定义，我们已经构建了一套完整的基于丘奇编码的自然数关系运算。\n一点关于时间复杂度分析与计算模型的声明 我们发现，刚刚实现的算术运算（尤其是乘法、前驱、减法）的过程，如果完全展开成 $\\beta$-规约，其步骤数会相当可观，效率较低。但是，$\\lambda$ 演算主要是一个用于研究计算理论、证明计算完备性的数学工具，其直接实现的效率并非首要考量。在实际编程中，我们当然会使用硬件直接支持的、高度优化的原生数字类型和运算。\n如果追求“高效的算术”，我们可以探索例如二进制表示的丘奇数。不过，这会引入显著的复杂性，超出了本文旨在演示如何用 $\\lambda$ 演算构建一个完备计算体系的目标。\n与此相对，我们将采取另一种视角。正如我们在前文“一层又一层抽象”中所讨论的，为了能够清晰地构建和分析更复杂的算法，我们将把这些已经定义的丘奇编码实体（如 ZERO, PLUS, IF-THEN-ELSE, PRED, SUB, IS_LEQ? 等）视为我们新的抽象原语 (abstract primitives)。\n在后续的算法讨论和复杂度分析中，除非特别指出，我们将假设对这些抽象原语的一次调用（例如，执行一次 (PLUS church_num1 church_num2) 或一次 (IS_LEQ? church_num1 church_num2))) 构成一个基本计算步骤，其开销计为常数时间 $O(1)$（或者说，我们统计的是这些高级原语被调用的次数）。\n这样做使我们能够专注于算法本身的逻辑和结构，而不必每次都回溯到底层的 $\\lambda$-规约。这与我们在高级编程语言中分析算法时，将整数加法或比较视为 $O(1)$ 操作的做法是相通的。\n我们还缺乏一种重要的算术运算：除法。但是它的实现比较复杂，需要一些额外的工具。在下一节中，我们将引入这些必要的工具。\n递归：让函数调用自身 到目前为止，我们已经用 λ 演算构建了布尔逻辑、自然数、算术运算乃至简单的数据结构（丘奇对）。然而，你可能已经敏锐地注意到，我们似乎还缺少一个在编程中至关重要的工具：循环或迭代。我们用丘奇数 n 实现了将某个操作重复 n 次，但这更像是一个固定次数的 for 循环。对于更一般的情况，比如“当条件满足时重复执行某个操作”（类似 while 循环），或者像阶乘那样需要根据输入值决定计算深度的场景，我们目前的工具还不够。\n在大多数编程语言中，这类重复性的任务通常通过递归（函数调用自身）或循环结构（for, while）来解决。循环结构本质上也可以看作是递归的一种特定模式或语法糖。因此，关键在于如何在 λ 演算这个纯粹的函数世界中实现递归。\n让我们先看看在 Scheme 中，递归是如何轻易实现的。比如，计算阶乘的函数：\n(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1))))) (factorial 5) ; 计算结果为 120 在这里，define 允许我们将函数命名为 factorial，然后在 factorial 的函数体内部，我们可以再次通过这个名字 factorial 来调用它自身。\n但问题来了：在纯粹的 λ 演算中，函数通常是匿名的。回忆一下，我们定义的 TRUE、ZERO、PLUS 等都是 (lambda (...) ...) 这样的匿名函数，只是为了方便讨论，我们才用 define 给它们起了名字。如果一个函数没有名字，它如何在自己的定义中引用自己呢？这就好比写一封匿名信，却想在信的内容里提及“写这封信的我”——我们该如何指代这个匿名的“我”？\n这正是 λ 演算实现递归所面临的核心挑战。我们需要一种方法，让一个匿名函数能够获得对自身的引用。\n“手动”实现递归：将函数作为参数传递 一种直观的想法是：如果一个函数 g 需要调用自身，我们可以修改 g 的定义，让它多接受一个参数，这个参数就是 g 自身（或者一个行为与 g 等同的函数）。 让我们尝试为一个“准阶乘函数”almost-factorial 这样做。这个 almost-factorial 期望接收一个 self 参数（代表它自己）和一个数字 n：\n(define almost-factorial (lambda (self n) ; self 是期望中的递归调用 (if (= n 0) 1 (* n (self self (- n 1)))))) ; 注意这里：用 (self self ...) 来进行递归调用 要使用它，我们需要某种方式把 almost-factorial 这个函数本身传递给它自己的第一个参数 self：\n(almost-factorial almost-factorial 5) ; 结果是 120 这种模式 (f f x) 有一个专门的名字，叫做 U 组合子（或模拟 U 组合子的行为），即 U f = f f。我们通过 (almost-factorial almost-factorial ...) 使得 almost-factorial 的第一个参数 self 确实是 almost-factorial 本身。在 almost-factorial 内部，当它需要递归调用时，它就调用 (self self (- n 1))，这实际上又变回了 (almost-factorial almost-factorial (- n 1))，递归得以实现！\n这种“将函数自身作为参数传递给自身”的技巧虽然可行，但每次调用时都需要重复写 (f f x) 这样的结构，显得有些笨拙。我们更希望有一个“魔法函数”，能够自动帮我们处理这种“自我引用”的传递。\n不动点组合子：Y 组合子与 Z 组合子 这个“魔法函数”就是不动点组合子 (Fixed-Point Combinator)。在数学中，函数 f 的一个不动点 x 是指满足 f(x) = x 的点。在计算理论中，递归函数可以被看作是某个高阶函数的不动点。\n假设我们有一个函数生成器 G。G 接受一个函数 h（代表递归调用）作为参数，并返回一个新的函数，这个新函数就是我们想要定义的递归函数的“单步版本”。例如，对于阶乘，G 可以这样定义（这里暂时借用 Scheme 的数字和运算以便理解）：\n(define G-factorial (lambda (h) ; h 是用于递归调用的函数 (即阶乘函数本身) (lambda (n) ; 返回的是阶乘函数的一步 (if (= n 0) 1 (* n (h (- n 1))))))) ; 这里用 h 来进行递归调用 我们希望找到一个函数 factorial，使得 factorial 等价于 (G-factorial factorial)。也就是说，factorial 是 G-factorial 这个高阶函数的不动点。\nY 组合子正是这样一个神奇的函数，它能为任何给定的函数生成器 G 找到其不动点。即 (Y G) 会产生一个函数 f_rec，这个 f_rec 满足 f_rec = (G f_rec)。 Y 组合子的经典定义是： $$ Y := \\lambda g . (\\lambda x . g (x \\ x)) (\\lambda x . g (x \\ x)) $$ 在 Scheme 中表示为：\n(define Y (lambda (g) ((lambda (x) (g (x x))) (lambda (x) (g (x x)))))) 于是， (Y G-factorial) 就会是上面我们用 define 直接定义的那个 factorial 函数！我们不再需要在调用时手动传递 factorial 给自身了，Y 组合子帮我们完成了这个绑定。\n补充：Y 组合子如何工作：不动点属性的推导\nY 组合子的神奇之处在于它如何构造出这个不动点。让我们手动展开 (Y G) 的求值过程（使用 β-规约）来看看它是如何工作的。\n回顾 Y 组合子的定义：\n(define Y (lambda (g) ((lambda (x) (g (x x))) ; 我们将这个内部的 (lambda (x) ...) 称为 omega-maker (lambda (x) (g (x x)))))) ; 这是传递给 omega-maker 的参数，形式与 omega-maker 自身相同 为了方便推导，我们定义一个辅助函数 omega_g (或者叫 make-omega-for-g)，它依赖于 g： omega_g := (lambda (x) (g (x x)))\n那么，Y 组合子可以看作是： Y := (lambda (g) (omega_g omega_g))\n现在，我们将 Y 应用于我们的函数生成器 G： (Y G) 根据 Y 的定义，这会进行一次 β-规约，将 G 替换掉 Y 定义中的 g： (Y G) evaluates-to (omega_G omega_G) 这里 omega_G 就是 (lambda (x) (G (x x))) (即把 g 换成了具体的 G)。\n接下来，我们来看 (omega_G omega_G) 是什么： (omega_G omega_G) = ((lambda (x) (G (x x))) omega_G) (将第一个 omega_G 展开)\n现在，我们再次进行 β-规约：将 omega_G 这个实际参数替换掉 (lambda (x) ...) 中的形式参数 x。 ((lambda (x) (G (x x))) omega_G) evaluates-to (G (omega_G omega_G))\n我们得到了：\n(Y G) = (omega_G omega_G) (omega_G omega_G) = (G (omega_G omega_G)) 综合这两步，我们可以通过代换得到： (Y G) = (G (omega_G omega_G))\n现在，注意到等式右边的 (omega_G omega_G) 正是我们在第一步中定义的 (Y G)！ 所以，我们可以将 (Y G) 代换回去： (Y G) = (G (Y G))\n这正是我们期望的不动点属性！ (Y G) 这个表达式本身（我们称之为 f_rec）等于将 G 应用于 (Y G)（即 (G f_rec)）。Y 组合子通过这种巧妙的自我应用结构，成功地为一个“期望接收自身作为参数”的函数生成器 G 创造了一个可以直接调用的递归函数 (Y G)，而这个递归函数 (Y G) 确实是 G 的不动点。\n这就是为什么 Y 组合子能够在纯 λ 演算中实现递归的魔力所在。它构建了一个表达式，该表达式在求值时会“展开”成将生成器 G 应用于该表达式自身的形式。\n然而，Y 组合子的这个经典定义在严格求值/应用序求值（Applicative Order Evaluation，即函数参数在函数体执行前就被完全求值）的语言（如 Scheme）中直接使用时会遇到问题：(x x) 这一部分会导致无限递归求值，从而使程序无法终止。\n为了解决这个问题，在应用序求值语言中，我们通常使用 Z 组合子，它是 Y 组合子的一个变体，通过引入一个额外的 lambda 来延迟 (x x) 的求值： $$ Z := \\lambda g . (\\lambda x . g (\\lambda v . ((x \\ x) v))) (\\lambda x . g (\\lambda v . ((x \\ x) v))) $$ 在 Scheme 中：\n(define Z (lambda (g) ((lambda (x) (g (lambda (v) ((x x) v)))) (lambda (x) (g (lambda (v) ((x x) v))))))) 现在，我们可以用 Z 组合子和我们之前定义的 G-factorial 来构造阶乘函数：\n(define factorial-via-Z (Z G-factorial)) (factorial-via-Z 5) ; 计算结果为 120 这里，factorial-via-Z 就是一个完全由 λ 演算（加上 Z 组合子）构造出来的递归阶乘函数。在纯 λ 演算的语境下，G-factorial 中的 if、=、0、1、*、- 当然也需要用我们之前讨论过的丘奇编码来定义。\n不动点组合子（如 Y 或 Z）是 λ 演算中一个深刻而强大的概念。它们揭示了即使在这样一个极简的系统中，我们也能通过纯粹的函数抽象和应用来构建出递归这一复杂的控制结构。这为 λ 演算的图灵完备性提供了关键的一环，也意味着我们几乎拥有了构建任何可计算过程所需的所有理论工具。\n有了递归，我们的 λ 演算工具箱才算真正强大起来，能够去定义和执行那些需要自我参照和重复计算的复杂算法了。\n我们很快就会看到它们的威力。在下一节中，我们将应用它们来构造之前我们暂时搁置的算术逻辑：除法。\n更进一步的算术：除法 (DIV) 在构建了加法、减法和乘法之后，自然会想到四则运算的最后一个基本操作：除法。我们将在这里实现整数除法，即计算 $m \\div n$ 的商 $q$。\n与加法和乘法不同，除法的计算过程（重复从被除数中减去约数，直到余数小于约数）通常不依赖于一个固定的、由输入数字直接决定的迭代次数。这暗示了我们需要使用递归来实现它。\n除法的核心逻辑：重复减法与递归 整数除法 $m \\div n$ 的商 $q$ 可以通过以下递归过程找到：\n基本情况：如果 $m \u003c n$，那么我们无法再从中减去 $n$ 了，此时累积的商就是最终结果。 递归步骤：如果 $m \\ge n$，那么我们可以从 $m$ 中减去一个 $n$，然后对新的 $m’ = m-n$ 和原始的 $n$ 再次进行除法过程，同时将累积的商加一。 我们需要一个辅助的递归函数，它会跟踪当前的被除数、原始的除数以及到目前为止累积的商。\n构造除法的递归辅助函数生成器 (G_DIV_LOOP) 让我们定义一个函数生成器 G_DIV_LOOP。它接受一个参数 self_div_loop（代表递归调用自身），并返回一个执行单步除法逻辑的函数。这个单步函数接受三个参数：\ncurrent_m：当前的被除数。 original_n：原始的（保持不变的）除数。 current_q：到目前为止累积的商。 $$ \\begin{aligned} \\text{G_DIV_LOOP} := \\lambda \\text{self_div_loop} . \\lambda \\text{current_m} . \\lambda \\text{original_n} . \\lambda \\text{current_q} . \\ \\quad (\\text{IS_LT?} \\ \\text{current_m} \\ \\text{original_n}) \\ \\quad \\quad \\text{current_q} \\ \\quad \\quad (\\text{self_div_loop} \\ (\\text{SUB} \\ \\text{current_m} \\ \\text{original_n}) \\ \\text{original_n} \\ (\\text{S} \\ \\text{current_q})) \\end{aligned} $$ 在 Scheme 中（使用我们之前定义的 IF-THEN-ELSE 的等价结构，即丘奇布尔值直接作为选择器）：\n(define G_DIV_LOOP (lambda (self_div_loop) (lambda (current_m) (lambda (original_n) (lambda (current_q) ((IS_LT? current_m original_n) ; If current_m \u003c original_n current_q ; Then: return current_q (self_div_loop (SUB current_m original_n) ; Else: recurse original_n (S current_q)))))))) 这里我们使用了之前定义的 IS_LT? (小于)，SUB (截断减法)，和 S (后继函数)。\n使用 Z 组合子实现递归循环 现在，我们可以使用 Z 组合子来从 G_DIV_LOOP 生成实际的递归辅助函数 DIV_LOOP： $$ \\text{DIV_LOOP} := \\text{Z} \\ \\text{G_DIV_LOOP} $$\n(define DIV_LOOP (Z G_DIV_LOOP)) DIV_LOOP 现在是一个柯里化的函数，它接受 current_m、original_n 和 current_q，并递归地计算直到 current_m \u003c original_n。\n定义主除法函数 DIV 主除法函数 DIV 将接受两个参数：被除数 m 和除数 n。它会调用 DIV_LOOP，并将初始商设为 ZERO。 $$ \\text{DIV} := \\lambda m . \\lambda n . (\\text{DIV_LOOP} \\ m \\ n \\ \\text{ZERO}) $$ 在 Scheme 中：\n(define DIV (lambda (m) (lambda (n) (DIV_LOOP m n ZERO)))) 注意： 此定义假设除数 n 不为 ZERO。如果 n 是 ZERO (且 m 非 ZERO)， (IS_LT? current_m ZERO) 永远为假，而 (SUB current_m ZERO) 结果仍是 current_m，这将导致无限递归（不终止）。\n示例 让我们尝试计算 (DIV SIX TWO)（假设 SIX 是丘奇数 6，TWO 是丘奇数 2）：\n(DIV_LOOP SIX TWO ZERO) IS_LT? SIX TWO 为 FALSE。 递归调用 (DIV_LOOP (SUB SIX TWO) TWO (S ZERO)) 即 (DIV_LOOP FOUR TWO ONE)。 (DIV_LOOP FOUR TWO ONE) IS_LT? FOUR TWO 为 FALSE。 递归调用 (DIV_LOOP (SUB FOUR TWO) TWO (S ONE)) 即 (DIV_LOOP TWO TWO TWO)。 (DIV_LOOP TWO TWO TWO) IS_LT? TWO TWO 为 FALSE (因为 TWO 不小于 TWO)。 递归调用 (DIV_LOOP (SUB TWO TWO) TWO (S TWO)) 即 (DIV_LOOP ZERO TWO THREE)。 (DIV_LOOP ZERO TWO THREE) IS_LT? ZERO TWO 为 TRUE。 返回当前的商 THREE。 因此，(DIV SIX TWO) 的结果是 THREE，这符合预期。\n同样，(DIV SEVEN THREE) 会返回 TWO。\n获取余数 (Remainder) (可选扩展) 上面的 DIV 函数只返回商。如果我们也想得到余数，该怎么办呢？ 余数其实就是在递归的基本情况下（即当 current_m \u003c original_n 时）的 current_m 的值。\n我们可以修改 G_DIV_LOOP，使其返回一个包含商和余数的丘奇对 (CONS quotient remainder)。\n$$ \\begin{aligned} \\text{G_DIV_REM_LOOP} := \\lambda \\text{self_div_loop} . \\lambda \\text{current_m} . \\lambda \\text{original_n} . \\lambda \\text{current_q} . \\ \\quad (\\text{IS_LT?} \\ \\text{current_m} \\ \\text{original_n}) \\ \\quad \\quad (\\text{CONS} \\ \\text{current_q} \\ \\text{current_m}) \\ \\quad \\quad (\\text{self_div_loop} \\ (\\text{SUB} \\ \\text{current_m} \\ \\text{original_n}) \\ \\text{original_n} \\ (\\text{S} \\ \\text{current_q})) \\end{aligned} $$\n(define G_DIV_REM_LOOP (lambda (self_div_loop) (lambda (current_m) (lambda (original_n) (lambda (current_q) ((IS_LT? current_m original_n) (CONS current_q current_m) ; 返回 (商, 余数) (self_div_loop (SUB current_m original_n) original_n (S current_q)))))))) (define DIV_REM_LOOP (Z G_DIV_REM_LOOP)) (define DIV_AND_REMAINDER (lambda (m) (lambda (n) (DIV_REM_LOOP m n ZERO)))) 然后，我们可以定义分别获取商和余数的函数： $$ \\text{QUOTIENT} := \\lambda m . \\lambda n . \\text{CAR} \\ (\\text{DIV_AND_REMAINDER} \\ m \\ n) $$ $$ \\text{REMAINDER} := \\lambda m . \\lambda n . \\text{CDR} \\ (\\text{DIV_AND_REMAINDER} \\ m \\ n) $$\n(define QUOTIENT (lambda (m) (lambda (n) (CAR (DIV_AND_REMAINDER m n))))) (define REMAINDER (lambda (m) (lambda (n) (CDR (DIV_AND_REMAINDER m n))))) 例如，(DIV_AND_REMAINDER SEVEN THREE) 会返回一个序对，其中 CAR 是 TWO (商)，CDR 是 ONE (余数)。\n通过这种方式，我们利用递归和之前构建的算术及逻辑原语，成功地扩展了我们的 $\\lambda$ 演算计算体系，使其包含了基本的除法运算。这进一步展示了该计算模型的图灵完备性。\n结语 在上文中，我们已经成功地用 λ 演算构建了基本的计算逻辑、自然数算术以及强大的递归机制。这为我们打开了通往更广阔计算世界的大门。\n在实际的编程中，除了原始的数据类型和运算，我们还需要各种数据结构来有效地组织和管理信息，例如链表、栈、队列、树、图、哈希表等等。没有这些，许多复杂的算法都将无从谈起。\n利用我们已经掌握的丘奇对 (可以看作是构造其他数据结构的基础单元) 和递归思想，我们完全有能力在纯 λ 演算的框架内逐步构建出这些复杂的数据结构。\n例如，链表 (Linked List) 作为最基础也最常用的数据结构之一，它与 λ 演算的递归特性天然契合。我们可以设想用嵌套的丘奇对来表示链表节点，其中每个节点包含一个数据元素和一个指向下一个节点的“指针”（即另一个链表或代表列表末尾的特殊值）。\n(define MY-NIL (lambda (f) (lambda (x) x))) ; 例如，用 ZERO 或一个特定的选择函数代表空列表 (define MY-CONS CONS) ; 丘奇对就是我们的 cons (define MY-CAR CAR) (define MY-CDR CDR) ; 一个包含 1, 2, 3 的列表可以表示为： ; (MY-CONS ONE (MY-CONS TWO (MY-CONS THREE MY-NIL))) 对这些数据结构的操作（如插入、删除、查找、遍历）也都可以通过定义相应的 λ 函数来实现，这些函数通常会利用递归来处理链表的递归定义。\n由于篇幅和精力的限制，本文不再详细展开这些数据结构的具体实现。但我们强烈鼓励充满好奇心的读者，以本文介绍的原理和方法为基础，亲自动手尝试去构建它们。这将会是一段极具启发性和挑战性的旅程，能让你更深刻地理解计算的构造性和 λ 演算的强大威力。\n同样，对于数系的扩展，例如从自然数到整数（如何表示负数？）、再到有理数（如何表示分数并进行运算？），甚至是实数的某些计算特性，也都是值得探索的领域。\n希望本文能为你打开一扇窗，让你窥见计算世界最纯粹、最本源的构造之美。\n","wordCount":"3893","inLanguage":"en","datePublished":"2025-10-13T14:57:18+08:00","dateModified":"2025-10-13T14:57:18+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/lets-build-our-mathematics-by-using-lambda-calculus--church-encoding/"},"publisher":{"@type":"Organization","name":"litjohn's blog","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="litjohn's blog (Alt + H)">litjohn's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Let's Build Our Mathematics by Using Lambda Calculus && Church Encoding!</h1><div class=post-meta><span title='2025-10-13 14:57:18 +0800 +0800'>October 13, 2025</span></div></header><div class=post-content><h3 id=致谢>致谢<a hidden class=anchor aria-hidden=true href=#致谢>#</a></h3><p>Gemini 2.5 Pro 0325 && 0506：文本润色、事实正确性审查，以及帮助我学习、理解和回忆这些内容。</p><p><a href=https://www.luogu.com.cn/user/528472>myster1ous</a>： 给予我巨大的启发，帮助我构建出 prev 函数。</p><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>本文是光剑系列的第一作，又名《lambda 演算，邱奇编码与优雅的计算模型》。</p><p>本文的目的是带领大家踏上一段奇妙的旅程：我们将使用 λ 演算（Lambda Calculus）这一极简的计算模型，并通过丘奇编码（Church Encoding）这一巧妙的技术，一步步构建出我们日常编程中熟悉和依赖的计算体系，例如数字、布尔逻辑乃至更复杂的数据结构。</p><p>为了方便演示和实践，本文中的所有代码示例都将使用 Scheme 语言。Scheme 是 Lisp 家族的一员，它的语法是 <strong>S-表达式 (Symbolic Expressions)</strong>。S-表达式不仅简洁优雅，而且其结构与 λ 演算的表达方式惊人地契合。</p><p>在我们开始之前，让我们先快速了解一下 S-表达式：</p><ul><li><strong>核心是列表 (List)：</strong> S-表达式的基本形式是由圆括号 <code>()</code> 包围起来的列表。</li><li><strong>结构：<code>(操作符 参数1 参数2 ...)</code>：</strong> 列表中的第一个元素通常是<strong>操作符</strong>（即要应用的函数），其余元素则是传递给该操作符的<strong>参数</strong>。</li><li><strong>原子 (Atom) 与嵌套：</strong> 列表中的元素可以是<strong>原子</strong>（如数字 <code>123</code>、符号 <code>x</code>、<code>+</code>），也可以是另一个 S-表达式。这种嵌套能力使得 S-表达式可以表示复杂的树状结构。</li></ul><p>例如，表达式 <code>(+ 1 (* 2 3))</code> 在 Scheme 中表示数学上的 <code>1 + (2 * 3)</code>。
这里：</p><ol><li>最外层的 <code>(+ 1 (* 2 3))</code> 是一个 S-表达式。<code>+</code> 是操作符，<code>1</code> 和 <code>(* 2 3)</code> 是它的参数。</li><li><code>(* 2 3)</code> 本身也是一个 S-表达式。<code>*</code> 是操作符，<code>2</code> 和 <code>3</code> 是它的参数。执行它会得到 <code>6</code>。</li><li>所以整个表达式 <code>(+ 1 6)</code> 最终会计算得到 <code>7</code>。</li></ol><p>理解了 S-表达式，我们就可以更顺畅地进入 λ 演算的世界了。</p><h2 id=λ-演算计算的本质>λ 演算：计算的本质<a hidden class=anchor aria-hidden=true href=#λ-演算计算的本质>#</a></h2><p>λ 演算（Lambda Calculus）由阿隆佐·丘奇在 20 世纪 30 年代提出，它是一个极其简洁却具有图灵完备计算能力的数学形式系统。这意味着任何可计算的函数都可以用 λ 演算来表达和计算。</p><p>λ 演算的核心要素出奇地少，主要包括：</p><ol><li><strong>变量 (Variables):</strong> 如 <code>x</code>, <code>y</code>, <code>f</code> 等，用作参数名或函数本身的占位符。</li><li><strong>函数抽象 (Function Abstraction):</strong> 这是定义一个新（通常是匿名的）函数的过程。</li><li><strong>函数应用 (Function Application):</strong> 这是将一个函数作用于其参数（即调用函数）的过程。</li></ol><p>让我们逐一来看。</p><h3 id=1-函数抽象-定义函数>1. 函数抽象 (定义函数)<a hidden class=anchor aria-hidden=true href=#1-函数抽象-定义函数>#</a></h3><p>在传统的数学或 λ 演算表示法中，一个接受参数 <code>x</code> 并返回表达式 <code>E</code> 的函数可以写为 $\lambda x.E$。
在 Scheme (以及本文的 S-表达式) 中，我们这样表示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(lambda (x) E)
</span></span></code></pre></div><p>这里的 <code>lambda</code> 是一个特殊的关键字，表示我们正在定义一个匿名函数。<code>(x)</code> 是参数列表（这里只有一个参数 <code>x</code>），而 <code>E</code> 是函数体，代表函数要执行的计算并返回的结果。</p><p>例如，一个接受参数 <code>x</code> 并简单返回 <code>x</code> 本身的函数 (称为恒等函数)：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(lambda (x) x)
</span></span></code></pre></div><p>这是一个非常基础但重要的函数。</p><p>再举一个例子，一个接受参数 <code>x</code> 并期望返回 <code>x+1</code> 的函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(lambda (x) (<span style=color:#a6e22e>+</span> x <span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><p><strong>请注意：</strong> 在这个例子中，我们暂时借用了 Scheme 中预定义的 <code>+</code> 操作符和数字 <code>1</code>。这有助于我们直观地理解函数定义。然而，在纯粹的 λ 演算中，并不存在预定义的数字或算术运算符。一切——包括数字、布尔值和运算——都需要从最基本的函数抽象和应用来构建。这正是我们稍后将通过“丘奇编码”来实现的迷人之处！现在，请将注意力集中在 <code>lambda</code> 如何定义一个接受输入、进行处理、然后输出结果的“黑盒子”。</p><p>这些用 <code>lambda</code> 定义的函数都是<strong>匿名函数</strong>，它们没有名字。</p><h3 id=2-函数应用-调用函数>2. 函数应用 (调用函数)<a hidden class=anchor aria-hidden=true href=#2-函数应用-调用函数>#</a></h3><p>定义了函数，我们自然需要调用它。在传统表示法中，将函数 $f$ 应用于参数 $a$ 通常写作 $f(a)$ 或 $f;a$。
在 S-表达式中，函数应用的形式非常统一：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(f a)
</span></span></code></pre></div><p>其中 <code>f</code> 是要应用的函数，<code>a</code> 是传递给函数的参数。</p><p>如果我们想直接应用一个匿名函数，可以这样做：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>((lambda (x) (<span style=color:#a6e22e>+</span> x <span style=color:#ae81ff>1</span>)) <span style=color:#ae81ff>5</span>)
</span></span></code></pre></div><p>这个表达式的含义是：将匿名函数 <code>(lambda (x) (+ x 1))</code> 应用于参数 <code>5</code>。计算过程（我们稍后会详细讨论其规则）会得到 <code>6</code>。</p><p>虽然纯粹的 λ 演算主要处理匿名函数，但在像 Scheme 这样的编程语言中，为了代码的清晰和可重用性，我们通常会给函数命名。这可以通过 <code>define</code> 实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define inc (lambda (x) (<span style=color:#a6e22e>+</span> x <span style=color:#ae81ff>1</span>)))
</span></span></code></pre></div><p>这里，我们将前面定义的“加一”函数命名为 <code>inc</code>。现在，我们可以通过名字来调用它：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(inc <span style=color:#ae81ff>5</span>) <span style=color:#75715e>; 这将返回 6</span>
</span></span><span style=display:flex><span>(inc <span style=color:#ae81ff>10</span>) <span style=color:#75715e>; 这将返回 11</span>
</span></span></code></pre></div><p>需要强调的是，<code>define</code> 并不是 λ 演算本身的一部分，它是 Scheme 提供的用于绑定名称到值的便利工具。在 λ 演算的理论探讨中，我们更多关注匿名函数及其组合。</p><h3 id=3-万物皆函数λ-演算的核心思想>3. 万物皆函数：λ 演算的核心思想<a hidden class=anchor aria-hidden=true href=#3-万物皆函数λ-演算的核心思想>#</a></h3><p>λ 演算最令人着迷的一点或许是它的极简主义哲学：<strong>在纯粹的 λ 演算中，一切皆是函数。</strong> 我们通常认为理所当然存在的数字 (0, 1, 2&mldr;)、布尔值 (真/假)、条件判断 (if-then-else)、数据结构 (如列表) 等等，在 λ 演算的宇宙中，都是通过巧妙地组合和嵌套函数来表达的。</p><p>这意味着，理论上我们只需要“定义函数”和“应用函数”这两个基本操作，就能构建出整个可计算的世界。这听起来可能有些抽象和不可思议，但别担心，本文的后半部分将通过<strong>丘奇编码</strong>来具体展示如何用函数来表示数字和布尔值，并在此基础上进行运算。</p><h3 id=λ-演算的运算法则>λ 演算的运算法则<a hidden class=anchor aria-hidden=true href=#λ-演算的运算法则>#</a></h3><p>λ 演算有几条基本的变换规则，它们定义了表达式如何被“计算”或“简化”。最重要的规则有：</p><h4 id=a-α-变换-alpha-conversion--α-renaming>a. α-变换 (Alpha Conversion / α-renaming)<a hidden class=anchor aria-hidden=true href=#a-α-变换-alpha-conversion--α-renaming>#</a></h4><p>α-变换指的是，在不改变函数行为的前提下，可以对函数定义中的绑定变量（即参数名）进行重命名。</p><p>例如，以下两个函数定义是完全等价的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(lambda (x) (<span style=color:#a6e22e>+</span> x <span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><p>和</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(lambda (y) (<span style=color:#a6e22e>+</span> y <span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><p>（用传统符号表示即 $\lambda x.x+1$ 等价于 $\lambda y.y+1$）</p><p>只要新的参数名不与函数体内的自由变量（即那些不是由当前 <code>lambda</code> 定义的参数，而是来自外部作用域的变量）冲突，这种重命名就是有效的。α-变换告诉我们，参数的具体名字是什么并不重要，重要的是函数的结构和行为。</p><h4 id=b-β-规约-beta-reduction>b. β-规约 (Beta Reduction)<a hidden class=anchor aria-hidden=true href=#b-β-规约-beta-reduction>#</a></h4><p>β-规约是 λ 演算的“引擎”，它描述了函数应用（调用）是如何执行的，其本质就是<strong>代入 (substitution)</strong>。</p><p>当一个形如 <code>((lambda (v) E_body) E_arg)</code> 的表达式出现时（即一个 <code>lambda</code> 函数紧接着被一个参数应用），β-规约允许我们将函数体 <code>E_body</code> 中所有出现的绑定变量 <code>v</code> 都替换成实际参数 <code>E_arg</code> 的（经过求值的）副本。</p><p>例如，对于表达式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>((lambda (x) (<span style=color:#a6e22e>+</span> x <span style=color:#ae81ff>1</span>)) <span style=color:#ae81ff>5</span>)
</span></span></code></pre></div><p>根据 β-规约：</p><ol><li>找到 <code>lambda</code> 的参数 <code>x</code> 和函数体 <code>(+ x 1)</code>。</li><li>找到实际传入的参数 <code>5</code>。</li><li>将函数体 <code>(+ x 1)</code> 中的所有（自由出现的）<code>x</code> 替换为 <code>5</code>。</li><li>得到新的表达式：<code>(+ 5 1)</code>。</li></ol><p>在 Scheme 环境下，这个表达式 <code>(+ 5 1)</code> 会被进一步求值为 <code>6</code>。β-规约是实现计算的核心步骤。</p><h4 id=c-η-变换-eta-conversion--η-reduction>c. η-变换 (Eta Conversion / η-reduction)<a hidden class=anchor aria-hidden=true href=#c-η-变换-eta-conversion--η-reduction>#</a></h4><p>η-变换表达了函数外延性的概念：如果两个函数对于所有可能的输入都产生相同的结果，那么它们就是等价的。</p><p>形式上，如果 <code>F</code> 是一个函数，且变量 <code>x</code> 在 <code>F</code> 中不是自由变量 (not free in F)，那么：
<code>(lambda (x) (F x))</code> 等价于 <code>F</code>。
（用传统符号表示即 $\lambda x.(F;x)$ 等价于 $F$，如果 $x \notin FV(F)$）</p><p>这意味着，如果一个函数的唯一作用就是将其参数传递给另一个函数 <code>F</code> 并返回结果，那么这个外层包裹的函数实际上就是 <code>F</code> 本身。</p><p>例如，如果我们有函数 <code>inc</code> (定义为 <code>(lambda (z) (+ z 1))</code>)，那么：
<code>(lambda (y) (inc y))</code> 就 η-等价于 <code>inc</code> 本身。</p><p>α-变换、β-规约和（可选的）η-变换共同构成了 λ 演算的计算基础。对于构建我们的计算体系而言，β-规约是最直接相关的“执行”规则。</p><h3 id=柯里化-currying用一元函数模拟多元函数>柯里化 (Currying)：用一元函数模拟多元函数<a hidden class=anchor aria-hidden=true href=#柯里化-currying用一元函数模拟多元函数>#</a></h3><p>你可能已经注意到，在纯粹的 λ 演算定义中，函数抽象（<code>lambda</code>）一次只绑定一个参数。例如我们前面看到的 <code>(lambda (x) x)</code>（$\lambda x.x$）或 <code>(lambda (x) (+ x 1))</code>（$\lambda x.x+1$）。那么，我们如何表示需要多个参数的函数呢，比如一个计算两数之积的函数，直觉上可能会写成类似 <code>(lambda (x y) (* x y))</code>（或 $\lambda xy. x \times y$）的形式？</p><p>在纯粹的 λ 演算中，函数严格来说只接受一个参数。但是，通过一种称为<strong>柯里化 (Currying)</strong> 的巧妙技巧（以逻辑学家哈斯凯尔·柯里命名），我们可以用这些一元函数来优雅地实现多元函数的效果。</p><p>这里的关键在于 λ 演算中的一个核心特性：<strong>函数是“一等公民”</strong>。这意味着函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。能够接受函数作为参数或返回函数的函数，我们称之为<strong>高阶函数 (Higher-Order Functions)</strong>。</p><p>柯里化的思想很简单：
要模拟一个接受多个参数（比如 <code>n</code> 个）的函数，我们可以：</p><ol><li>定义一个一元函数，它接受第一个参数。</li><li>这个函数返回一个新的<strong>一元函数</strong>，这个新函数接受第二个参数。</li><li>这个新函数又返回一个更新的<strong>一元函数</strong>，接受第三个参数&mldr;</li><li>如此往复，直到所有 <code>n</code> 个参数都被逐个接受。最后一个返回的函数才会最终计算并返回结果。</li></ol><p>让我们看一个例子。假设我们想实现一个两数相乘的函数 <code>multiply(x, y)</code>。通过柯里化，它可以表示为：</p><p>$\lambda x . (\lambda y . x \times y)$</p><p>在 Scheme 中，这对应于：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(lambda (x)
</span></span><span style=display:flex><span>  (lambda (y)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>*</span> x y)))
</span></span></code></pre></div><p>这个表达式做了什么？</p><ul><li>它首先定义了一个匿名函数，接受参数 <code>x</code>。</li><li>当这个函数被调用（比如传入 <code>3</code>）时，它并不会立即计算乘积，而是返回<strong>另一个新的匿名函数</strong>。这个新的函数“记住”了 <code>x</code> 的值（比如 <code>3</code>），并且它接受一个参数 <code>y</code>。</li><li>当这个返回的新函数被调用（比如传入 <code>4</code>）并传入 <code>y</code> 的值时，它才会执行 <code>(* x y)</code>（即 <code>(* 3 4)</code>），返回最终结果 <code>12</code>。</li></ul><p>我们如何使用这个柯里化的乘法函数呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#75715e>; 定义柯里化的乘法函数</span>
</span></span><span style=display:flex><span>(define curried-mult
</span></span><span style=display:flex><span>  (lambda (x)
</span></span><span style=display:flex><span>    (lambda (y)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>*</span> x y))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 应用第一个参数</span>
</span></span><span style=display:flex><span>(define times-three (curried-mult <span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span><span style=color:#75715e>; (curried-mult 3) 返回的是 (lambda (y) (* 3 y))</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; times-three 现在就是这个新函数</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 应用第二个参数</span>
</span></span><span style=display:flex><span>(display (times-three <span style=color:#ae81ff>5</span>)) <span style=color:#75715e>; 输出 15</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 或者一步到位地调用</span>
</span></span><span style=display:flex><span>(display ((curried-mult <span style=color:#ae81ff>3</span>) <span style=color:#ae81ff>5</span>)) <span style=color:#75715e>; 输出 15</span>
</span></span></code></pre></div><p>通过柯里化，我们成功地用一系列只接受单个参数的函数模拟了多参数函数的功能。这在 λ 演算的理论框架中至关重要，因为它表明仅用一元函数就足以表达所有计算。在很多函数式编程语言中，虽然它们可能提供了直接定义多参数函数的语法，但其底层有时就是通过柯里化来实现或解释的，或者柯里化本身就是一种推荐的编程范式。</p><h3 id=一层又一层抽象构建复杂性的阶梯>一层又一层抽象：构建复杂性的阶梯<a hidden class=anchor aria-hidden=true href=#一层又一层抽象构建复杂性的阶梯>#</a></h3><p>计算机科学与工程的伟大之处，很大程度上在于其精妙的<strong>抽象分层 (Layers of Abstraction)</strong>。我们从最底层的物理现象开始：</p><ul><li>我们抽象晶体管的行为，得到逻辑门（与门、或门、非门）。</li><li>我们抽象逻辑门的组合，得到算术逻辑单元 (ALU)、存储单元等。</li><li>我们抽象这些硬件组件的协同工作，得到完整的计算机体系结构。</li><li>然后，我们抽象硬件的细节，得到机器语言。</li><li>我们进一步抽象机器语言，得到汇编语言和指令集架构 (ISA)。</li><li>再往上，我们抽象汇编指令，得到C、Java、Python等高级编程语言，它们提供了更接近人类思维的表达方式。</li><li>甚至在高级语言内部，我们也会构建库、框架，提供更高层次的抽象来解决特定领域的问题。</li></ul><p>每一层都依赖于其下一层提供的功能，同时向上一层隐藏了不必要的复杂细节。这使得我们能够专注于当前层次的问题，而不必每次都从最原始的元素（比如电子的运动）开始思考。</p><p>在本文探索 λ 演算和丘奇编码的旅程中，我们也将采用类似的方法。
<strong>一旦我们成功地用 λ 演算定义了一个概念（比如布尔值、数字或某个运算），在后续的构造中，我们就会把它当作一个已知的、可以直接使用的“基本构建块”或“新定义的原语 (primitive)”。</strong> 我们不会在每次使用时都将其完全展开回最原始的 <code>lambda</code> 表达式形态（除非为了阐释特定原理）。</p><p>例如，一旦我们用 λ 表达式定义了数字 <code>ZERO</code>、<code>ONE</code> 和加法运算 <code>ADD</code>：</p><ul><li>在讨论乘法时，我们就可以直接写 <code>(ADD ONE ONE)</code> 来表示 <code>1+1</code>，而不需要把 <code>ADD</code>, <code>ONE</code> 都展开成它们底层的 <code>lambda</code> 定义。</li></ul><p>这样做可以让我们保持思路清晰，逐步构建更复杂的系统，而不至于迷失在无尽的 <code>lambda</code> 嵌套中。</p><p>现在，我们已经了解了 λ 演算的基本规则和柯里化这一重要技巧（它让我们能方便地处理多“参数”的函数），是时候开始用这些积木搭建我们计算世界的第一块基石了！</p><h2 id=构建数学与计算体系的开始基本元素>构建数学与计算体系的开始：基本元素<a hidden class=anchor aria-hidden=true href=#构建数学与计算体系的开始基本元素>#</a></h2><p>正如我们之前讨论的，纯粹的 λ 演算只拥有函数抽象（定义函数）和函数应用（调用函数）这两个基本构建块。我们日常编程中习以为常的“数字”、“自然数”、“加法运算”，乃至“字符”、“布尔值”（真/假）等等，在 λ 演算的原始宇宙中并不直接存在。</p><p>显然，如果缺少这些基本的数据类型和运算，我们很难用常规的思路来编写程序。</p><p>然而，λ 演算的强大之处在于，我们可以完全利用其自身的体系来<strong>构造</strong>出这些常用的对象。换句话说，我们可以为这些概念找到它们在 λ 演算世界中的函数式<strong>对应物 (functional counterparts)</strong>。</p><p>这个将数据类型和运算用纯函数来表达和实现的过程，正是<strong>丘奇编码 (Church Encoding)</strong> 的核心思想，由阿隆佐·丘奇本人开创。</p><p>让我们从最基本、也可能是最简单的概念开始：<strong>布尔值 (Booleans)</strong>。</p><h3 id=布尔值-booleans-与逻辑运算>布尔值 (Booleans) 与逻辑运算<a hidden class=anchor aria-hidden=true href=#布尔值-booleans-与逻辑运算>#</a></h3><p>布尔逻辑是计算的基石，它处理的是“真”与“假”这两个基本值。在丘奇编码中，这两个值被巧妙地定义为两个不同的<strong>选择函数</strong>：</p><ul><li><p><strong><code>true</code></strong> 被定义为一个函数，它接受两个参数，并总是选择并返回<strong>第一个</strong>参数。
$$ true := \lambda t . \lambda f . t $$
或者，使用我们之前约定的 Scheme 多参数函数抽象（内部通过柯里化实现）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define true (lambda (<span style=color:#66d9ef>t</span> f) <span style=color:#66d9ef>t</span>))
</span></span></code></pre></div></li><li><p><strong><code>false</code></strong> 被定义为一个函数，它接受两个参数，并总是选择并返回<strong>第二个</strong>参数。
$$ false := \lambda t . \lambda f . f $$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define false (lambda (<span style=color:#66d9ef>t</span> f) f))
</span></span></code></pre></div></li></ul><p><strong>这两个定义的神奇之处在于，它们内在地编码了条件选择的行为，这正是 <code>if-then-else</code> 语句的核心！</strong>
如果我们有一个丘奇布尔值 <code>condition</code>，以及两个表达式 <code>then-expr</code> 和 <code>else-expr</code>，那么：
<code>(condition then-expr else-expr)</code>
这个表达式本身就会根据 <code>condition</code> 是 <code>true</code> 还是 <code>false</code> 来求值：</p><ul><li>如果 <code>condition</code> 是 <code>true</code>，例如 <code>(true "苹果" "香蕉")</code>，它会返回 <code>"苹果"</code> (第一个参数)。</li><li>如果 <code>condition</code> 是 <code>false</code>，例如 <code>(false "苹果" "香蕉")</code>，它会返回 <code>"香蕉"</code> (第二个参数)。</li></ul><p>有了 <code>true</code> 和 <code>false</code> 这两个基本构建块，我们就可以定义出标准的逻辑运算符：</p><ol><li><p><strong>逻辑非 (NOT)</strong>: <code>(not x)</code>
<code>not</code> 应该将 <code>true</code> 变为 <code>false</code>，将 <code>false</code> 变为 <code>true</code>。
我们可以这样定义 <code>not</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define (<span style=color:#a6e22e>not</span> x)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; x 是一个选择函数，它会从后面两个参数中选一个</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; 如果 x 是 true, 它选择第一个参数 (false)。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; 如果 x 是 false, 它选择第二个参数 (true)。</span>
</span></span><span style=display:flex><span>  (x false true))
</span></span></code></pre></div><p><em>验证：</em></p><ul><li><code>(not true)</code> 会展开为 <code>(true false true)</code>，根据 <code>true</code> 的定义，返回 <code>false</code>。</li><li><code>(not false)</code> 会展开为 <code>(false false true)</code>，根据 <code>false</code> 的定义，返回 <code>true</code>。</li></ul></li><li><p><strong>逻辑与 (AND)</strong>: <code>(and p q)</code>
<code>p AND q</code> 为真，当且仅当 <code>p</code> 和 <code>q</code> 都为真。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define (and p q)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; 如果 p 是 true，则 AND 的结果取决于 q (实际上是 q 本身)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; 如果 p 是 false，则 AND 的结果一定是 false</span>
</span></span><span style=display:flex><span>  (p q false)) <span style=color:#75715e>; 注：这里 q 必须也是一个丘奇布尔值</span>
</span></span></code></pre></div><p><em>解释：</em></p><ul><li>如果 <code>p</code> 是 <code>true</code>：表达式变为 <code>(true q false)</code>。<code>true</code> 选择第一个参数，即 <code>q</code>。所以 <code>(and true q)</code> 的结果就是 <code>q</code>。<ul><li>若 <code>q</code> 是 <code>true</code>，结果是 <code>true</code>。</li><li>若 <code>q</code> 是 <code>false</code>，结果是 <code>false</code>。</li></ul></li><li>如果 <code>p</code> 是 <code>false</code>：表达式变为 <code>(false q false)</code>。<code>false</code> 选择第二个参数，即 <code>false</code>。所以 <code>(and false q)</code> 的结果总是 <code>false</code>。
这完全符合 <code>AND</code> 的逻辑。
<em>(你原文中的 <code>(p (q true false) false)</code> 也是完全正确的，它更明确地将 <code>q</code> 的结果约束在 <code>true</code> 或 <code>false</code> 上，如果 <code>q</code> 本身已经是丘奇布尔值，<code> (q true false)</code> 就等价于 <code>q</code>。)</em></li></ul></li><li><p><strong>逻辑或 (OR)</strong>: <code>(or p q)</code>
<code>p OR q</code> 为真，只要 <code>p</code> 或 <code>q</code> 中至少一个为真。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define (or p q)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; 如果 p 是 true，则 OR 的结果一定是 true</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; 如果 p 是 false，则 OR 的结果取决于 q (实际上是 q 本身)</span>
</span></span><span style=display:flex><span>  (p true q)) <span style=color:#75715e>; 注：这里 q 必须也是一个丘奇布尔值</span>
</span></span></code></pre></div><p><em>解释：</em></p><ul><li>如果 <code>p</code> 是 <code>true</code>：表达式变为 <code>(true true q)</code>。<code>true</code> 选择第一个参数，即 <code>true</code>。所以 <code>(or true q)</code> 的结果总是 <code>true</code>。</li><li>如果 <code>p</code> 是 <code>false</code>：表达式变为 <code>(false true q)</code>。<code>false</code> 选择第二个参数，即 <code>q</code>。所以 <code>(or false q)</code> 的结果就是 <code>q</code>。<ul><li>若 <code>q</code> 是 <code>true</code>，结果是 <code>true</code>。</li><li>若 <code>q</code> 是 <code>false</code>，结果是 <code>false</code>。
这完美符合 <code>OR</code> 的逻辑。
<em>(同样，你原文的 <code>(p true (q true false))</code> 也是正确的。)</em></li></ul></li></ul></li></ol><p>阿隆佐·丘奇选择用“选择函数”来代表布尔值，这无疑是一个天才般的洞察。“选择”这一行为完美地概括了我们通常使用布尔值所做的核心操作——基于条件做出决策——这也使得后续逻辑运算的定义变得异常简洁和优雅。我们仅仅通过函数定义和应用，就凭空创造出了逻辑系统！</p><hr><h3 id=小扩展更直观的-if-结构>小扩展：更直观的 <code>if</code> 结构<a hidden class=anchor aria-hidden=true href=#小扩展更直观的-if-结构>#</a></h3><p>既然我们的丘奇布尔值 <code>true</code> 和 <code>false</code> 本身就是选择函数，我们自然可以定义一个更符合我们日常编程直觉的 <code>if</code> 控制结构。这个 <code>if</code> 函数将接受三个参数：一个条件 (丘奇布尔值)，一个“then”分支的表达式，以及一个“else”分支的表达式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define (if-then-else <span style=color:#66d9ef>condition</span> then-branch else-branch)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>condition</span> then-branch else-branch))
</span></span></code></pre></div><p>你可能会问，这和直接写 <code>(condition then-branch else-branch)</code> 有什么本质区别呢？确实，通过我们前面讨论过的 <strong>η-变换 (Eta Conversion)</strong>，<code>(lambda (c t e) (c t e))</code> 其实就等价于一个直接接受 <code>c, t, e</code> 并应用的结构（在Scheme中，多参数函数可以看作是柯里化的一种语法糖）。
然而，定义这样一个 <code>if-then-else</code> 函数的好处在于：</p><ol><li><strong>可读性：</strong> <code>(if-then-else hungry? (eat food) (sleep))</code> 比 <code>(hungry? (eat food) (sleep))</code> 更明确地表达了条件判断的意图，尤其是当 <code>hungry?</code> 本身也是一个复杂表达式时。</li><li><strong>抽象的体现：</strong> 它再次强调了我们可以通过函数封装来构建我们熟悉的编程构造。这更像是一种“语法糖”，它向我们展示了如何将底层的函数式构造包装成更易读、更符合特定编程范式的形式。</li></ol><p>这再次提醒我们，λ 演算的表达能力是灵活的，我们可以基于核心规则构建出我们需要的抽象层次。</p><h3 id=自然数-natural-numbers函数的重复应用>自然数 (Natural Numbers)：函数的重复应用<a hidden class=anchor aria-hidden=true href=#自然数-natural-numbers函数的重复应用>#</a></h3><p>继布尔值之后，下一个重要的基石是<strong>自然数 (Natural Numbers)</strong>，如 0, 1, 2, &mldr;
与布尔值通过“选择”来定义不同，自然数的丘奇编码抓住的是“重复”或“迭代”这一核心概念。</p><p>阿隆佐·丘奇的天才之处在于他意识到，数字可以被表示为<strong>高阶函数</strong>，其含义是“<strong>一个函数被应用的次数</strong>”。</p><p>具体来说，一个丘奇数 <code>n</code> 是一个函数，它接受两个参数：</p><ol><li>一个函数 <code>f</code> (代表要被重复应用的操作)。</li><li>一个初始值 <code>x</code> (代表该操作的起点，或者说被操作的对象)。</li></ol><p>这个丘奇数 <code>n</code> 会将 <code>f</code> 应用到 <code>x</code> 上恰好 <code>n</code> 次。</p><p><strong>“重复应用 n 次”如何用纯函数定义呢？</strong> 我们没有循环语句，也没有内置的计数器。
答案在于巧妙地利用函数本身的结构，类似于数学中从 0 和后继操作构建自然数的皮亚诺公理 (Peano Axioms)。</p><h4 id=数字-零-zero>数字 零 (ZERO)<a hidden class=anchor aria-hidden=true href=#数字-零-zero>#</a></h4><p>数字 <strong>零 (ZERO)</strong> 就代表“将函数 <code>f</code> 应用零次”。这意味着无论 <code>f</code> 是什么，初始值 <code>x</code> 都原封不动地返回。
其定义如下：
$$ ZERO := \lambda f . \lambda x . x $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define ZERO
</span></span><span style=display:flex><span>  (lambda (f)      <span style=color:#75715e>; ZERO 接受一个函数 f</span>
</span></span><span style=display:flex><span>    (lambda (x)    <span style=color:#75715e>; 并返回一个新的函数，这个新函数接受 x</span>
</span></span><span style=display:flex><span>      x)))         <span style=color:#75715e>; 然后直接返回 x (f 应用了0次)</span>
</span></span></code></pre></div><p>这里的 <code>ZERO</code> 是一个柯里化的函数。它首先接受一个函数 <code>f</code>，然后返回另一个函数。这个内部函数接受初始值 <code>x</code> 并直接返回 <code>x</code>，完美体现了 <code>f</code> 被应用了零次。</p><p>例如，如果我们有一个函数 <code>inc</code> (加一) 和一个值 <code>10</code>：
<code>((ZERO inc) 10)</code></p><ol><li><code>(ZERO inc)</code> 会返回 <code>(lambda (x) x)</code> （因为 <code>f</code> 是 <code>inc</code>，但没有被使用）。</li><li>然后 <code>((lambda (x) x) 10)</code> 会返回 <code>10</code>。
这正是我们期望的“对 10 加一 0 次”的结果。</li></ol><h4 id=后继函数-successor-function-s>后继函数 (Successor Function, S)<a hidden class=anchor aria-hidden=true href=#后继函数-successor-function-s>#</a></h4><p>有了 <code>ZERO</code>，我们如何得到其他数字呢？我们需要一个<strong>后继函数 (Successor Function)</strong>，通常表示为 <code>S</code>。<code>S</code> 接受一个丘奇数 <code>n</code> 作为输入，并返回代表 <code>n+1</code> 的丘奇数。</p><p>如果丘奇数 <code>n</code> 代表“将 <code>f</code> 应用 <code>n</code> 次”，那么 <code>(S n)</code>（即 <code>n+1</code>）就应该代表“将 <code>f</code> 应用 <code>n+1</code> 次”。
这可以这样理解：要将 <code>f</code> 应用 <code>n+1</code> 次到 <code>x</code> 上，我们可以先将 <code>f</code> 应用 <code>n</code> 次到 <code>x</code> 上得到一个中间结果，然后再对这个中间结果额外应用一次 <code>f</code>。</p><p>形式化地，后继函数 <code>S</code> 定义为：
$$ S := \lambda n . \lambda f . \lambda x . f ( (n f) x ) $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define S
</span></span><span style=display:flex><span>  (lambda (n)          <span style=color:#75715e>; S 接受一个丘奇数 n</span>
</span></span><span style=display:flex><span>    (lambda (f)        <span style=color:#75715e>; 返回一个新函数 (代表 n+1)，它接受 f</span>
</span></span><span style=display:flex><span>      (lambda (x)      <span style=color:#75715e>; 再返回一个新函数，它接受 x</span>
</span></span><span style=display:flex><span>        (f             <span style=color:#75715e>; 将 f 应用于...</span>
</span></span><span style=display:flex><span>         ((n f) x)))))) <span style=color:#75715e>; ...n 将 f 应用于 x 的结果</span>
</span></span></code></pre></div><p>让我们仔细解读一下 <code>S</code> 的定义：</p><ol><li><code>S</code> 接受一个丘奇数 <code>n</code> (例如 <code>ZERO</code>)。</li><li>它返回一个新的函数，这个函数就是代表 <code>n+1</code> 的丘奇数。这个新函数也遵循丘奇数的规范，所以它也期望接受一个函数 <code>f</code> 和一个值 <code>x</code>。</li><li>当这个代表 <code>n+1</code> 的函数被 <code>f</code> 和 <code>x</code> 调用时，它的行为是 <code>(f ((n f) x))</code>：<ul><li><code>(n f)</code>: 首先，我们将输入的丘奇数 <code>n</code> 应用于 <code>f</code>。回忆一下，丘奇数 <code>n</code> 本身是 <code>(lambda (f_inner) (lambda (x_inner) ...))</code> 的形式。所以 <code>(n f)</code> 会返回一个“准备好对某个 <code>x_inner</code> 应用 <code>f_inner</code>（这里是 <code>f</code>）<code>n</code> 次”的函数。</li><li><code>((n f) x)</code>: 接着，我们将上面返回的函数应用于 <code>x</code>。这就完成了 <code>f</code> 在 <code>x</code> 上的 <code>n</code> 次应用。</li><li><code>(f ((n f) x))</code>: 最后，我们将 <code>f</code> 再额外应用一次到 <code>((n f) x)</code> 的结果上。这就构成了 <code>f</code> 的 <code>n+1</code> 次应用。</li></ul></li></ol><p>这种从 <code>ZERO</code> 和后继函数 <code>S</code> 出发来构造所有自然数的方法，其思想与数学中的<strong>皮亚诺公理 (Peano Axioms)</strong> 定义自然数的方式高度相似（皮亚诺公理：① 0 是自然数；② 每个自然数 a 都有一个后继数 S(a)；&mldr;）。</p><p>现在，我们可以定义其他数字了：</p><ul><li><strong><code>ONE</code></strong> 就是 <code>(S ZERO)</code></li><li><strong><code>TWO</code></strong> 就是 <code>(S ONE)</code>，也就是 <code>(S (S ZERO))</code></li><li><strong><code>THREE</code></strong> 就是 <code>(S TWO)</code>，也就是 <code>(S (S (S ZERO)))</code><br>等等。</li></ul><p>例如，<code>ONE</code> 的展开会是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define ONE (S ZERO))
</span></span><span style=display:flex><span><span style=color:#75715e>;; ONE 展开为：</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; (lambda (f)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;   (lambda (x)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;     (f ((ZERO f) x))))</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; 由于 ((ZERO f) x) 会返回 x，所以 ONE 进一步简化为：</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; (lambda (f)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;   (lambda (x)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;     (f x)))</span>
</span></span></code></pre></div><p>这完美符合“将 <code>f</code> 应用一次到 <code>x</code>”的定义。</p><p>同样，<code>TWO</code> 会展开为 <code>(lambda (f) (lambda (x) (f (f x))))</code>，即 <code>f</code> 应用两次。</p><p>通过 <code>ZERO</code> 和 <code>S</code>，我们已经用纯粹的函数构建了整个自然数体系的“骨架”！下一步，我们将探索如何在这些丘奇数上进行算术运算，比如加法和乘法。</p><h3 id=算术运算-arithmetic-operations-加法与乘法>算术运算 (Arithmetic Operations): 加法与乘法<a hidden class=anchor aria-hidden=true href=#算术运算-arithmetic-operations-加法与乘法>#</a></h3><p>有了代表自然数的丘奇编码，我们自然想在它们之上定义算术运算，比如加法和乘法。</p><p>熟悉皮亚诺公理 (Peano Axioms) 的朋友可能还记得它们是如何递归定义加法和乘法的：</p><ul><li><strong>加法:</strong><ol><li>对于任意自然数 $m$, $m + 0 = m$</li><li>对于任意自然数 $m$ 和 $n$, $m + S(n) = S(m+n)$ (其中 $S(n)$ 是 $n$ 的后继，即 $n+1$)</li></ol></li><li><strong>乘法:</strong><ol><li>对于任意自然数 $m$, $m \times 0 = 0$</li><li>对于任意自然数 $m$ 和 $n$, $m \times S(n) = (m \times n) + m$</li></ol></li></ul><p>直接将这些递归定义转换为纯 λ 演算（尤其是没有显式递归操作符如 Y 组合子的情况下）会有些棘手，特别是处理像 $S(n)$ 这样需要“分解”参数的模式，或者找到一个数的前驱。</p><p>幸运的是，丘奇编码的本质——“将一个函数应用特定次数”——为我们提供了一条更直接、更优雅的路径。</p><h4 id=加法-addition-m--n>加法 (Addition): <code>m + n</code><a hidden class=anchor aria-hidden=true href=#加法-addition-m--n>#</a></h4><p>思考一下加法 <code>m + n</code> 的含义：它可以被看作是<strong>从数字 <code>m</code> 开始，连续应用“加一”（即后继函数 <code>S</code>）操作 <code>n</code> 次</strong>。</p><p>这完美契合了丘奇数 <code>n</code> 的定义！回忆一下，丘奇数 <code>n</code> 是一个函数 <code>(lambda (f) (lambda (x) ...))</code>，它会将 <code>f</code> 应用到 <code>x</code> 上 <code>n</code> 次。</p><ul><li>我们想要应用的操作是“后继”函数 <code>S</code>。</li><li>我们想要应用这个操作的起点是丘奇数 <code>m</code>。</li><li>我们想要应用它的次数是 <code>n</code> 次。</li></ul><p>所以，<code>m + n</code> 可以通过将丘奇数 <code>n</code> 应用于后继函数 <code>S</code> 和初始值 <code>m</code> 来实现：
<code>((n S) m)</code></p><p>因此，我们可以定义一个柯里化的加法函数 <code>PLUS</code> (或者叫 <code>ADD</code>)：
$$ PLUS := \lambda m . \lambda n . ( (n S) m ) $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define PLUS
</span></span><span style=display:flex><span>  (lambda (m)      <span style=color:#75715e>; PLUS 接受第一个加数 m</span>
</span></span><span style=display:flex><span>    (lambda (n)    <span style=color:#75715e>; 返回一个函数，该函数接受第二个加数 n</span>
</span></span><span style=display:flex><span>      ((n S) m)))) <span style=color:#75715e>; 将 S 应用到 m 上 n 次</span>
</span></span></code></pre></div><p>让我们来验证一下 <code>(PLUS ONE TWO)</code> 是否等于 <code>THREE</code>：</p><ul><li><code>PLUS</code> 应用于 <code>ONE</code>：<code>(PLUS ONE)</code> 返回 <code>(lambda (n) ((n S) ONE))</code>。</li><li>将此结果应用于 <code>TWO</code>：<code>(((lambda (n) ((n S) ONE)) TWO))</code>
这会进行 β-规约，得到 <code>((TWO S) ONE)</code>。</li><li>现在我们展开 <code>TWO</code>。<code>TWO</code> 是 <code>(lambda (f) (lambda (x) (f (f x))))</code>。</li><li>所以 <code>(TWO S)</code> 返回 <code>(lambda (x) (S (S x)))</code>。</li><li>最后，<code>((lambda (x) (S (S x))) ONE)</code> 应用于 <code>ONE</code>：
这得到 <code>(S (S ONE))</code>。</li><li>根据后继函数的定义，这正是 <code>THREE</code>！</li></ul><p>加法的定义就是如此简洁！它直接利用了丘奇数 <code>n</code> 作为“迭代器”的特性。</p><h4 id=乘法-multiplication-m--n>乘法 (Multiplication): <code>m × n</code><a hidden class=anchor aria-hidden=true href=#乘法-multiplication-m--n>#</a></h4><p>乘法 <code>m × n</code> 又如何用类似的思想表达呢？
它可以被看作是<strong>将“加 <code>m</code>”这个操作，应用 <code>n</code> 次，并且从 <code>ZERO</code> 开始累加</strong>。
也就是说： $m \times n = \underbrace{m + m + \dots + m}_{n \text{ times}}$。</p><ul><li>我们想要重复应用的操作是 “将 <code>m</code> 加到某个数上”。这个操作本身可以用我们刚定义的 <code>PLUS</code> 来表示：<code>(PLUS m)</code>。回忆一下，<code>(PLUS m)</code> 是一个函数，它接受一个参数 <code>k</code> 并返回 <code>m+k</code> (即 <code>((k S) m)</code>)。</li><li>我们想要应用这个操作的起点是 <code>ZERO</code>。</li><li>我们想要应用它的次数是 <code>n</code> 次。</li></ul><p>所以，<code>m × n</code> 可以通过将丘奇数 <code>n</code> 应用于“加 <code>m</code>”这个函数 <code>(PLUS m)</code> 和初始值 <code>ZERO</code> 来实现：
<code>((n (PLUS m)) ZERO)</code></p><p>因此，柯里化的乘法函数 <code>TIMES</code> (或者叫 <code>MULTIPLY</code>) 定义为：
$$ TIMES := \lambda m . \lambda n . ( (n (PLUS \ m)) ZERO ) $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define TIMES
</span></span><span style=display:flex><span>  (lambda (m)          <span style=color:#75715e>; TIMES 接受第一个乘数 m</span>
</span></span><span style=display:flex><span>    (lambda (n)        <span style=color:#75715e>; 返回一个函数，该函数接受第二个乘数 n</span>
</span></span><span style=display:flex><span>      ((n (PLUS m))    <span style=color:#75715e>; 将 (PLUS m) 这个“加m”的函数...</span>
</span></span><span style=display:flex><span>       ZERO))))        <span style=color:#75715e>; ...应用 n 次到 ZERO 上</span>
</span></span></code></pre></div><p>这里的 <code>(PLUS m)</code> 是一个函数，它等待另一个参数 <code>k</code> 来计算 <code>m+k</code>。丘奇数 <code>n</code> 正好可以将这个“加 <code>m</code>”的函数重复作用。</p><p>例如，思考 <code>(TIMES TWO THREE)</code>:</p><ol><li><code>(TIMES TWO)</code> 返回 <code>(lambda (n) ((n (PLUS TWO)) ZERO))</code>。</li><li>将其应用于 <code>THREE</code>： <code>((THREE (PLUS TWO)) ZERO)</code>。</li><li><code>THREE</code> 会将 <code>(PLUS TWO)</code> 这个函数应用 3 次到 <code>ZERO</code> 上：<ul><li>第一次：<code>((PLUS TWO) ZERO)</code> 结果是 <code>TWO</code> (0 + 2 = 2)</li><li>第二次：<code>((PLUS TWO) TWO)</code> 结果是 <code>FOUR</code> (2 + 2 = 4) (假设我们已经定义了 <code>FOUR</code>)</li><li>第三次：<code>((PLUS TWO) FOUR)</code> 结果是 <code>SIX</code> (4 + 2 = 6) (假设我们已经定义了 <code>SIX</code>)
这正是 $2 \times 3 = 6$。</li></ul></li></ol><p>通过这些定义，我们看到丘奇编码不仅能表示数字，还能以一种非常优雅和本质的方式来定义它们之间的运算，这一切都仅仅建立在函数抽象和应用之上！</p><h3 id=进入更深层次的构造比较与减法>进入更深层次的构造：比较与减法<a hidden class=anchor aria-hidden=true href=#进入更深层次的构造比较与减法>#</a></h3><p>我们已经成功地用纯函数定义了布尔逻辑、自然数以及基本的加法和乘法运算。这本身已经是一个了不起的成就，展示了 $\lambda$ 演算惊人的表达能力。现在，我们将继续沿着这条道路前进，构建更复杂的计算工具，首当其冲的是如何比较两个数字，以及如何定义减法。</p><p>正如你可能预料到的，这些操作的定义会比加法和乘法稍微复杂一些，它们需要我们更深入地挖掘丘奇编码的潜力，并引入一些新的辅助函数。</p><h4 id=减法--引入>减法 · 引入<a hidden class=anchor aria-hidden=true href=#减法--引入>#</a></h4><p>按照四则运算的顺序，接下来我们要构造的就是减法，它是加法的逆运算。</p><p>面对这个问题，你第一时间的想法是什么？很有可能你会想到“前驱函数”（即找到 $n-1$），然后思考“如何从 $n$ 次函数应用中去除一次”。</p><p>这听起来似乎直接，例如通过求反函数。然而，并非所有函数都拥有反函数，且求取反函数本身也相当复杂。我们需要另辟蹊径。</p><p>从“加法的逆运算”这个角度思考 $n-m$：我们是否可以枚举一个数 $k$ (从 $0$ 到 $n$)，检查 $k+m$ 是否等于 $n$？如果相等，则 $k$ 就是 $n-m$ 的值。如果找不到这样的 $k$，则 $n-m$ 在自然数内无解。</p><p>然而，这又引入了一个新问题：我们如何判断两个丘奇数是否“相等”？这是一个我们尚未定义的关键谓词。</p><p>有人可能会说：“如果 $n-m=0$，那么 $n$ 不就等于 $m$ 了吗？”或者“如果 $n \ge m$ 且 $n \le m$，那么 $n=m$。” 但这又会使我们陷入对减法或比较运算的循环定义中。</p><p>别担心，我们将逐步解决这些问题。</p><h4 id=判断是否为零-zero一个重要的边界条件>判断是否为零 (<code>ZERO?</code>)：一个重要的边界条件<a hidden class=anchor aria-hidden=true href=#判断是否为零-zero一个重要的边界条件>#</a></h4><p>要判断任意两个自然数是否相等，或者进行更复杂的算术运算，我们至少需要能够判断一个数是否为零。这是许多递归定义和条件判断的基础。</p><p>我们可以通过以下方式巧妙地定义 <code>ZERO?</code> 谓词：
$$ \text{ZERO? predicated} := \lambda n . (n \ (\lambda x . \text{FALSE})) \ \text{TRUE} $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define ZERO?
</span></span><span style=display:flex><span>  (lambda (n)
</span></span><span style=display:flex><span>    ((n (lambda (x) FALSE)) TRUE)))
</span></span></code></pre></div><p>这个定义的巧妙之处在于它利用了丘奇数自身的特性：</p><ul><li><p>回忆一下，丘奇数 <code>ZERO</code> 定义为 $ \lambda f . \lambda x . x $。</p><p>如果参数 <code>n</code> 是 <code>ZERO</code>，那么 <code>(ZERO (lambda (x) FALSE))</code> 会忽略掉 <code>(lambda (x) FALSE)</code> 这个函数，直接返回一个恒等函数 $ \lambda y . y $。</p><p>于是整个表达式 <code>(ZERO? ZERO)</code> 变为 <code>((lambda (y) y) TRUE)</code>，其结果自然是 <code>TRUE</code>。</p></li><li><p>如果参数 <code>n</code> 是一个非零的丘奇数（比如 <code>ONE</code>, <code>TWO</code>, &mldr;），它代表将第一个参数（一个函数）应用若干（非零）次。</p><p>那么 <code>(n (lambda (x) FALSE))</code> 意味着将 <code>(lambda (x) FALSE)</code> 这个“无论输入是什么都返回 <code>FALSE</code>”的函数至少应用一次到某个初始值上。其最终效果是得到一个“总是返回 <code>FALSE</code>”的函数（可以认为是 $ \lambda y . \text{FALSE} $）。</p><p>于是整个表达式 <code>(ZERO? n)</code>（当 <code>n</code> 非零时）变为 <code>((\lambda y . FALSE) TRUE)</code>，其结果便是 <code>FALSE</code>。</p></li></ul><p>这样，我们就得到了一个可靠的 <code>ZERO?</code> 测试。</p><h4 id=构造数据结构的基础丘奇对-church-pairs>构造数据结构的基础——丘奇对 (Church Pairs)<a hidden class=anchor aria-hidden=true href=#构造数据结构的基础丘奇对-church-pairs>#</a></h4><p>在定义更复杂的操作（如前驱函数）之前，我们需要一种方式来将两个值组合成一个单一的复合数据单元。<strong>丘奇对 (Church Pairs)</strong> 提供了这样的机制，它类似于许多编程语言中的 <code>pair</code> 或二元元组。</p><p>一个丘奇对通过一个高阶函数来表示，这个高阶函数接受一个“选择器”函数作为参数。当我们用两个值 <code>a</code> 和 <code>b</code> 构造一个序对时，这个序对函数会“包裹”住 <code>a</code> 和 <code>b</code>。当它被一个选择器函数 <code>s</code> 调用时，它会将 <code>a</code> 和 <code>b</code> 传递给 <code>s</code>，即执行 <code>(s a b)</code>。</p><p>构造序对的函数 <code>CONS</code> 定义如下：
$$ \text{CONS} := \lambda a . \lambda b . \lambda s . (s \ a \ b) $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define CONS
</span></span><span style=display:flex><span>  (lambda (first-element)
</span></span><span style=display:flex><span>    (lambda (second-element)
</span></span><span style=display:flex><span>      (lambda (selector-function)
</span></span><span style=display:flex><span>        (selector-function first-element second-element)))))
</span></span></code></pre></div><p>要从序对中提取元素，我们需要合适的选择器。丘奇布尔值 <code>TRUE</code> ($\lambda t . \lambda f . t$) 和 <code>FALSE</code> ($\lambda t . \lambda f . f$) 正好可以胜任：</p><ul><li><strong><code>CAR</code> (获取第一个元素):</strong>
$$ \text{CAR} := \lambda p . (p \ \text{TRUE}) $$<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define CAR
</span></span><span style=display:flex><span>  (lambda (a-church-pair)
</span></span><span style=display:flex><span>    (a-church-pair TRUE)))
</span></span></code></pre></div></li><li><strong><code>CDR</code> (获取第二个元素):</strong>
$$ \text{CDR} := \lambda p . (p \ \text{FALSE}) $$<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define CDR
</span></span><span style=display:flex><span>  (lambda (a-church-pair)
</span></span><span style=display:flex><span>    (a-church-pair FALSE)))
</span></span></code></pre></div></li></ul><p>丘奇对是构建更复杂数据结构（如列表）和实现某些算法（如下文的前驱函数）的关键。</p><h4 id=前驱函数-pred寻找-n-1>前驱函数 (<code>PRED</code>)：寻找 $n-1$<a hidden class=anchor aria-hidden=true href=#前驱函数-pred寻找-n-1>#</a></h4><p>前驱函数 <code>PRED</code> 的目标是计算 $n-1$。对于丘奇数 <code>ZERO</code>，其前驱仍然是 <code>ZERO</code> (即 $ \text{PRED ZERO} = \text{ZERO} $ )。</p><p>直接从丘奇数“减去”一次函数应用是困难的。但我们有一个巧妙的思路：考虑一个序列，例如 $ (0, 0, 1, 2, 3, \dots) $。如果我们能通过某种方式定位到这个序列的第 $n$ 项（0-indexed），那么这一项的值恰好是 $n$ 的前驱（当 $n=0$ 时为 $0$，当 $n=1$ 时为 $0$，当 $n=2$ 时为 $1$，以此类推）。</p><p>我们不必实际构造一个无穷列表。关键在于定义一个<strong>状态转换函数</strong>，该函数接受当前状态（一个序对），并返回序列中的下一个状态。丘奇数 $n$ 可以将这个状态转换函数应用 $n$ 次。</p><p>我们将状态表示为一个序对 <code>(current-predecessor-value, flag)</code>:</p><ul><li><code>current-predecessor-value</code>：表示当前计算到的前驱值。</li><li><code>flag</code>：一个状态标记。<code>ZERO</code> 表示这是迭代的初始步骤（对应输入数字 0 或 1 的情况），<code>ONE</code> 表示是后续的常规步骤。</li></ul><p>初始状态为 <code>(CONS ZERO ZERO)</code>。
状态转换函数 <code>PHI_PRED_STEP</code> 定义为：
$$ \Phi_{\text{PRED_STEP}} := \lambda p . (\text{ZERO?} \ (\text{CDR}\ p)) \ (\text{CONS}\ \text{ZERO}\ \text{ONE}) \ (\text{CONS}\ (\text{S}\ (\text{CAR}\ p))\ \text{ONE}) $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define PHI_PRED_STEP
</span></span><span style=display:flex><span>  (lambda (p) <span style=color:#75715e>; p 是形如 (current-predecessor-value, flag) 的序对</span>
</span></span><span style=display:flex><span>    ((ZERO? (CDR p))          <span style=color:#75715e>; 检查 flag 是否为 ZERO</span>
</span></span><span style=display:flex><span>     (CONS ZERO ONE)          <span style=color:#75715e>; 如果是，下一个状态是 (ZERO, ONE)</span>
</span></span><span style=display:flex><span>     (CONS (S (CAR p)) ONE)))) <span style=color:#75715e>; 否则，下一个状态是 (S current-predecessor-value, ONE)</span>
</span></span></code></pre></div><p>这个转换逻辑是：</p><ol><li>如果 <code>flag</code> 是 <code>ZERO</code>（初始状态，意味着我们正在处理输入为 <code>ZERO</code> 或 <code>ONE</code> 的情况的“第一步迭代”）：下一个状态的 <code>current-predecessor-value</code> 保持 <code>ZERO</code>，并将 <code>flag</code> 置为 <code>ONE</code>。</li><li>如果 <code>flag</code> 是 <code>ONE</code>（后续状态）：下一个状态的 <code>current-predecessor-value</code> 是前一个值的后继 <code>(S (CAR p))</code>，<code>flag</code> 保持 <code>ONE</code>。</li></ol><p>有了初始状态和转换函数，<code>PRED n</code> 就是将 <code>PHI_PRED_STEP</code> 应用 $n$ 次到初始状态 <code>(CONS ZERO ZERO)</code> 上，然后取结果序对的第一个元素：
$$ \text{PRED} := \lambda n . \text{CAR} \ (n \ \Phi_{\text{PRED_STEP}} \ (\text{CONS ZERO ZERO})) $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define PRED
</span></span><span style=display:flex><span>  (lambda (n)
</span></span><span style=display:flex><span>    (CAR ((n PHI_PRED_STEP) (CONS ZERO ZERO)))))
</span></span></code></pre></div><p>让我们验证一下：</p><ul><li><code>(PRED ZERO)</code>: <code>PHI_PRED_STEP</code> 应用 0 次，结果是 <code>(CAR (CONS ZERO ZERO))</code> 即 <code>ZERO</code>。</li><li><code>(PRED ONE)</code>:<ol><li>初始状态 <code>p0 = (CONS ZERO ZERO)</code>。</li><li>应用一次 <code>PHI_PRED_STEP</code>: <code>(PHI_PRED_STEP p0)</code>。因为 <code>(CDR p0)</code> 是 <code>ZERO</code>，所以结果是 <code>p1 = (CONS ZERO ONE)</code>。</li><li><code>(CAR p1)</code> 是 <code>ZERO</code>。所以 <code>(PRED ONE)</code> 是 <code>ZERO</code>。</li></ol></li><li><code>(PRED TWO)</code>:<ol><li><code>p0 = (CONS ZERO ZERO)</code>。</li><li>第一次应用得到 <code>p1 = (CONS ZERO ONE)</code>。</li><li>第二次应用 <code>(PHI_PRED_STEP p1)</code>。因为 <code>(CDR p1)</code> 是 <code>ONE</code> (非 <code>ZERO</code>)，所以结果是 <code>p2 = (CONS (S (CAR p1)) ONE) = (CONS (S ZERO) ONE) = (CONS ONE ONE)</code>。</li><li><code>(CAR p2)</code> 是 <code>ONE</code>。所以 <code>(PRED TWO)</code> 是 <code>ONE</code>。</li></ol></li></ul><p>这完美地实现了前驱函数的功能。</p><h4 id=减法--截断减法-sub>减法 · 截断减法 (<code>SUB</code>)<a hidden class=anchor aria-hidden=true href=#减法--截断减法-sub>#</a></h4><p>有了前驱函数 <code>PRED</code>，定义减法就变得直接了。我们要实现的是<strong>截断减法 (Truncating Subtraction)</strong>，即 $m-n$。如果 $m \ge n$，结果是 $m-n$；如果 $m &lt; n$，结果是 $0$（因为我们只处理自然数）。</p><p>$m-n$ 可以看作是对 $m$ 重复应用 <code>PRED</code> 函数 $n$ 次。
$$ \text{SUB} := \lambda m . \lambda n . (n \ \text{PRED} \ m) $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define SUB
</span></span><span style=display:flex><span>  (lambda (m)
</span></span><span style=display:flex><span>    (lambda (n)
</span></span><span style=display:flex><span>      ((n PRED) m)))) <span style=color:#75715e>; 计算 m - n</span>
</span></span></code></pre></div><p>例如 <code>(SUB FIVE TWO)</code> 会将 <code>PRED</code> 应用 2 次到 <code>FIVE</code> 上，得到 <code>THREE</code>。而 <code>(SUB TWO FIVE)</code> 会得到 <code>ZERO</code>。</p><h4 id=关系运算符>关系运算符<a hidden class=anchor aria-hidden=true href=#关系运算符>#</a></h4><p>基于 <code>SUB</code> 和 <code>ZERO?</code>，我们可以构建各种关系运算符：</p><ol><li><p><strong>小于或等于 (<code>IS_LEQ?</code>)</strong>: $m \le n$ 当且仅当 $m-n = 0$ (在截断减法中)。
$$ \text{IS_LEQ?} := \lambda m . \lambda n . \text{ZERO?} \ (\text{SUB}\ m \ n) $$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define IS_LEQ?
</span></span><span style=display:flex><span>  (lambda (m)
</span></span><span style=display:flex><span>    (lambda (n)
</span></span><span style=display:flex><span>      (ZERO? (SUB m n)))))
</span></span></code></pre></div></li><li><p><strong>大于 (<code>IS_GT?</code>)</strong>: $m > n$ 当且仅当 $m-n \neq 0$ (且 $m-n > 0$)，也即 $m \not\le n$。
$$ \text{IS_GT?} := \lambda m . \lambda n . \text{NOT} \ (\text{IS_LEQ?}\ m \ n) $$
或者，更直接地：$m > n$ 当且仅当 $m-n$ 的结果不是 $ZERO$ (在我们的自然数和截断减法定义下，这意味着 $m-n$ 是一个正数)。
$$ \text{IS_GT?}<em>{\text{alt}} := \lambda m . \lambda n . \text{NOT} \ (\text{ZERO?} \ (\text{SUB}\ m \ n)) $$
*(注：使用 $\text{IS_GT?}</em>{\text{alt}}$ 定义，则 $m>n$ 为真。若 $m \le n$, $\text{SUB}\ m\ n$ 为 $\text{ZERO}$, $ZERO?$ 为 $\text{TRUE}$, $\text{NOT}$ 为 $\text{FALSE}$)*</p></li><li><p><strong>等于 (<code>IS_EQ?</code>)</strong>: $m = n$ 当且仅当 $m \le n$ 并且 $n \le m$。
$$ \text{IS_EQ?} := \lambda m . \lambda n . \text{AND} \ (\text{IS_LEQ?}\ m \ n) \ (\text{IS_LEQ?}\ n \ m) $$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define IS_EQ?
</span></span><span style=display:flex><span>  (lambda (m)
</span></span><span style=display:flex><span>    (lambda (n)
</span></span><span style=display:flex><span>      (AND (IS_LEQ? m n) (IS_LEQ? n m)))))
</span></span></code></pre></div><p>另一种思路是：$m=n$ 当且仅当 $m-n=0$ 且 $n-m=0$。所以 $(\text{SUB } m n)$ 和 $(\text{SUB } n m)$ 都必须是 <code>ZERO</code>。</p></li><li><p><strong>小于 (<code>IS_LT?</code>)</strong>: $m &lt; n$ 当且仅当 $n > m$。
$$ \text{IS_LT?} := \lambda m . \lambda n . \text{IS_GT?}\ n \ m $$
或者 $m &lt; n$ 当且仅当 $m \not\ge n$ (即 $\neg(n \le m)$)。
$$ \text{IS_LT?}_{\text{alt}} := \lambda m . \lambda n . \text{NOT} \ (\text{IS_LEQ?}\ n \ m) $$</p></li><li><p><strong>大于或等于 (<code>IS_GEQ?</code>)</strong>: $m \ge n$ 当且仅当 $n \le m$。
$$ \text{IS_GEQ?} := \lambda m . \lambda n . \text{IS_LEQ?}\ n \ m $$</p></li></ol><p>通过这些定义，我们已经构建了一套完整的基于丘奇编码的自然数关系运算。</p><h4 id=一点关于时间复杂度分析与计算模型的声明>一点关于时间复杂度分析与计算模型的声明<a hidden class=anchor aria-hidden=true href=#一点关于时间复杂度分析与计算模型的声明>#</a></h4><p>我们发现，刚刚实现的算术运算（尤其是乘法、前驱、减法）的过程，如果完全展开成 $\beta$-规约，其步骤数会相当可观，效率较低。但是，$\lambda$ 演算主要是一个用于研究计算理论、证明计算完备性的数学工具，其直接实现的效率并非首要考量。在实际编程中，我们当然会使用硬件直接支持的、高度优化的原生数字类型和运算。</p><p>如果追求“高效的算术”，我们可以探索例如二进制表示的丘奇数。不过，这会引入显著的复杂性，超出了本文旨在演示如何用 $\lambda$ 演算构建一个完备计算体系的目标。</p><p>与此相对，我们将采取另一种视角。正如我们在前文“一层又一层抽象”中所讨论的，为了能够清晰地构建和分析更复杂的算法，我们将把这些已经定义的丘奇编码实体（如 <code>ZERO</code>, <code>PLUS</code>, <code>IF-THEN-ELSE</code>, <code>PRED</code>, <code>SUB</code>, <code>IS_LEQ?</code> 等）视为我们新的<strong>抽象原语 (abstract primitives)</strong>。</p><p>在后续的算法讨论和复杂度分析中，除非特别指出，我们将假设对这些抽象原语的一次调用（例如，执行一次 <code>(PLUS church_num1 church_num2)</code> 或一次 <code>(IS_LEQ? church_num1 church_num2))</code>) 构成一个基本计算步骤，其开销计为常数时间 $O(1)$（或者说，我们统计的是这些高级原语被调用的次数）。</p><p>这样做使我们能够专注于算法本身的逻辑和结构，而不必每次都回溯到底层的 $\lambda$-规约。这与我们在高级编程语言中分析算法时，将整数加法或比较视为 $O(1)$ 操作的做法是相通的。</p><hr><p>我们还缺乏一种重要的算术运算：除法。但是它的实现比较复杂，需要一些额外的工具。在下一节中，我们将引入这些必要的工具。</p><h2 id=递归让函数调用自身>递归：让函数调用自身<a hidden class=anchor aria-hidden=true href=#递归让函数调用自身>#</a></h2><p>到目前为止，我们已经用 λ 演算构建了布尔逻辑、自然数、算术运算乃至简单的数据结构（丘奇对）。然而，你可能已经敏锐地注意到，我们似乎还缺少一个在编程中至关重要的工具：<strong>循环或迭代</strong>。我们用丘奇数 <code>n</code> 实现了将某个操作重复 <code>n</code> 次，但这更像是一个固定次数的 <code>for</code> 循环。对于更一般的情况，比如“当条件满足时重复执行某个操作”（类似 <code>while</code> 循环），或者像阶乘那样需要根据输入值决定计算深度的场景，我们目前的工具还不够。</p><p>在大多数编程语言中，这类重复性的任务通常通过递归（函数调用自身）或循环结构（<code>for</code>, <code>while</code>）来解决。循环结构本质上也可以看作是递归的一种特定模式或语法糖。因此，关键在于如何在 λ 演算这个纯粹的函数世界中实现递归。</p><p>让我们先看看在 Scheme 中，递归是如何轻易实现的。比如，计算阶乘的函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define (factorial n)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>=</span> n <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>*</span> n (factorial (<span style=color:#a6e22e>-</span> n <span style=color:#ae81ff>1</span>)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(factorial <span style=color:#ae81ff>5</span>) <span style=color:#75715e>; 计算结果为 120</span>
</span></span></code></pre></div><p>在这里，<code>define</code> 允许我们将函数命名为 <code>factorial</code>，然后在 <code>factorial</code> 的函数体内部，我们可以再次通过这个名字 <code>factorial</code> 来调用它自身。</p><p>但问题来了：在纯粹的 λ 演算中，函数通常是<strong>匿名</strong>的。回忆一下，我们定义的 <code>TRUE</code>、<code>ZERO</code>、<code>PLUS</code> 等都是 <code>(lambda (...) ...)</code> 这样的匿名函数，只是为了方便讨论，我们才用 <code>define</code> 给它们起了名字。如果一个函数没有名字，它如何在自己的定义中引用自己呢？这就好比写一封匿名信，却想在信的内容里提及“写这封信的我”——我们该如何指代这个匿名的“我”？</p><p>这正是 λ 演算实现递归所面临的核心挑战。我们需要一种方法，让一个匿名函数能够获得对自身的引用。</p><h3 id=手动实现递归将函数作为参数传递>“手动”实现递归：将函数作为参数传递<a hidden class=anchor aria-hidden=true href=#手动实现递归将函数作为参数传递>#</a></h3><p>一种直观的想法是：如果一个函数 <code>g</code> 需要调用自身，我们可以修改 <code>g</code> 的定义，让它多接受一个参数，这个参数就是 <code>g</code> 自身（或者一个行为与 <code>g</code> 等同的函数）。
让我们尝试为一个“准阶乘函数”<code>almost-factorial</code> 这样做。这个 <code>almost-factorial</code> 期望接收一个 <code>self</code> 参数（代表它自己）和一个数字 <code>n</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define almost-factorial
</span></span><span style=display:flex><span>  (lambda (self n) <span style=color:#75715e>; self 是期望中的递归调用</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>=</span> n <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>*</span> n (self self (<span style=color:#a6e22e>-</span> n <span style=color:#ae81ff>1</span>)))))) <span style=color:#75715e>; 注意这里：用 (self self ...) 来进行递归调用</span>
</span></span></code></pre></div><p>要使用它，我们需要某种方式把 <code>almost-factorial</code> 这个函数本身传递给它自己的第一个参数 <code>self</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(almost-factorial almost-factorial <span style=color:#ae81ff>5</span>) <span style=color:#75715e>; 结果是 120</span>
</span></span></code></pre></div><p>这种模式 <code>(f f x)</code> 有一个专门的名字，叫做 <strong>U 组合子</strong>（或模拟 U 组合子的行为），即 <code>U f = f f</code>。我们通过 <code>(almost-factorial almost-factorial ...)</code> 使得 <code>almost-factorial</code> 的第一个参数 <code>self</code> 确实是 <code>almost-factorial</code> 本身。在 <code>almost-factorial</code> 内部，当它需要递归调用时，它就调用 <code>(self self (- n 1))</code>，这实际上又变回了 <code>(almost-factorial almost-factorial (- n 1))</code>，递归得以实现！</p><p>这种“将函数自身作为参数传递给自身”的技巧虽然可行，但每次调用时都需要重复写 <code>(f f x)</code> 这样的结构，显得有些笨拙。我们更希望有一个“魔法函数”，能够自动帮我们处理这种“自我引用”的传递。</p><h3 id=不动点组合子y-组合子与-z-组合子>不动点组合子：Y 组合子与 Z 组合子<a hidden class=anchor aria-hidden=true href=#不动点组合子y-组合子与-z-组合子>#</a></h3><p>这个“魔法函数”就是<strong>不动点组合子 (Fixed-Point Combinator)</strong>。在数学中，函数 <code>f</code> 的一个不动点 <code>x</code> 是指满足 <code>f(x) = x</code> 的点。在计算理论中，递归函数可以被看作是某个高阶函数的不动点。</p><p>假设我们有一个函数生成器 <code>G</code>。<code>G</code> 接受一个函数 <code>h</code>（代表递归调用）作为参数，并返回一个新的函数，这个新函数就是我们想要定义的递归函数的“单步版本”。例如，对于阶乘，<code>G</code> 可以这样定义（这里暂时借用 Scheme 的数字和运算以便理解）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define G-factorial
</span></span><span style=display:flex><span>  (lambda (h)          <span style=color:#75715e>; h 是用于递归调用的函数 (即阶乘函数本身)</span>
</span></span><span style=display:flex><span>    (lambda (n)        <span style=color:#75715e>; 返回的是阶乘函数的一步</span>
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>=</span> n <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>*</span> n (h (<span style=color:#a6e22e>-</span> n <span style=color:#ae81ff>1</span>))))))) <span style=color:#75715e>; 这里用 h 来进行递归调用</span>
</span></span></code></pre></div><p>我们希望找到一个函数 <code>factorial</code>，使得 <code>factorial</code> 等价于 <code>(G-factorial factorial)</code>。也就是说，<code>factorial</code> 是 <code>G-factorial</code> 这个高阶函数的不动点。</p><p><strong>Y 组合子</strong>正是这样一个神奇的函数，它能为任何给定的函数生成器 <code>G</code> 找到其不动点。即 <code>(Y G)</code> 会产生一个函数 <code>f_rec</code>，这个 <code>f_rec</code> 满足 <code>f_rec = (G f_rec)</code>。
Y 组合子的经典定义是：
$$ Y := \lambda g . (\lambda x . g (x \ x)) (\lambda x . g (x \ x)) $$
在 Scheme 中表示为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define Y
</span></span><span style=display:flex><span>  (lambda (g)
</span></span><span style=display:flex><span>    ((lambda (x) (g (x x)))
</span></span><span style=display:flex><span>     (lambda (x) (g (x x))))))
</span></span></code></pre></div><p>于是，<code> (Y G-factorial)</code> 就会是上面我们用 <code>define</code> 直接定义的那个 <code>factorial</code> 函数！我们不再需要在调用时手动传递 <code>factorial</code> 给自身了，Y 组合子帮我们完成了这个绑定。</p><hr><p><strong>补充：Y 组合子如何工作：不动点属性的推导</strong></p><p>Y 组合子的神奇之处在于它如何构造出这个不动点。让我们手动展开 <code>(Y G)</code> 的求值过程（使用 β-规约）来看看它是如何工作的。</p><p>回顾 Y 组合子的定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define Y
</span></span><span style=display:flex><span>  (lambda (g)
</span></span><span style=display:flex><span>    ((lambda (x) (g (x x)))    <span style=color:#75715e>; 我们将这个内部的 (lambda (x) ...) 称为 omega-maker</span>
</span></span><span style=display:flex><span>     (lambda (x) (g (x x)))))) <span style=color:#75715e>; 这是传递给 omega-maker 的参数，形式与 omega-maker 自身相同</span>
</span></span></code></pre></div><p>为了方便推导，我们定义一个辅助函数 <code>omega_g</code> (或者叫 <code>make-omega-for-g</code>)，它依赖于 <code>g</code>：
<code>omega_g := (lambda (x) (g (x x)))</code></p><p>那么，Y 组合子可以看作是：
<code>Y := (lambda (g) (omega_g omega_g))</code></p><p>现在，我们将 Y 应用于我们的函数生成器 <code>G</code>：
<code>(Y G)</code>
根据 Y 的定义，这会进行一次 β-规约，将 <code>G</code> 替换掉 Y 定义中的 <code>g</code>：
<code>(Y G) evaluates-to (omega_G omega_G)</code>
这里 <code>omega_G</code> 就是 <code>(lambda (x) (G (x x)))</code> (即把 <code>g</code> 换成了具体的 <code>G</code>)。</p><p>接下来，我们来看 <code>(omega_G omega_G)</code> 是什么：
<code>(omega_G omega_G)</code>
<code>= ((lambda (x) (G (x x))) omega_G)</code> (将第一个 <code>omega_G</code> 展开)</p><p>现在，我们再次进行 β-规约：将 <code>omega_G</code> 这个实际参数替换掉 <code>(lambda (x) ...)</code> 中的形式参数 <code>x</code>。
<code>((lambda (x) (G (x x))) omega_G)</code>
<code>evaluates-to (G (omega_G omega_G))</code></p><p>我们得到了：</p><ol><li><code>(Y G) = (omega_G omega_G)</code></li><li><code>(omega_G omega_G) = (G (omega_G omega_G))</code></li></ol><p>综合这两步，我们可以通过代换得到：
<code>(Y G) = (G (omega_G omega_G))</code></p><p>现在，注意到等式右边的 <code>(omega_G omega_G)</code> 正是我们在第一步中定义的 <code>(Y G)</code>！
所以，我们可以将 <code>(Y G)</code> 代换回去：
<code>(Y G) = (G (Y G))</code></p><p>这正是我们期望的不动点属性！ <code>(Y G)</code> 这个表达式本身（我们称之为 <code>f_rec</code>）等于将 <code>G</code> 应用于 <code>(Y G)</code>（即 <code>(G f_rec)</code>）。Y 组合子通过这种巧妙的自我应用结构，成功地为一个“期望接收自身作为参数”的函数生成器 <code>G</code> 创造了一个可以直接调用的递归函数 <code>(Y G)</code>，而这个递归函数 <code>(Y G)</code> 确实是 <code>G</code> 的不动点。</p><p>这就是为什么 Y 组合子能够在纯 λ 演算中实现递归的魔力所在。它构建了一个表达式，该表达式在求值时会“展开”成将生成器 <code>G</code> 应用于该表达式自身的形式。</p><hr><p>然而，Y 组合子的这个经典定义在严格求值/应用序求值（Applicative Order Evaluation，即函数参数在函数体执行前就被完全求值）的语言（如 Scheme）中直接使用时会遇到问题：<code>(x x)</code> 这一部分会导致无限递归求值，从而使程序无法终止。</p><p>为了解决这个问题，在应用序求值语言中，我们通常使用 <strong>Z 组合子</strong>，它是 Y 组合子的一个变体，通过引入一个额外的 <code>lambda</code> 来延迟 <code>(x x)</code> 的求值：
$$ Z := \lambda g . (\lambda x . g (\lambda v . ((x \ x) v))) (\lambda x . g (\lambda v . ((x \ x) v))) $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define Z
</span></span><span style=display:flex><span>  (lambda (g)
</span></span><span style=display:flex><span>    ((lambda (x) (g (lambda (v) ((x x) v))))
</span></span><span style=display:flex><span>     (lambda (x) (g (lambda (v) ((x x) v)))))))
</span></span></code></pre></div><p>现在，我们可以用 Z 组合子和我们之前定义的 <code>G-factorial</code> 来构造阶乘函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define factorial-via-Z (Z G-factorial))
</span></span><span style=display:flex><span>(factorial-via-Z <span style=color:#ae81ff>5</span>) <span style=color:#75715e>; 计算结果为 120</span>
</span></span></code></pre></div><p>这里，<code>factorial-via-Z</code> 就是一个完全由 λ 演算（加上 Z 组合子）构造出来的递归阶乘函数。在纯 λ 演算的语境下，<code>G-factorial</code> 中的 <code>if</code>、<code>=</code>、<code>0</code>、<code>1</code>、<code>*</code>、<code>-</code> 当然也需要用我们之前讨论过的丘奇编码来定义。</p><p>不动点组合子（如 Y 或 Z）是 λ 演算中一个深刻而强大的概念。它们揭示了即使在这样一个极简的系统中，我们也能通过纯粹的函数抽象和应用来构建出递归这一复杂的控制结构。这为 λ 演算的图灵完备性提供了关键的一环，也意味着我们几乎拥有了构建任何可计算过程所需的所有理论工具。</p><p>有了递归，我们的 λ 演算工具箱才算真正强大起来，能够去定义和执行那些需要自我参照和重复计算的复杂算法了。</p><p>我们很快就会看到它们的威力。在下一节中，我们将应用它们来构造之前我们暂时搁置的算术逻辑：除法。</p><h3 id=更进一步的算术除法-div>更进一步的算术：除法 (<code>DIV</code>)<a hidden class=anchor aria-hidden=true href=#更进一步的算术除法-div>#</a></h3><p>在构建了加法、减法和乘法之后，自然会想到四则运算的最后一个基本操作：<strong>除法</strong>。我们将在这里实现整数除法，即计算 $m \div n$ 的商 $q$。</p><p>与加法和乘法不同，除法的计算过程（重复从被除数中减去约数，直到余数小于约数）通常不依赖于一个固定的、由输入数字直接决定的迭代次数。这暗示了我们需要使用递归来实现它。</p><h4 id=除法的核心逻辑重复减法与递归>除法的核心逻辑：重复减法与递归<a hidden class=anchor aria-hidden=true href=#除法的核心逻辑重复减法与递归>#</a></h4><p>整数除法 $m \div n$ 的商 $q$ 可以通过以下递归过程找到：</p><ol><li><strong>基本情况</strong>：如果 $m &lt; n$，那么我们无法再从中减去 $n$ 了，此时累积的商就是最终结果。</li><li><strong>递归步骤</strong>：如果 $m \ge n$，那么我们可以从 $m$ 中减去一个 $n$，然后对新的 $m&rsquo; = m-n$ 和原始的 $n$ 再次进行除法过程，同时将累积的商加一。</li></ol><p>我们需要一个辅助的递归函数，它会跟踪当前的被除数、原始的除数以及到目前为止累积的商。</p><h4 id=构造除法的递归辅助函数生成器-g_div_loop>构造除法的递归辅助函数生成器 (<code>G_DIV_LOOP</code>)<a hidden class=anchor aria-hidden=true href=#构造除法的递归辅助函数生成器-g_div_loop>#</a></h4><p>让我们定义一个函数生成器 <code>G_DIV_LOOP</code>。它接受一个参数 <code>self_div_loop</code>（代表递归调用自身），并返回一个执行单步除法逻辑的函数。这个单步函数接受三个参数：</p><ul><li><code>current_m</code>：当前的被除数。</li><li><code>original_n</code>：原始的（保持不变的）除数。</li><li><code>current_q</code>：到目前为止累积的商。</li></ul><p>$$
\begin{aligned}
\text{G_DIV_LOOP} := \lambda \text{self_div_loop} . \lambda \text{current_m} . \lambda \text{original_n} . \lambda \text{current_q} . \
\quad (\text{IS_LT?} \ \text{current_m} \ \text{original_n}) \
\quad \quad \text{current_q} \
\quad \quad (\text{self_div_loop} \ (\text{SUB} \ \text{current_m} \ \text{original_n}) \ \text{original_n} \ (\text{S} \ \text{current_q}))
\end{aligned}
$$
在 Scheme 中（使用我们之前定义的 <code>IF-THEN-ELSE</code> 的等价结构，即丘奇布尔值直接作为选择器）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define G_DIV_LOOP
</span></span><span style=display:flex><span>  (lambda (self_div_loop)
</span></span><span style=display:flex><span>    (lambda (current_m)
</span></span><span style=display:flex><span>      (lambda (original_n)
</span></span><span style=display:flex><span>        (lambda (current_q)
</span></span><span style=display:flex><span>          ((IS_LT? current_m original_n) <span style=color:#75715e>; If current_m &lt; original_n</span>
</span></span><span style=display:flex><span>           current_q                     <span style=color:#75715e>; Then: return current_q</span>
</span></span><span style=display:flex><span>           (self_div_loop (SUB current_m original_n) <span style=color:#75715e>; Else: recurse</span>
</span></span><span style=display:flex><span>                          original_n
</span></span><span style=display:flex><span>                          (S current_q))))))))
</span></span></code></pre></div><p>这里我们使用了之前定义的 <code>IS_LT?</code> (小于)，<code>SUB</code> (截断减法)，和 <code>S</code> (后继函数)。</p><h4 id=使用-z-组合子实现递归循环>使用 Z 组合子实现递归循环<a hidden class=anchor aria-hidden=true href=#使用-z-组合子实现递归循环>#</a></h4><p>现在，我们可以使用 Z 组合子来从 <code>G_DIV_LOOP</code> 生成实际的递归辅助函数 <code>DIV_LOOP</code>：
$$ \text{DIV_LOOP} := \text{Z} \ \text{G_DIV_LOOP} $$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define DIV_LOOP (Z G_DIV_LOOP))
</span></span></code></pre></div><p><code>DIV_LOOP</code> 现在是一个柯里化的函数，它接受 <code>current_m</code>、<code>original_n</code> 和 <code>current_q</code>，并递归地计算直到 <code>current_m &lt; original_n</code>。</p><h4 id=定义主除法函数-div>定义主除法函数 <code>DIV</code><a hidden class=anchor aria-hidden=true href=#定义主除法函数-div>#</a></h4><p>主除法函数 <code>DIV</code> 将接受两个参数：被除数 <code>m</code> 和除数 <code>n</code>。它会调用 <code>DIV_LOOP</code>，并将初始商设为 <code>ZERO</code>。
$$ \text{DIV} := \lambda m . \lambda n . (\text{DIV_LOOP} \ m \ n \ \text{ZERO}) $$
在 Scheme 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define DIV
</span></span><span style=display:flex><span>  (lambda (m)
</span></span><span style=display:flex><span>    (lambda (n)
</span></span><span style=display:flex><span>      (DIV_LOOP m n ZERO))))
</span></span></code></pre></div><p><strong>注意：</strong> 此定义假设除数 <code>n</code> 不为 <code>ZERO</code>。如果 <code>n</code> 是 <code>ZERO</code> (且 <code>m</code> 非 <code>ZERO</code>)，<code> (IS_LT? current_m ZERO)</code> 永远为假，而 <code>(SUB current_m ZERO)</code> 结果仍是 <code>current_m</code>，这将导致无限递归（不终止）。</p><h4 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h4><p>让我们尝试计算 <code>(DIV SIX TWO)</code>（假设 <code>SIX</code> 是丘奇数 6，<code>TWO</code> 是丘奇数 2）：</p><ol><li><code>(DIV_LOOP SIX TWO ZERO)</code><ul><li><code>IS_LT? SIX TWO</code> 为 <code>FALSE</code>。</li><li>递归调用 <code>(DIV_LOOP (SUB SIX TWO) TWO (S ZERO))</code> 即 <code>(DIV_LOOP FOUR TWO ONE)</code>。</li></ul></li><li><code>(DIV_LOOP FOUR TWO ONE)</code><ul><li><code>IS_LT? FOUR TWO</code> 为 <code>FALSE</code>。</li><li>递归调用 <code>(DIV_LOOP (SUB FOUR TWO) TWO (S ONE))</code> 即 <code>(DIV_LOOP TWO TWO TWO)</code>。</li></ul></li><li><code>(DIV_LOOP TWO TWO TWO)</code><ul><li><code>IS_LT? TWO TWO</code> 为 <code>FALSE</code> (因为 <code>TWO</code> 不小于 <code>TWO</code>)。</li><li>递归调用 <code>(DIV_LOOP (SUB TWO TWO) TWO (S TWO))</code> 即 <code>(DIV_LOOP ZERO TWO THREE)</code>。</li></ul></li><li><code>(DIV_LOOP ZERO TWO THREE)</code><ul><li><code>IS_LT? ZERO TWO</code> 为 <code>TRUE</code>。</li><li>返回当前的商 <code>THREE</code>。</li></ul></li></ol><p>因此，<code>(DIV SIX TWO)</code> 的结果是 <code>THREE</code>，这符合预期。</p><p>同样，<code>(DIV SEVEN THREE)</code> 会返回 <code>TWO</code>。</p><h4 id=获取余数-remainder-可选扩展>获取余数 (Remainder) (可选扩展)<a hidden class=anchor aria-hidden=true href=#获取余数-remainder-可选扩展>#</a></h4><p>上面的 <code>DIV</code> 函数只返回商。如果我们也想得到余数，该怎么办呢？
余数其实就是在递归的<strong>基本情况</strong>下（即当 <code>current_m &lt; original_n</code> 时）的 <code>current_m</code> 的值。</p><p>我们可以修改 <code>G_DIV_LOOP</code>，使其返回一个包含商和余数的<strong>丘奇对 <code>(CONS quotient remainder)</code></strong>。</p><p>$$
\begin{aligned}
\text{G_DIV_REM_LOOP} := \lambda \text{self_div_loop} . \lambda \text{current_m} . \lambda \text{original_n} . \lambda \text{current_q} . \
\quad (\text{IS_LT?} \ \text{current_m} \ \text{original_n}) \
\quad \quad (\text{CONS} \ \text{current_q} \ \text{current_m}) \
\quad \quad (\text{self_div_loop} \ (\text{SUB} \ \text{current_m} \ \text{original_n}) \ \text{original_n} \ (\text{S} \ \text{current_q}))
\end{aligned}
$$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define G_DIV_REM_LOOP
</span></span><span style=display:flex><span>  (lambda (self_div_loop)
</span></span><span style=display:flex><span>    (lambda (current_m)
</span></span><span style=display:flex><span>      (lambda (original_n)
</span></span><span style=display:flex><span>        (lambda (current_q)
</span></span><span style=display:flex><span>          ((IS_LT? current_m original_n)
</span></span><span style=display:flex><span>           (CONS current_q current_m) <span style=color:#75715e>; 返回 (商, 余数)</span>
</span></span><span style=display:flex><span>           (self_div_loop (SUB current_m original_n)
</span></span><span style=display:flex><span>                          original_n
</span></span><span style=display:flex><span>                          (S current_q))))))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(define DIV_REM_LOOP (Z G_DIV_REM_LOOP))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(define DIV_AND_REMAINDER
</span></span><span style=display:flex><span>  (lambda (m)
</span></span><span style=display:flex><span>    (lambda (n)
</span></span><span style=display:flex><span>      (DIV_REM_LOOP m n ZERO))))
</span></span></code></pre></div><p>然后，我们可以定义分别获取商和余数的函数：
$$ \text{QUOTIENT} := \lambda m . \lambda n . \text{CAR} \ (\text{DIV_AND_REMAINDER} \ m \ n) $$
$$ \text{REMAINDER} := \lambda m . \lambda n . \text{CDR} \ (\text{DIV_AND_REMAINDER} \ m \ n) $$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(define QUOTIENT
</span></span><span style=display:flex><span>  (lambda (m)
</span></span><span style=display:flex><span>    (lambda (n)
</span></span><span style=display:flex><span>      (CAR (DIV_AND_REMAINDER m n)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(define REMAINDER
</span></span><span style=display:flex><span>  (lambda (m)
</span></span><span style=display:flex><span>    (lambda (n)
</span></span><span style=display:flex><span>      (CDR (DIV_AND_REMAINDER m n)))))
</span></span></code></pre></div><p>例如，<code>(DIV_AND_REMAINDER SEVEN THREE)</code> 会返回一个序对，其中 <code>CAR</code> 是 <code>TWO</code> (商)，<code>CDR</code> 是 <code>ONE</code> (余数)。</p><p>通过这种方式，我们利用递归和之前构建的算术及逻辑原语，成功地扩展了我们的 $\lambda$ 演算计算体系，使其包含了基本的除法运算。这进一步展示了该计算模型的图灵完备性。</p><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>在上文中，我们已经成功地用 λ 演算构建了基本的计算逻辑、自然数算术以及强大的递归机制。这为我们打开了通往更广阔计算世界的大门。</p><p>在实际的编程中，除了原始的数据类型和运算，我们还需要各种<strong>数据结构</strong>来有效地组织和管理信息，例如链表、栈、队列、树、图、哈希表等等。没有这些，许多复杂的算法都将无从谈起。</p><p>利用我们已经掌握的丘奇对 (可以看作是构造其他数据结构的基础单元) 和递归思想，我们完全有能力在纯 λ 演算的框架内逐步构建出这些复杂的数据结构。</p><p>例如，<strong>链表 (Linked List)</strong> 作为最基础也最常用的数据结构之一，它与 λ 演算的递归特性天然契合。我们可以设想用嵌套的丘奇对来表示链表节点，其中每个节点包含一个数据元素和一个指向下一个节点的“指针”（即另一个链表或代表列表末尾的特殊值）。</p><pre tabindex=0><code>(define MY-NIL (lambda (f) (lambda (x) x))) ; 例如，用 ZERO 或一个特定的选择函数代表空列表
(define MY-CONS CONS) ; 丘奇对就是我们的 cons
(define MY-CAR CAR)
(define MY-CDR CDR)

; 一个包含 1, 2, 3 的列表可以表示为：
; (MY-CONS ONE (MY-CONS TWO (MY-CONS THREE MY-NIL)))
</code></pre><p>对这些数据结构的操作（如插入、删除、查找、遍历）也都可以通过定义相应的 λ 函数来实现，这些函数通常会利用递归来处理链表的递归定义。</p><p>由于篇幅和精力的限制，本文不再详细展开这些数据结构的具体实现。但我们强烈鼓励充满好奇心的读者，以本文介绍的原理和方法为基础，亲自动手尝试去构建它们。这将会是一段极具启发性和挑战性的旅程，能让你更深刻地理解计算的构造性和 λ 演算的强大威力。</p><p>同样，对于数系的扩展，例如从自然数到整数（如何表示负数？）、再到有理数（如何表示分数并进行运算？），甚至是实数的某些计算特性，也都是值得探索的领域。</p><p>希望本文能为你打开一扇窗，让你窥见计算世界最纯粹、最本源的构造之美。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/plt/>PLT</a></li><li><a href=https://litjohn.github.io/tags/lisp/scheme/racket/>Lisp/Scheme/Racket</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>litjohn's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>