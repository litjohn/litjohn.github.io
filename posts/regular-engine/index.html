<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Regular Engine | 正确即是废话，废话亦是正确</title><meta name=keywords content="lisp/scheme/racket,algorithms"><meta name=description content="
亲手实现一个正则引擎！
众所周知，一类经典的自动机是有限状态自动机。它们识别的语言是正则语言，而正则表达式能够匹配的字符串的集合也是正则语言。
（如果你之前没有了解过，询问 AI 或是使用搜索引擎都很适合快速了解）
导数法
要匹配一个正则表达式，最经典的方法就是构造对应的 NFA，然后通过一些手法转化为 DFA。但这太复杂了。有没有更简单的方法呢？
有一种被称为“导数法”的方法。
思想非常简单：我们将构造出的 DFA 编码为一个正则。这样，转移之后相当于产生了一个新的自动机，也就是一个新的正则表达式。
原始正则表达式是 $r$。那么，$r$“吃掉”一个字符 $c$ 之后产生的表达式 $r'$，能匹配的所有字符串就是所有满足 (match? (cat c s) r) 的字符串 $s$。
读者可以自行思考一下导数公式。

我想用代码表示是最清晰的。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


(define (derive re c)
  (match re
    [(Void) (Void)]
    [(Eps) (Void)]
    [(Dot) (Eps)]
    [(Chr ch) (if (char=? ch c) (Eps) (Void))]
    [(Alt e1 e2)
     (make-alt (derive e1 c) (derive e2 c))]
    [(Cat e1 e2)
     (if (nullable? e1)
         (make-alt (make-cat (derive e1 c) e2) (derive e2 c))
         (make-cat (derive e1 c) e2))]
    [(Star e)
     (make-cat (derive e c) (Star e))]))


导数法将是我们使用的核心算法。
特性与抽象语法
我们将实现支持连接（cat），选择（alt）与闭包（kleene star）三种特性的正则表达式。同时添加“任意字符”（Dot）这种有用的语法糖（为了辅助包含匹配）。"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/regular-engine/><link crossorigin=anonymous href=/assets/css/stylesheet.b915ce98f9f65cca5e346b24fc336009b3608a3eeb24ce4b0e53c4500eba9374.css integrity="sha256-uRXOmPn2XMpeNGsk/DNgCbNgij7rJM5LDlPEUA66k3Q=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/regular-engine/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/regular-engine/"><meta property="og:site_name" content="正确即是废话，废话亦是正确"><meta property="og:title" content="Regular Engine"><meta property="og:description" content=" 亲手实现一个正则引擎！
众所周知，一类经典的自动机是有限状态自动机。它们识别的语言是正则语言，而正则表达式能够匹配的字符串的集合也是正则语言。
（如果你之前没有了解过，询问 AI 或是使用搜索引擎都很适合快速了解）
导数法 要匹配一个正则表达式，最经典的方法就是构造对应的 NFA，然后通过一些手法转化为 DFA。但这太复杂了。有没有更简单的方法呢？
有一种被称为“导数法”的方法。
思想非常简单：我们将构造出的 DFA 编码为一个正则。这样，转移之后相当于产生了一个新的自动机，也就是一个新的正则表达式。
原始正则表达式是 $r$。那么，$r$“吃掉”一个字符 $c$ 之后产生的表达式 $r'$，能匹配的所有字符串就是所有满足 (match? (cat c s) r) 的字符串 $s$。
读者可以自行思考一下导数公式。
我想用代码表示是最清晰的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 (define (derive re c) (match re [(Void) (Void)] [(Eps) (Void)] [(Dot) (Eps)] [(Chr ch) (if (char=? ch c) (Eps) (Void))] [(Alt e1 e2) (make-alt (derive e1 c) (derive e2 c))] [(Cat e1 e2) (if (nullable? e1) (make-alt (make-cat (derive e1 c) e2) (derive e2 c)) (make-cat (derive e1 c) e2))] [(Star e) (make-cat (derive e c) (Star e))])) 导数法将是我们使用的核心算法。
特性与抽象语法 我们将实现支持连接（cat），选择（alt）与闭包（kleene star）三种特性的正则表达式。同时添加“任意字符”（Dot）这种有用的语法糖（为了辅助包含匹配）。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-03T09:06:20+08:00"><meta property="article:modified_time" content="2026-01-03T09:06:20+08:00"><meta property="article:tag" content="Lisp/Scheme/Racket"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="Regular Engine"><meta name=twitter:description content="
亲手实现一个正则引擎！
众所周知，一类经典的自动机是有限状态自动机。它们识别的语言是正则语言，而正则表达式能够匹配的字符串的集合也是正则语言。
（如果你之前没有了解过，询问 AI 或是使用搜索引擎都很适合快速了解）
导数法
要匹配一个正则表达式，最经典的方法就是构造对应的 NFA，然后通过一些手法转化为 DFA。但这太复杂了。有没有更简单的方法呢？
有一种被称为“导数法”的方法。
思想非常简单：我们将构造出的 DFA 编码为一个正则。这样，转移之后相当于产生了一个新的自动机，也就是一个新的正则表达式。
原始正则表达式是 $r$。那么，$r$“吃掉”一个字符 $c$ 之后产生的表达式 $r'$，能匹配的所有字符串就是所有满足 (match? (cat c s) r) 的字符串 $s$。
读者可以自行思考一下导数公式。

我想用代码表示是最清晰的。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


(define (derive re c)
  (match re
    [(Void) (Void)]
    [(Eps) (Void)]
    [(Dot) (Eps)]
    [(Chr ch) (if (char=? ch c) (Eps) (Void))]
    [(Alt e1 e2)
     (make-alt (derive e1 c) (derive e2 c))]
    [(Cat e1 e2)
     (if (nullable? e1)
         (make-alt (make-cat (derive e1 c) e2) (derive e2 c))
         (make-cat (derive e1 c) e2))]
    [(Star e)
     (make-cat (derive e c) (Star e))]))


导数法将是我们使用的核心算法。
特性与抽象语法
我们将实现支持连接（cat），选择（alt）与闭包（kleene star）三种特性的正则表达式。同时添加“任意字符”（Dot）这种有用的语法糖（为了辅助包含匹配）。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Regular Engine","item":"https://litjohn.github.io/posts/regular-engine/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Regular Engine","name":"Regular Engine","description":" 亲手实现一个正则引擎！\n众所周知，一类经典的自动机是有限状态自动机。它们识别的语言是正则语言，而正则表达式能够匹配的字符串的集合也是正则语言。\n（如果你之前没有了解过，询问 AI 或是使用搜索引擎都很适合快速了解）\n导数法 要匹配一个正则表达式，最经典的方法就是构造对应的 NFA，然后通过一些手法转化为 DFA。但这太复杂了。有没有更简单的方法呢？\n有一种被称为“导数法”的方法。\n思想非常简单：我们将构造出的 DFA 编码为一个正则。这样，转移之后相当于产生了一个新的自动机，也就是一个新的正则表达式。\n原始正则表达式是 $r$。那么，$r$“吃掉”一个字符 $c$ 之后产生的表达式 $r'$，能匹配的所有字符串就是所有满足 (match? (cat c s) r) 的字符串 $s$。\n读者可以自行思考一下导数公式。\n我想用代码表示是最清晰的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (define (derive re c) (match re [(Void) (Void)] [(Eps) (Void)] [(Dot) (Eps)] [(Chr ch) (if (char=? ch c) (Eps) (Void))] [(Alt e1 e2) (make-alt (derive e1 c) (derive e2 c))] [(Cat e1 e2) (if (nullable? e1) (make-alt (make-cat (derive e1 c) e2) (derive e2 c)) (make-cat (derive e1 c) e2))] [(Star e) (make-cat (derive e c) (Star e))])) 导数法将是我们使用的核心算法。\n特性与抽象语法 我们将实现支持连接（cat），选择（alt）与闭包（kleene star）三种特性的正则表达式。同时添加“任意字符”（Dot）这种有用的语法糖（为了辅助包含匹配）。\n","keywords":["lisp/scheme/racket","algorithms"],"articleBody":" 亲手实现一个正则引擎！\n众所周知，一类经典的自动机是有限状态自动机。它们识别的语言是正则语言，而正则表达式能够匹配的字符串的集合也是正则语言。\n（如果你之前没有了解过，询问 AI 或是使用搜索引擎都很适合快速了解）\n导数法 要匹配一个正则表达式，最经典的方法就是构造对应的 NFA，然后通过一些手法转化为 DFA。但这太复杂了。有没有更简单的方法呢？\n有一种被称为“导数法”的方法。\n思想非常简单：我们将构造出的 DFA 编码为一个正则。这样，转移之后相当于产生了一个新的自动机，也就是一个新的正则表达式。\n原始正则表达式是 $r$。那么，$r$“吃掉”一个字符 $c$ 之后产生的表达式 $r'$，能匹配的所有字符串就是所有满足 (match? (cat c s) r) 的字符串 $s$。\n读者可以自行思考一下导数公式。\n我想用代码表示是最清晰的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (define (derive re c) (match re [(Void) (Void)] [(Eps) (Void)] [(Dot) (Eps)] [(Chr ch) (if (char=? ch c) (Eps) (Void))] [(Alt e1 e2) (make-alt (derive e1 c) (derive e2 c))] [(Cat e1 e2) (if (nullable? e1) (make-alt (make-cat (derive e1 c) e2) (derive e2 c)) (make-cat (derive e1 c) e2))] [(Star e) (make-cat (derive e c) (Star e))])) 导数法将是我们使用的核心算法。\n特性与抽象语法 我们将实现支持连接（cat），选择（alt）与闭包（kleene star）三种特性的正则表达式。同时添加“任意字符”（Dot）这种有用的语法糖（为了辅助包含匹配）。\n使用 S-expression 以及 racket 结构体表达正则：\n1 2 3 4 5 6 7 regexp ::= (Void) | (Eps) | (Chr Char) | (Cat regexp regexp) | (Alt regexp regexp) | (Star regexp) | (Dot) 定义语法树节点：\n1 2 3 4 5 6 7 (struct Eps () #:transparent) ;; 空串 ε (struct Void () #:transparent) ;; 空集 φ (匹配失败) (struct Chr (c) #:transparent) ;; 字符 c (struct Cat (e1 e2) #:transparent) ;; 连接 e1 e2 (struct Alt (e1 e2) #:transparent) ;; 选择 e1 | e2 (struct Star (e) #:transparent) ;; 克林闭包 e* (struct Dot () #:transparent) ;; 语法糖：匹配任意字符 接下来我们要定义 Cat 和 Alt 的构造函数。这很重要，因为其中引入了一些简单的化简。这些化简是防止复杂度退化的重要工具。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (define (make-cat a b) (match* (a b) [((Void) _) (Void)] [(_ (Void)) (Void)] [((Eps) r) r] [(r (Eps)) r] [(_ _) (Cat a b)])) (define (make-alt a b) (match* (a b) [((Void) _) b] [(_ (Void)) a] [(r r) r] [(_ _) (Alt a b)])) 流程设计 导数法是步进式的：给定一个正则和一个字符，返回一个新的正则。所以我们的匹配也是步进式的。\n我们将字符串转换为列表（相当于没有惰性求值的字符流）。然后一个一个吃字符，直到吃完为止。\n这时如何看匹不匹配呢？我们需要一个 nullable? 函数来判断一个正则能否匹配空串。如果字符串结束时的正则是 nullable? 的，则匹配（接受），否则不匹配（拒绝）。\n依然请读者自行思考实现。\n1 2 3 4 5 6 7 8 9 (define (nullable? re) (match re [(Eps) #t] [(Void) #f] [(Dot) #f] [(Chr _) #f] [(Star _) #t] [(Alt a b) (or (nullable? a) (nullable? b))] [(Cat a b) (and (nullable? a) (nullable? b))])) 缓存 有许多正则表达式，它们关于特定字符的后继会被多次计算。这是很大的开销，所以我们用哈希表把它们存起来。\n我们将使用一个二维哈希表，即 Hash Hash regexp\u003e\u003e。\n这样，判定给定字符串是否被给定正则接受就是简单的了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 (define (make-matcher re) (define cache (make-hash)) (define (match-loop cur s) (cond [(null? s) (nullable? cur)] [else (let ([c (car s)]) (define next (hash-ref! (hash-ref! cache cur (lambda () (make-hash))) c (lambda () (derive cur c)))) (if (Void? next) #f (match-loop next (cdr s))))])) (lambda (str) (match-loop re (string-\u003elist str)))) 至此，我们实现了一个基础的正则判定器。同时埋下伏笔。\n匹配 从头到尾扫描并对每个子串暴力判定显然是不好的，就像 brute-force 字符串模式匹配一样。\n要匹配正则在字符串的哪个地方出现了，我们有更精妙的做法。\n辅助正则 1 (define forward (Cat (Star (Dot)) regexp)) 用这个正则去匹配字符串（的前缀），我们就知道原始正则 regexp 在字符串中是否出现过了。\n通过对匹配过程的魔改，我们可以知道辅助正则匹配的第一个（或者最后一个，甚至中间任意一个）字符串前缀是什么。具体而言，对于所有 forward 满足 nullable? 的下标，我们记录其最小值或最大值。\n至于记录最小值还是最大值，决定了匹配行为。我的代码选择了最小值，也就是最左最短匹配。如果要实现贪婪匹配，需要记录最大值。\n我们记被我们记录的那个（能够被辅助正则匹配的）字符串前缀为 S，长度为 E。\n1 (define backward (re-reverse re)) 这是另一个辅助正则。其中，re-reverse 函数用来将一个正则表达式“反转”。即原始正则能匹配的任意字符串反转后都能被它返回的正则匹配，且它返回的正则不能匹配其他任何字符串。\n它的实现在这里：\n1 2 3 4 5 6 (define (re-reverse re) (match re [(Cat e1 e2) (make-cat (re-reverse e2) (re-reverse e1))] [(Alt e1 e2) (make-alt (re-reverse e1) (re-reverse e2))] [(Star e) (Star (re-reverse e))] [_ re])) 二遍扫描 将 S 反转。\n然后用 backward 匹配它（反转后的新字符串）的一个前缀。记长度为 T。\n那么原始正则 regexp 能够匹配的子串（的下标区间）就是 $[E - T, E)$.\n完整代码 精确判定和位置匹配都有一些测试用例。Gemini 写的。有比较好的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 #lang racket (require srfi/13) ;; --------------------------------------------------------- ;; 1. 定义正则表达式的 AST (抽象语法树) ;; --------------------------------------------------------- (struct Eps () #:transparent) ;; 空串 ε (struct Void () #:transparent) ;; 空集 φ (匹配失败) (struct Chr (c) #:transparent) ;; 字符 c (struct Cat (e1 e2) #:transparent) ;; 连接 e1 e2 (struct Alt (e1 e2) #:transparent) ;; 选择 e1 | e2 (struct Star (e) #:transparent) ;; 克林闭包 e* (struct Dot () #:transparent) ;; 语法糖：匹配任意字符 (define (make-cat a b) (match* (a b) [((Void) _) (Void)] [(_ (Void)) (Void)] [((Eps) r) r] [(r (Eps)) r] [(_ _) (Cat a b)])) (define (make-alt a b) (match* (a b) [((Void) _) b] [(_ (Void)) a] [(r r) r] [(_ _) (Alt a b)])) (define (nullable? re) (match re [(Eps) #t] [(Void) #f] [(Dot) #f] [(Chr _) #f] [(Star _) #t] [(Alt a b) (or (nullable? a) (nullable? b))] [(Cat a b) (and (nullable? a) (nullable? b))])) (define (derive re c) (match re [(Void) (Void)] [(Eps) (Void)] [(Dot) (Eps)] [(Chr ch) (if (char=? ch c) (Eps) (Void))] [(Alt e1 e2) (make-alt (derive e1 c) (derive e2 c))] [(Cat e1 e2) (if (nullable? e1) (make-alt (make-cat (derive e1 c) e2) (derive e2 c)) (make-cat (derive e1 c) e2))] [(Star e) (make-cat (derive e c) (Star e))])) (define (make-matcher re) (define cache (make-hash)) (define (match-loop cur s) (cond [(null? s) (nullable? cur)] [else (let ([c (car s)]) (define next (hash-ref! (hash-ref! cache cur (lambda () (make-hash))) c (lambda () (derive cur c)))) (if (Void? next) #f (match-loop next (cdr s))))])) (lambda (str) (match-loop re (string-\u003elist str)))) ;; --------------------------------------------------------- ;; 测试 ;; --------------------------------------------------------- ;; 正则: a(b|c)*d (define my-re (make-cat (Chr #\\a) (make-cat (Star (make-alt (Chr #\\b) (Chr #\\c))) (Chr #\\d)))) (define matches? (make-matcher my-re)) (displayln \"Test Cases:\") (displayln (matches? \"ad\")) ;; #t (displayln (matches? \"abd\")) ;; #t (displayln (matches? \"abccbd\")) ;; #t (displayln (matches? \"add\")) ;; #f (displayln (matches? \"a\")) ;; #f ;; 压力测试：状态缓存机制 ;; 第一次运行会构建缓存，第二次运行直接查表 (time (for ([i 10000]) (matches? \"abcbcd\"))) (define (re-reverse re) (match re [(Cat e1 e2) (make-cat (re-reverse e2) (re-reverse e1))] [(Alt e1 e2) (make-alt (re-reverse e1) (re-reverse e2))] [(Star e) (Star (re-reverse e))] [_ re])) (define (make-search re) (define forward (make-cat (Star (Dot)) re)) (define backward (re-reverse re)) (define cache (make-hash)) (define (match-loop cur s idx) (cond [(nullable? cur) idx] [(\u003e= idx (string-length s)) #f] [else (let ([c (string-ref s idx)]) (define next (hash-ref! (hash-ref! cache cur (lambda () (make-hash))) c (lambda () (derive cur c)))) (if (Void? next) #f (match-loop next s (add1 idx))))])) (lambda (str) (define E (match-loop forward str 0)) (if E (begin (let ([T (match-loop backward (string-reverse str 0 E) 0)]) (cons (- E T) E))) #f))) ;; --------------------------------------------------------- ;; 4. 测试用例 ;; --------------------------------------------------------- (define search (make-search my-re)) (displayln \"=== Standard Cases ===\") (displayln (search \"ad\")) ;; '(0 . 2) (displayln (search \"xxxad\")) ;; '(3 . 5) (displayln (search \"adxxx\")) ;; '(0 . 2) -- 验证最左匹配 (displayln (search \"xxxadxxx\")) ;; '(3 . 5) (displayln (search \"abccbd\")) ;; '(0 . 6) (displayln (search \"z\")) ;; #f (displayln \"=== Edge Cases ===\") ;; 多个匹配，应该返回最左边的那个 (displayln (search \"ad...ad\")) ;; '(0 . 2) ;; 贪婪/非贪婪行为测试 ;; 这里的实现是\"最短匹配\" (reluctant)，因为遇到 nullable 就立即返回了 ;; 对于 a(b|c)*d，如果输入 abdbd ;; forward 会在第一个 d 处 (index 3) 停止。 ;; backward 从 d 反向匹配到 a。 ;; 结果应该是 '(0 . 3) -\u003e \"abd\" (displayln (search \"abdbd\")) ;; '(0 . 3) ;; 复杂一点的 (displayln (search \"zzzaaaaaaddddzzz\")) ;; '(8 . 10) -\u003e 匹配了第一个 a..d 即 \"ad\" ;; 解释：因为 forward 匹配 .*a(b|c)*d。 ;; .* 吃了 \"zzzaaaa\"，然后 a 匹配 \"a\"，然后 d 匹配 \"d\"。 ;; 这里其实取决于 .* 的结合性，但在导数语义下，一旦 nullable 就停，这通常意味着匹配了\"能匹配的最短前缀\"。 复杂度问题 收回伏笔。\n1 2 3 4 5 6 7 8 9 10 (define (test-performance n) (printf \"Testing n=~a... \" n) (define part1 (for/fold ([acc (Eps]) ([i n]) (make-cat (make-alt (Eps) (make-chr #\\a)) acc))) (define part2 (for/fold ([acc (Eps]) ([i n]) (make-cat (make-chr #\\a) acc))) (define re (make-cat part1 part2)) (define matcher (make-matcher re)) (define input (make-string (* 2 n) #\\a)) (time (matcher input))) (test-performance 50) 这是一个经典的 hack。用类似下面的正则去匹配全 a 字符串：\n1 #(struct:Cat #(struct:Cat #(struct:Alt (#(struct:Chr a) #(struct:Eps))) #(struct:Alt (#(struct:Chr a) #(struct:Eps)))) #(struct:Cat #(struct:Chr a) #(struct:Chr a))) 即 a|Eps a|Eps a a。\n你会注意到数据规模达到 50 的时候卡死了。事实上，我们的简单引擎在这个 hack 下是指数复杂度（具体是 $O(2^n)$）的。\n问题的发掘，以及效率优化 问题在于缓存没有生效。具体而言，(Alt (Alt (Chr #\\a) (Chr #\\a)) (Chr #\\b)) 和 (Alt (Alt (Chr #\\a) (Chr #\\b)) (Chr #\\a)) 在语义上是相同的，但是结构上却不相等。这时两个状态都会被分别扔进缓存，复杂度就退化了。\n如何解决？我们需要把 Alt 节点拍平，并且按照一定顺序排序。\n“按照一定顺序排序”意味着我们需要给节点定义一个全序关系。这是难办的。\n直接递归比较会导致复杂度退化。\n经验丰富的读者们大概会想到给每个节点赋一个唯一的 uid。这是一个好主意，但是需要添加新的字段（表达式问题的一个侧面）。我比较懒，不想这么做。\n我们可以利用一种类似符号类型的驻留机制。使用哈希表存储所有出现过的表达式节点，来实现对于两个值相同的节点，保证它们是 eq? 的（即在内存中是同一个对象）。对于一个新构造的节点，如果它在哈希表中出现过，返回哈希表中记录的值，否则将这个节点构造出来扔进哈希表。\n这样，比较时就可以利用 eq-hash-code。虽然可能有冲突，但是概率很小（因为 eq-hash-code 的返回值是 61-62 位整数）。\n这份代码是 Gemini 帮忙写的。对于上面那个性能测试，在 $n=100$ 时大概需要一秒多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 #lang racket (require srfi/13) ;; 1. 定义 AST，通过 gen:equal+hash 强制 O(1) 比较 ;; 只要对象是驻留的，equal? 逻辑就等同于 eq? (struct Eps () #:transparent #:methods gen:equal+hash [(define (equal-proc a b recur) (eq? a b)) (define (hash-proc a recur) (eq-hash-code a)) (define (hash2-proc a recur) (eq-hash-code a))]) (struct Void () #:transparent #:methods gen:equal+hash [(define (equal-proc a b recur) (eq? a b)) (define (hash-proc a recur) (eq-hash-code a)) (define (hash2-proc a recur) (eq-hash-code a))]) (struct Chr (c) #:transparent #:methods gen:equal+hash [(define (equal-proc a b recur) (eq? a b)) (define (hash-proc a recur) (eq-hash-code a)) (define (hash2-proc a recur) (eq-hash-code a))]) (struct Cat (e1 e2) #:transparent #:methods gen:equal+hash [(define (equal-proc a b recur) (eq? a b)) (define (hash-proc a recur) (eq-hash-code a)) (define (hash2-proc a recur) (eq-hash-code a))]) (struct Alt (e-list) #:transparent #:methods gen:equal+hash [(define (equal-proc a b recur) (eq? a b)) (define (hash-proc a recur) (eq-hash-code a)) (define (hash2-proc a recur) (eq-hash-code a))]) (struct Star (e) #:transparent #:methods gen:equal+hash [(define (equal-proc a b recur) (eq? a b)) (define (hash-proc a recur) (eq-hash-code a)) (define (hash2-proc a recur) (eq-hash-code a))]) (struct Dot () #:transparent #:methods gen:equal+hash [(define (equal-proc a b recur) (eq? a b)) (define (hash-proc a recur) (eq-hash-code a)) (define (hash2-proc a recur) (eq-hash-code a))]) ;; 2. 驻留池 (Weak Hash Table) ;; 注意：池的 Key 必须使用 vector，因为 vector 的 equal? 会递归检查其内容 ;; 而内容（子节点）已经是驻留的，所以比较子节点是 O(1) 的 eq? (define pool (make-weak-hash)) (define (intern key constructor) (hash-ref! pool key constructor)) ;; 基础常量 (define phi (intern (vector 'Void) (λ () (Void)))) (define eps (intern (vector 'Eps) (λ () (Eps)))) (define dot (intern (vector 'Dot) (λ () (Dot)))) ;; 3. 辅助排序函数：利用 eq-hash-code 实现常数时间全序 (define (re-type-rank r) (cond [(Void? r) 0] [(Eps? r) 1] [(Dot? r) 2] [(Chr? r) 3] [(Star? r) 4] [(Cat? r) 5] [(Alt? r) 6])) (define (re-compare r1 r2) (let ([t1 (re-type-rank r1)] [t2 (re-type-rank r2)]) (if (= t1 t2) (\u003c (eq-hash-code r1) (eq-hash-code r2)) (\u003c t1 t2)))) ;; 4. 智能构造函数 (define (make-chr c) (intern (vector 'Chr c) (λ () (Chr c)))) (define (make-star e) (cond [(Void? e) eps] [(Eps? e) eps] [(Star? e) e] [else (intern (vector 'Star e) (λ () (Star e)))])) (define (make-cat e1 e2) (cond [(or (Void? e1) (Void? e2)) phi] [(Eps? e1) e2] [(Eps? e2) e1] [else (intern (vector 'Cat e1 e2) (λ () (Cat e1 e2)))])) (define (make-alt l) (define (flatten es) (append-map (λ (x) (if (Alt? x) (Alt-e-list x) (list x))) es)) (let* ([flat (flatten l)] [no-phi (filter-not Void? flat)] ;; 使用 eq-hash-code 排序，确保 ACI 规范化 [sorted (sort no-phi re-compare)] [unique (remove-duplicates sorted eq?)]) (cond [(null? unique) phi] [(null? (cdr unique)) (car unique)] [else (intern (vector 'Alt unique) (λ () (Alt unique)))]))) ;; 5. 导数与判空 (define (nullable? re) (match re [(Eps) #t] [(Star _) #t] [(Alt es) (ormap nullable? es)] [(Cat e1 e2) (and (nullable? e1) (nullable? e2))] [_ #f])) (define (derive re c) (match re [(Void) phi] [(Eps) phi] [(Dot) eps] [(Chr ch) (if (char=? ch c) eps phi)] [(Alt es) (make-alt (map (λ (e) (derive e c)) es))] [(Cat e1 e2) (if (nullable? e1) (make-alt (list (make-cat (derive e1 c) e2) (derive e2 c))) (make-cat (derive e1 c) e2))] [(Star e) (make-cat (derive e c) re)])) ;; --------------------------------------------------------- ;; 1. 匹配器构造 (完全匹配) ;; --------------------------------------------------------- (define (make-matcher re) (define cache (make-hash)) ;; 状态转移缓存: cur -\u003e char -\u003e next (lambda (str) (let loop ([cur re] [s (string-\u003elist str)]) (if (null? s) (nullable? cur) (let ([next (hash-ref! (hash-ref! cache cur (λ () (make-hash))) (car s) (λ () (derive cur (car s))))]) (if (Void? next) #f (loop next (cdr s)))))))) ;; --------------------------------------------------------- ;; 2. 正则表达式反转 ;; --------------------------------------------------------- (define (re-reverse re) (match re [(Cat e1 e2) (make-cat (re-reverse e2) (re-reverse e1))] [(Alt es) (make-alt (map re-reverse es))] [(Star e) (make-star (re-reverse e))] [_ re])) ;; --------------------------------------------------------- ;; 3. 搜索器构造 (子串匹配: 最左最短) ;; --------------------------------------------------------- (define (make-search re) ;; 前向搜索: 匹配 .*RE (define forward-re (make-cat (make-star dot) re)) ;; 后向搜索: 匹配 RE_reversed (define backward-re (re-reverse re)) (define f-cache (make-hash)) (define b-cache (make-hash)) (define (step cache cur c) (hash-ref! (hash-ref! cache cur (λ () (make-hash))) c (λ () (derive cur c)))) (lambda (str) (let* ([chars (string-\u003elist str)]) ;; 1. 前向扫描：寻找第一个能让 (.*RE) 变成 nullable 的位置 E (define E (let f-loop ([cur forward-re] [s chars] [idx 0]) (cond [(nullable? cur) idx] ;; 找到匹配终点 [(null? s) #f] [else (let ([next (step f-cache cur (car s))]) (if (Void? next) #f (f-loop next (cdr s) (add1 idx))))]))) (if E ;; 2. 后向扫描：从 E 位置开始向左匹配 RE_rev，寻找最短的起点 ;; 提取前 E 个字符并反转 (let* ([prefix-rev (reverse (take chars E))] [T (let b-loop ([cur backward-re] [s prefix-rev] [idx 0]) (cond [(nullable? cur) idx] ;; 找到匹配起点（距离 E 的偏移） [(null? s) (if (nullable? cur) idx #f)] [else (let ([next (step b-cache cur (car s))]) (if (Void? next) #f (b-loop next (cdr s) (add1 idx))))]))]) (cons (- E T) E)) #f)))) ;; --------------------------------------------------------- ;; 测试脚本 ;; --------------------------------------------------------- (define (run-tests) (define a (make-chr #\\a)) (define b (make-chr #\\b)) (define c (make-chr #\\c)) (define d (make-chr #\\d)) ;; 正则: a(b|c)*d (define my-re (make-cat a (make-cat (make-star (make-alt (list b c))) d))) (printf \"=== Testing Matcher ===\\n\") (define matches? (make-matcher my-re)) (displayln (list 'ad (matches? \"ad\"))) ; #t (displayln (list 'abd (matches? \"abd\"))) ; #t (displayln (list 'abccbd (matches? \"abccbd\"))) ; #t (displayln (list 'add (matches? \"add\"))) ; #f (displayln (list 'a (matches? \"a\"))) ; #f (printf \"\\n=== Testing Searcher ===\\n\") (define search (make-search my-re)) (displayln (list 'search-ad (search \"ad\"))) ; '(0 . 2) (displayln (list 'search-xxxad (search \"xxxad\"))) ; '(3 . 5) (displayln (list 'search-adxxx (search \"adxxx\"))) ; '(0 . 2) (displayln (list 'search-abccbd (search \"abccbd\"))) ; '(0 . 6) (displayln (list 'search-none (search \"xyz\"))) ; #f (printf \"\\n=== Testing Complex Search (Shortest-Left) ===\\n\") ;; 多个匹配，应该返回最左边的那个 (displayln (list 'multi-ad (search \"ad...ad\"))) ; '(0 . 2) ;; 贪婪/非贪婪行为测试 ;; 在 \"abdbd\" 中，forward 会在第一个 d (index 3) 停止，然后 backward 找到 a。 (displayln (list 'abdbd (search \"abdbd\"))) ; '(0 . 3) -\u003e \"abd\" ;; 验证 a...d 在长字符串中的表现 (displayln (list 'long-str (search \"zzzaaaaaaddddzzz\"))) ; '(8 . 10) -\u003e \"ad\" (printf \"\\n=== Testing Reverse Logic ===\\n\") ;; 测试反转后的匹配 (d (b|c)* a) (define rev-matches? (make-matcher (re-reverse my-re))) (displayln (list 'rev-da (rev-matches? \"da\"))) ; #t (displayln (list 'rev-dbca (rev-matches? \"dbca\"))) ; #t (displayln (list 'rev-ad (rev-matches? \"ad\"))) ; #f (printf \"\\nAll functional tests finished.\\n\")) (run-tests) ","wordCount":"2617","inLanguage":"en","datePublished":"2026-01-03T09:06:20+08:00","dateModified":"2026-01-03T09:06:20+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/regular-engine/"},"publisher":{"@type":"Organization","name":"正确即是废话，废话亦是正确","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="正确即是废话，废话亦是正确 (Alt + H)">正确即是废话，废话亦是正确</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://litjohn.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Regular Engine</h1><div class=post-meta><span title='2026-01-03 09:06:20 +0800 +0800'>January 3, 2026</span></div></header><div class=post-content><blockquote><p>亲手实现一个正则引擎！</p></blockquote><p>众所周知，一类经典的自动机是有限状态自动机。它们识别的语言是正则语言，而正则表达式能够匹配的字符串的集合也是正则语言。</p><p>（如果你之前没有了解过，询问 AI 或是使用搜索引擎都很适合快速了解）</p><h2 id=导数法>导数法<a hidden class=anchor aria-hidden=true href=#导数法>#</a></h2><p>要匹配一个正则表达式，最经典的方法就是构造对应的 NFA，然后通过一些手法转化为 DFA。但这太复杂了。有没有更简单的方法呢？</p><p>有一种被称为“导数法”的方法。</p><p>思想非常简单：我们将构造出的 DFA 编码为一个正则。这样，转移之后相当于产生了一个新的自动机，也就是一个新的正则表达式。</p><p>原始正则表达式是 $r$。那么，$r$“吃掉”一个字符 $c$ 之后产生的表达式 $r'$，能匹配的所有字符串就是所有满足 <code>(match? (cat c s) r)</code> 的字符串 $s$。</p><p>读者可以自行思考一下导数公式。</p><hr><p>我想用代码表示是最清晰的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>derive</span> <span class=n>re</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>re</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Void</span><span class=p>)</span> <span class=p>(</span><span class=n>Void</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Eps</span><span class=p>)</span> <span class=p>(</span><span class=n>Void</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Dot</span><span class=p>)</span> <span class=p>(</span><span class=n>Eps</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Chr</span> <span class=n>ch</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>char=?</span> <span class=n>ch</span> <span class=n>c</span><span class=p>)</span> <span class=p>(</span><span class=n>Eps</span><span class=p>)</span> <span class=p>(</span><span class=n>Void</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Alt</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e1</span> <span class=n>c</span><span class=p>)</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e2</span> <span class=n>c</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>e1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e1</span> <span class=n>c</span><span class=p>)</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e2</span> <span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e1</span> <span class=n>c</span><span class=p>)</span> <span class=n>e2</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Star</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e</span> <span class=n>c</span><span class=p>)</span> <span class=p>(</span><span class=n>Star</span> <span class=n>e</span><span class=p>))]))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>导数法将是我们使用的核心算法。</p><h2 id=特性与抽象语法>特性与抽象语法<a hidden class=anchor aria-hidden=true href=#特性与抽象语法>#</a></h2><p>我们将实现支持连接（cat），选择（alt）与闭包（kleene star）三种特性的正则表达式。同时添加“任意字符”（Dot）这种有用的语法糖（为了辅助包含匹配）。</p><p>使用 S-expression 以及 racket 结构体表达正则：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>regexp ::= (Void)
</span></span><span class=line><span class=cl>         | (Eps)
</span></span><span class=line><span class=cl>         | (Chr Char)
</span></span><span class=line><span class=cl>         | (Cat regexp regexp)
</span></span><span class=line><span class=cl>         | (Alt regexp regexp)
</span></span><span class=line><span class=cl>         | (Star regexp)
</span></span><span class=line><span class=cl>         | (Dot)
</span></span></code></pre></td></tr></table></div></div><p>定义语法树节点：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Eps</span> <span class=p>()</span> <span class=kd>#:transparent</span><span class=p>)</span>          <span class=c1>;; 空串 ε</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Void</span> <span class=p>()</span> <span class=kd>#:transparent</span><span class=p>)</span>         <span class=c1>;; 空集 φ (匹配失败)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Chr</span> <span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>         <span class=c1>;; 字符 c</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Cat</span> <span class=p>(</span><span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>     <span class=c1>;; 连接 e1 e2</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Alt</span> <span class=p>(</span><span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>     <span class=c1>;; 选择 e1 | e2</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Star</span> <span class=p>(</span><span class=n>e</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>        <span class=c1>;; 克林闭包 e*</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Dot</span> <span class=p>()</span> <span class=kd>#:transparent</span><span class=p>)</span>          <span class=c1>;; 语法糖：匹配任意字符</span>
</span></span></code></pre></td></tr></table></div></div><p>接下来我们要定义 Cat 和 Alt 的构造函数。这很重要，因为其中引入了一些简单的化简。这些化简是防止复杂度退化的重要工具。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-cat</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match*</span> <span class=p>(</span><span class=n>a</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>[((</span><span class=n>Void</span><span class=p>)</span> <span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>Void</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=k>_</span> <span class=p>(</span><span class=n>Void</span><span class=p>))</span> <span class=p>(</span><span class=n>Void</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[((</span><span class=n>Eps</span><span class=p>)</span> <span class=n>r</span><span class=p>)</span> <span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>r</span> <span class=p>(</span><span class=n>Eps</span><span class=p>))</span> <span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=k>_</span> <span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>Cat</span> <span class=n>a</span> <span class=n>b</span><span class=p>)]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-alt</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match*</span> <span class=p>(</span><span class=n>a</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>[((</span><span class=n>Void</span><span class=p>)</span> <span class=k>_</span><span class=p>)</span> <span class=n>b</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=k>_</span> <span class=p>(</span><span class=n>Void</span><span class=p>))</span> <span class=n>a</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>r</span> <span class=n>r</span><span class=p>)</span> <span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=k>_</span> <span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>Alt</span> <span class=n>a</span> <span class=n>b</span><span class=p>)]))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=流程设计>流程设计<a hidden class=anchor aria-hidden=true href=#流程设计>#</a></h2><p>导数法是步进式的：给定一个正则和一个字符，返回一个新的正则。所以我们的匹配也是步进式的。</p><p>我们将字符串转换为列表（相当于没有惰性求值的字符流）。然后一个一个吃字符，直到吃完为止。</p><p>这时如何看匹不匹配呢？我们需要一个 <code>nullable?</code> 函数来判断一个正则能否匹配空串。如果字符串结束时的正则是 <code>nullable?</code> 的，则匹配（接受），否则不匹配（拒绝）。</p><p>依然请读者自行思考实现。</p><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>re</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Eps</span><span class=p>)</span> <span class=no>#t</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Void</span><span class=p>)</span> <span class=no>#f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Dot</span><span class=p>)</span> <span class=no>#f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Chr</span> <span class=k>_</span><span class=p>)</span> <span class=no>#f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Star</span> <span class=k>_</span><span class=p>)</span> <span class=no>#t</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Alt</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=k>or</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>a</span><span class=p>)</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>b</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Cat</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>a</span><span class=p>)</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>b</span><span class=p>))]))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=缓存>缓存<a hidden class=anchor aria-hidden=true href=#缓存>#</a></h2><p>有许多正则表达式，它们关于特定字符的后继会被多次计算。这是很大的开销，所以我们用哈希表把它们存起来。</p><p>我们将使用一个二维哈希表，即 <code>Hash&lt;regexp -> Hash&lt;char -> regexp>></code>。</p><p>这样，判定给定字符串是否被给定正则接受就是简单的了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-matcher</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>cache</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>match-loop</span> <span class=n>cur</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=nb>null?</span> <span class=n>s</span><span class=p>)</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>cur</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=k>else</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>c</span> <span class=p>(</span><span class=nb>car</span> <span class=n>s</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>define</span> <span class=n>next</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=nb>hash-ref!</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>hash-ref!</span> <span class=n>cache</span> <span class=n>cur</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>()</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>lambda</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>derive</span> <span class=n>cur</span> <span class=n>c</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>Void?</span> <span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>             <span class=no>#f</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=n>match-loop</span> <span class=n>next</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>s</span><span class=p>))))]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>match-loop</span> <span class=n>re</span> <span class=p>(</span><span class=nb>string-&gt;list</span> <span class=n>str</span><span class=p>))))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>至此，我们实现了一个基础的正则判定器。同时埋下伏笔。</p><h2 id=匹配>匹配<a hidden class=anchor aria-hidden=true href=#匹配>#</a></h2><p>从头到尾扫描并对每个子串暴力判定显然是不好的，就像 brute-force 字符串模式匹配一样。</p><p>要匹配正则在字符串的哪个地方出现了，我们有更精妙的做法。</p><h3 id=辅助正则>辅助正则<a hidden class=anchor aria-hidden=true href=#辅助正则>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>forward</span> <span class=p>(</span><span class=n>Cat</span> <span class=p>(</span><span class=n>Star</span> <span class=p>(</span><span class=n>Dot</span><span class=p>))</span> <span class=nb>regexp</span><span class=p>))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>用这个正则去匹配字符串（的前缀），我们就知道原始正则 <code>regexp</code> 在字符串中是否出现过了。</p><p>通过对匹配过程的魔改，我们可以知道辅助正则匹配的第一个（或者最后一个，甚至中间任意一个）字符串前缀是什么。具体而言，对于所有 <code>forward</code> 满足 <code>nullable?</code> 的下标，我们记录其最小值或最大值。</p><p>至于记录最小值还是最大值，决定了匹配行为。我的代码选择了最小值，也就是最左最短匹配。如果要实现贪婪匹配，需要记录最大值。</p><p>我们记被我们记录的那个（能够被辅助正则匹配的）字符串前缀为 <code>S</code>，长度为 <code>E</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>backward</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>re</span><span class=p>))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这是另一个辅助正则。其中，<code>re-reverse</code> 函数用来将一个正则表达式“反转”。即原始正则能匹配的任意字符串反转后都能被它返回的正则匹配，且它返回的正则不能匹配其他任何字符串。</p><p>它的实现在这里：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>re</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e1</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Alt</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e1</span><span class=p>)</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e2</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Star</span> <span class=n>e</span><span class=p>)</span> <span class=p>(</span><span class=n>Star</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=k>_</span> <span class=n>re</span><span class=p>]))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=二遍扫描>二遍扫描<a hidden class=anchor aria-hidden=true href=#二遍扫描>#</a></h3><p>将 <code>S</code> 反转。</p><p>然后用 <code>backward</code> 匹配它（反转后的新字符串）的一个前缀。记长度为 <code>T</code>。</p><p>那么原始正则 <code>regexp</code> 能够匹配的子串（的下标区间）就是 $[E - T, E)$.</p><h2 id=完整代码>完整代码<a hidden class=anchor aria-hidden=true href=#完整代码>#</a></h2><p>精确判定和位置匹配都有一些测试用例。Gemini 写的。有比较好的注释。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>require</span> <span class=n>srfi/13</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>;; 1. 定义正则表达式的 AST (抽象语法树)</span>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Eps</span> <span class=p>()</span> <span class=kd>#:transparent</span><span class=p>)</span>          <span class=c1>;; 空串 ε</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Void</span> <span class=p>()</span> <span class=kd>#:transparent</span><span class=p>)</span>         <span class=c1>;; 空集 φ (匹配失败)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Chr</span> <span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>         <span class=c1>;; 字符 c</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Cat</span> <span class=p>(</span><span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>     <span class=c1>;; 连接 e1 e2</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Alt</span> <span class=p>(</span><span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>     <span class=c1>;; 选择 e1 | e2</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Star</span> <span class=p>(</span><span class=n>e</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>        <span class=c1>;; 克林闭包 e*</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Dot</span> <span class=p>()</span> <span class=kd>#:transparent</span><span class=p>)</span>          <span class=c1>;; 语法糖：匹配任意字符</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-cat</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match*</span> <span class=p>(</span><span class=n>a</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>[((</span><span class=n>Void</span><span class=p>)</span> <span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>Void</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=k>_</span> <span class=p>(</span><span class=n>Void</span><span class=p>))</span> <span class=p>(</span><span class=n>Void</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[((</span><span class=n>Eps</span><span class=p>)</span> <span class=n>r</span><span class=p>)</span> <span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>r</span> <span class=p>(</span><span class=n>Eps</span><span class=p>))</span> <span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=k>_</span> <span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>Cat</span> <span class=n>a</span> <span class=n>b</span><span class=p>)]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-alt</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match*</span> <span class=p>(</span><span class=n>a</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>[((</span><span class=n>Void</span><span class=p>)</span> <span class=k>_</span><span class=p>)</span> <span class=n>b</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=k>_</span> <span class=p>(</span><span class=n>Void</span><span class=p>))</span> <span class=n>a</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>r</span> <span class=n>r</span><span class=p>)</span> <span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=k>_</span> <span class=k>_</span><span class=p>)</span> <span class=p>(</span><span class=n>Alt</span> <span class=n>a</span> <span class=n>b</span><span class=p>)]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>re</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Eps</span><span class=p>)</span> <span class=no>#t</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Void</span><span class=p>)</span> <span class=no>#f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Dot</span><span class=p>)</span> <span class=no>#f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Chr</span> <span class=k>_</span><span class=p>)</span> <span class=no>#f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Star</span> <span class=k>_</span><span class=p>)</span> <span class=no>#t</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Alt</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=k>or</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>a</span><span class=p>)</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>b</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Cat</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>a</span><span class=p>)</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>b</span><span class=p>))]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>derive</span> <span class=n>re</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>re</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Void</span><span class=p>)</span> <span class=p>(</span><span class=n>Void</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Eps</span><span class=p>)</span> <span class=p>(</span><span class=n>Void</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Dot</span><span class=p>)</span> <span class=p>(</span><span class=n>Eps</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Chr</span> <span class=n>ch</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>char=?</span> <span class=n>ch</span> <span class=n>c</span><span class=p>)</span> <span class=p>(</span><span class=n>Eps</span><span class=p>)</span> <span class=p>(</span><span class=n>Void</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Alt</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e1</span> <span class=n>c</span><span class=p>)</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e2</span> <span class=n>c</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>e1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e1</span> <span class=n>c</span><span class=p>)</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e2</span> <span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e1</span> <span class=n>c</span><span class=p>)</span> <span class=n>e2</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Star</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e</span> <span class=n>c</span><span class=p>)</span> <span class=p>(</span><span class=n>Star</span> <span class=n>e</span><span class=p>))]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-matcher</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>cache</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>match-loop</span> <span class=n>cur</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=nb>null?</span> <span class=n>s</span><span class=p>)</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>cur</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=k>else</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>c</span> <span class=p>(</span><span class=nb>car</span> <span class=n>s</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>define</span> <span class=n>next</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=nb>hash-ref!</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>hash-ref!</span> <span class=n>cache</span> <span class=n>cur</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>()</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>lambda</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>derive</span> <span class=n>cur</span> <span class=n>c</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>Void?</span> <span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>             <span class=no>#f</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=n>match-loop</span> <span class=n>next</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>s</span><span class=p>))))]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>match-loop</span> <span class=n>re</span> <span class=p>(</span><span class=nb>string-&gt;list</span> <span class=n>str</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>;; 测试</span>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 正则: a(b|c)*d</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>my-re</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>Chr</span> <span class=sc>#\a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>Star</span> <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=n>Chr</span> <span class=sc>#\b</span><span class=p>)</span> <span class=p>(</span><span class=n>Chr</span> <span class=sc>#\c</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                  <span class=p>(</span><span class=n>Chr</span> <span class=sc>#\d</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>matches?</span> <span class=p>(</span><span class=n>make-matcher</span> <span class=n>my-re</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;Test Cases:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;ad&#34;</span><span class=p>))</span>       <span class=c1>;; #t</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;abd&#34;</span><span class=p>))</span>      <span class=c1>;; #t</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;abccbd&#34;</span><span class=p>))</span>   <span class=c1>;; #t</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;add&#34;</span><span class=p>))</span>      <span class=c1>;; #f</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;a&#34;</span><span class=p>))</span>        <span class=c1>;; #f</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 压力测试：状态缓存机制</span>
</span></span><span class=line><span class=cl><span class=c1>;; 第一次运行会构建缓存，第二次运行直接查表</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>time</span> <span class=p>(</span><span class=k>for</span> <span class=p>([</span><span class=n>i</span> <span class=mi>10000</span><span class=p>])</span> <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;abcbcd&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>re</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e1</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Alt</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e1</span><span class=p>)</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e2</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Star</span> <span class=n>e</span><span class=p>)</span> <span class=p>(</span><span class=n>Star</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=k>_</span> <span class=n>re</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-search</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>forward</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>Star</span> <span class=p>(</span><span class=n>Dot</span><span class=p>))</span> <span class=n>re</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>backward</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>re</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>cache</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>match-loop</span> <span class=n>cur</span> <span class=n>s</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=n>nullable?</span> <span class=n>cur</span><span class=p>)</span> <span class=n>idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=nb>&gt;=</span> <span class=n>idx</span> <span class=p>(</span><span class=nb>string-length</span> <span class=n>s</span><span class=p>))</span> <span class=no>#f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=k>else</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>c</span> <span class=p>(</span><span class=nb>string-ref</span> <span class=n>s</span> <span class=n>idx</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>define</span> <span class=n>next</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=nb>hash-ref!</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>hash-ref!</span> <span class=n>cache</span> <span class=n>cur</span> <span class=p>(</span><span class=k>lambda</span> <span class=p>()</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>lambda</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=n>derive</span> <span class=n>cur</span> <span class=n>c</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>Void?</span> <span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>             <span class=no>#f</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=n>match-loop</span> <span class=n>next</span> <span class=n>s</span> <span class=p>(</span><span class=nb>add1</span> <span class=n>idx</span><span class=p>))))]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>define</span> <span class=n>E</span> <span class=p>(</span><span class=n>match-loop</span> <span class=n>forward</span> <span class=n>str</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=n>E</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>begin</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>T</span> <span class=p>(</span><span class=n>match-loop</span> <span class=n>backward</span> <span class=p>(</span><span class=n>string-reverse</span> <span class=n>str</span> <span class=mi>0</span> <span class=n>E</span><span class=p>)</span> <span class=mi>0</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=nb>-</span> <span class=n>E</span> <span class=n>T</span><span class=p>)</span> <span class=n>E</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=no>#f</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>;; 4. 测试用例</span>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>search</span> <span class=p>(</span><span class=n>make-search</span> <span class=n>my-re</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;=== Standard Cases ===&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;ad&#34;</span><span class=p>))</span>         <span class=c1>;; &#39;(0 . 2)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;xxxad&#34;</span><span class=p>))</span>      <span class=c1>;; &#39;(3 . 5)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;adxxx&#34;</span><span class=p>))</span>      <span class=c1>;; &#39;(0 . 2)  -- 验证最左匹配</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;xxxadxxx&#34;</span><span class=p>))</span>   <span class=c1>;; &#39;(3 . 5)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;abccbd&#34;</span><span class=p>))</span>     <span class=c1>;; &#39;(0 . 6)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;z&#34;</span><span class=p>))</span>          <span class=c1>;; #f</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;=== Edge Cases ===&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>;; 多个匹配，应该返回最左边的那个</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;ad...ad&#34;</span><span class=p>))</span>    <span class=c1>;; &#39;(0 . 2)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 贪婪/非贪婪行为测试</span>
</span></span><span class=line><span class=cl><span class=c1>;; 这里的实现是&#34;最短匹配&#34; (reluctant)，因为遇到 nullable 就立即返回了</span>
</span></span><span class=line><span class=cl><span class=c1>;; 对于 a(b|c)*d，如果输入 abdbd</span>
</span></span><span class=line><span class=cl><span class=c1>;; forward 会在第一个 d 处 (index 3) 停止。</span>
</span></span><span class=line><span class=cl><span class=c1>;; backward 从 d 反向匹配到 a。</span>
</span></span><span class=line><span class=cl><span class=c1>;; 结果应该是 &#39;(0 . 3) -&gt; &#34;abd&#34;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;abdbd&#34;</span><span class=p>))</span>      <span class=c1>;; &#39;(0 . 3)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 复杂一点的</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;zzzaaaaaaddddzzz&#34;</span><span class=p>))</span> <span class=c1>;; &#39;(8 . 10) -&gt; 匹配了第一个 a..d 即 &#34;ad&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>;; 解释：因为 forward 匹配 .*a(b|c)*d。</span>
</span></span><span class=line><span class=cl><span class=c1>;; .* 吃了 &#34;zzzaaaa&#34;，然后 a 匹配 &#34;a&#34;，然后 d 匹配 &#34;d&#34;。</span>
</span></span><span class=line><span class=cl><span class=c1>;; 这里其实取决于 .* 的结合性，但在导数语义下，一旦 nullable 就停，这通常意味着匹配了&#34;能匹配的最短前缀&#34;。</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=复杂度问题>复杂度问题<a hidden class=anchor aria-hidden=true href=#复杂度问题>#</a></h2><p>收回伏笔。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>test-performance</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;Testing n=~a... &#34;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>part1</span> <span class=p>(</span><span class=k>for/fold</span> <span class=p>([</span><span class=n>acc</span> <span class=p>(</span><span class=n>Eps</span><span class=p>])</span> <span class=p>([</span><span class=n>i</span> <span class=n>n</span><span class=p>])</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=n>Eps</span><span class=p>)</span> <span class=p>(</span><span class=n>make-chr</span> <span class=sc>#\a</span><span class=p>))</span> <span class=n>acc</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>part2</span> <span class=p>(</span><span class=k>for/fold</span> <span class=p>([</span><span class=n>acc</span> <span class=p>(</span><span class=n>Eps</span><span class=p>])</span> <span class=p>([</span><span class=n>i</span> <span class=n>n</span><span class=p>])</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>make-chr</span> <span class=sc>#\a</span><span class=p>)</span> <span class=n>acc</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>re</span> <span class=p>(</span><span class=n>make-cat</span> <span class=n>part1</span> <span class=n>part2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>matcher</span> <span class=p>(</span><span class=n>make-matcher</span> <span class=n>re</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>input</span> <span class=p>(</span><span class=nb>make-string</span> <span class=p>(</span><span class=nb>*</span> <span class=mi>2</span> <span class=n>n</span><span class=p>)</span> <span class=sc>#\a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>time</span> <span class=p>(</span><span class=n>matcher</span> <span class=n>input</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>test-performance</span> <span class=mi>50</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这是一个经典的 hack。用类似下面的正则去匹配全 a 字符串：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=o>#</span><span class=p>(</span><span class=ss>struct:Cat</span> <span class=o>#</span><span class=p>(</span><span class=ss>struct:Cat</span> <span class=o>#</span><span class=p>(</span><span class=ss>struct:Alt</span> <span class=p>(</span><span class=o>#</span><span class=p>(</span><span class=ss>struct:Chr</span> <span class=ss>a</span><span class=p>)</span> <span class=o>#</span><span class=p>(</span><span class=ss>struct:Eps</span><span class=p>)))</span> <span class=o>#</span><span class=p>(</span><span class=ss>struct:Alt</span> <span class=p>(</span><span class=o>#</span><span class=p>(</span><span class=ss>struct:Chr</span> <span class=ss>a</span><span class=p>)</span> <span class=o>#</span><span class=p>(</span><span class=ss>struct:Eps</span><span class=p>))))</span> <span class=o>#</span><span class=p>(</span><span class=ss>struct:Cat</span> <span class=o>#</span><span class=p>(</span><span class=ss>struct:Chr</span> <span class=ss>a</span><span class=p>)</span> <span class=o>#</span><span class=p>(</span><span class=ss>struct:Chr</span> <span class=ss>a</span><span class=p>)))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>即 <code>a|Eps a|Eps a a</code>。</p><p>你会注意到数据规模达到 50 的时候卡死了。事实上，我们的简单引擎在这个 hack 下是指数复杂度（具体是 $O(2^n)$）的。</p><h2 id=问题的发掘以及效率优化>问题的发掘，以及效率优化<a hidden class=anchor aria-hidden=true href=#问题的发掘以及效率优化>#</a></h2><p>问题在于缓存没有生效。具体而言，<code>(Alt (Alt (Chr #\a) (Chr #\a)) (Chr #\b))</code> 和 <code>(Alt (Alt (Chr #\a) (Chr #\b)) (Chr #\a))</code> 在语义上是相同的，但是结构上却不相等。这时两个状态都会被分别扔进缓存，复杂度就退化了。</p><p>如何解决？我们需要把 Alt 节点拍平，并且按照一定顺序排序。</p><p>“按照一定顺序排序”意味着我们需要给节点定义一个全序关系。这是难办的。</p><p>直接递归比较会导致复杂度退化。</p><p>经验丰富的读者们大概会想到给每个节点赋一个唯一的 uid。这是一个好主意，但是需要添加新的字段（表达式问题的一个侧面）。我比较懒，不想这么做。</p><p>我们可以利用一种类似符号类型的驻留机制。使用哈希表存储所有出现过的表达式节点，来实现对于两个值相同的节点，保证它们是 <code>eq?</code> 的（即在内存中是同一个对象）。对于一个新构造的节点，如果它在哈希表中出现过，返回哈希表中记录的值，否则将这个节点构造出来扔进哈希表。</p><p>这样，比较时就可以利用 <code>eq-hash-code</code>。虽然可能有冲突，但是概率很小（因为 <code>eq-hash-code</code> 的返回值是 61-62 位整数）。</p><p>这份代码是 Gemini 帮忙写的。对于上面那个性能测试，在 $n=100$ 时大概需要一秒多。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>require</span> <span class=n>srfi/13</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 1. 定义 AST，通过 gen:equal+hash 强制 O(1) 比较</span>
</span></span><span class=line><span class=cl><span class=c1>;; 只要对象是驻留的，equal? 逻辑就等同于 eq?</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Eps</span> <span class=p>()</span> <span class=kd>#:transparent</span>
</span></span><span class=line><span class=cl>  <span class=kd>#:methods</span> <span class=k>gen:equal+hash</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=k>define</span> <span class=p>(</span><span class=n>equal-proc</span> <span class=n>a</span> <span class=n>b</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq?</span> <span class=n>a</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash2-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Void</span> <span class=p>()</span> <span class=kd>#:transparent</span>
</span></span><span class=line><span class=cl>  <span class=kd>#:methods</span> <span class=k>gen:equal+hash</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=k>define</span> <span class=p>(</span><span class=n>equal-proc</span> <span class=n>a</span> <span class=n>b</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq?</span> <span class=n>a</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash2-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Chr</span> <span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=kd>#:transparent</span>
</span></span><span class=line><span class=cl>  <span class=kd>#:methods</span> <span class=k>gen:equal+hash</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=k>define</span> <span class=p>(</span><span class=n>equal-proc</span> <span class=n>a</span> <span class=n>b</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq?</span> <span class=n>a</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash2-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Cat</span> <span class=p>(</span><span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=kd>#:transparent</span>
</span></span><span class=line><span class=cl>  <span class=kd>#:methods</span> <span class=k>gen:equal+hash</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=k>define</span> <span class=p>(</span><span class=n>equal-proc</span> <span class=n>a</span> <span class=n>b</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq?</span> <span class=n>a</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash2-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Alt</span> <span class=p>(</span><span class=n>e-list</span><span class=p>)</span> <span class=kd>#:transparent</span>
</span></span><span class=line><span class=cl>  <span class=kd>#:methods</span> <span class=k>gen:equal+hash</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=k>define</span> <span class=p>(</span><span class=n>equal-proc</span> <span class=n>a</span> <span class=n>b</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq?</span> <span class=n>a</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash2-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Star</span> <span class=p>(</span><span class=n>e</span><span class=p>)</span> <span class=kd>#:transparent</span>
</span></span><span class=line><span class=cl>  <span class=kd>#:methods</span> <span class=k>gen:equal+hash</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=k>define</span> <span class=p>(</span><span class=n>equal-proc</span> <span class=n>a</span> <span class=n>b</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq?</span> <span class=n>a</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash2-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>Dot</span> <span class=p>()</span> <span class=kd>#:transparent</span>
</span></span><span class=line><span class=cl>  <span class=kd>#:methods</span> <span class=k>gen:equal+hash</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=k>define</span> <span class=p>(</span><span class=n>equal-proc</span> <span class=n>a</span> <span class=n>b</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq?</span> <span class=n>a</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>hash2-proc</span> <span class=n>a</span> <span class=n>recur</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>a</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 2. 驻留池 (Weak Hash Table)</span>
</span></span><span class=line><span class=cl><span class=c1>;; 注意：池的 Key 必须使用 vector，因为 vector 的 equal? 会递归检查其内容</span>
</span></span><span class=line><span class=cl><span class=c1>;; 而内容（子节点）已经是驻留的，所以比较子节点是 O(1) 的 eq?</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>pool</span> <span class=p>(</span><span class=nb>make-weak-hash</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>intern</span> <span class=n>key</span> <span class=n>constructor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>hash-ref!</span> <span class=n>pool</span> <span class=n>key</span> <span class=n>constructor</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 基础常量</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>phi</span> <span class=p>(</span><span class=n>intern</span> <span class=p>(</span><span class=nb>vector</span> <span class=o>&#39;</span><span class=ss>Void</span><span class=p>)</span> <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=n>Void</span><span class=p>))))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>eps</span> <span class=p>(</span><span class=n>intern</span> <span class=p>(</span><span class=nb>vector</span> <span class=o>&#39;</span><span class=ss>Eps</span><span class=p>)</span> <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=n>Eps</span><span class=p>))))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>dot</span> <span class=p>(</span><span class=n>intern</span> <span class=p>(</span><span class=nb>vector</span> <span class=o>&#39;</span><span class=ss>Dot</span><span class=p>)</span> <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=n>Dot</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 3. 辅助排序函数：利用 eq-hash-code 实现常数时间全序</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>re-type-rank</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=n>Void?</span> <span class=n>r</span><span class=p>)</span> <span class=mi>0</span><span class=p>]</span> <span class=p>[(</span><span class=n>Eps?</span> <span class=n>r</span><span class=p>)</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[(</span><span class=n>Dot?</span> <span class=n>r</span><span class=p>)</span> <span class=mi>2</span><span class=p>]</span> <span class=p>[(</span><span class=n>Chr?</span> <span class=n>r</span><span class=p>)</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>Star?</span> <span class=n>r</span><span class=p>)</span> <span class=mi>4</span><span class=p>]</span> <span class=p>[(</span><span class=n>Cat?</span> <span class=n>r</span><span class=p>)</span> <span class=mi>5</span><span class=p>]</span> <span class=p>[(</span><span class=n>Alt?</span> <span class=n>r</span><span class=p>)</span> <span class=mi>6</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>re-compare</span> <span class=n>r1</span> <span class=n>r2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>t1</span> <span class=p>(</span><span class=n>re-type-rank</span> <span class=n>r1</span><span class=p>)]</span> <span class=p>[</span><span class=n>t2</span> <span class=p>(</span><span class=n>re-type-rank</span> <span class=n>r2</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>=</span> <span class=n>t1</span> <span class=n>t2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>&lt;</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>r1</span><span class=p>)</span> <span class=p>(</span><span class=nb>eq-hash-code</span> <span class=n>r2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>&lt;</span> <span class=n>t1</span> <span class=n>t2</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 4. 智能构造函数</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-chr</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>intern</span> <span class=p>(</span><span class=nb>vector</span> <span class=o>&#39;</span><span class=ss>Chr</span> <span class=n>c</span><span class=p>)</span> <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=n>Chr</span> <span class=n>c</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-star</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=n>Void?</span> <span class=n>e</span><span class=p>)</span> <span class=n>eps</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>Eps?</span> <span class=n>e</span><span class=p>)</span> <span class=n>eps</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>Star?</span> <span class=n>e</span><span class=p>)</span> <span class=n>e</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=k>else</span> <span class=p>(</span><span class=n>intern</span> <span class=p>(</span><span class=nb>vector</span> <span class=o>&#39;</span><span class=ss>Star</span> <span class=n>e</span><span class=p>)</span> <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=n>Star</span> <span class=n>e</span><span class=p>)))]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>cond</span> <span class=p>[(</span><span class=k>or</span> <span class=p>(</span><span class=n>Void?</span> <span class=n>e1</span><span class=p>)</span> <span class=p>(</span><span class=n>Void?</span> <span class=n>e2</span><span class=p>))</span> <span class=n>phi</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>Eps?</span> <span class=n>e1</span><span class=p>)</span> <span class=n>e2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>Eps?</span> <span class=n>e2</span><span class=p>)</span> <span class=n>e1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=k>else</span> <span class=p>(</span><span class=n>intern</span> <span class=p>(</span><span class=nb>vector</span> <span class=o>&#39;</span><span class=ss>Cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=n>Cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)))]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-alt</span> <span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=nb>flatten</span> <span class=n>es</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>append-map</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>Alt?</span> <span class=n>x</span><span class=p>)</span> <span class=p>(</span><span class=n>Alt-e-list</span> <span class=n>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>list</span> <span class=n>x</span><span class=p>)))</span> <span class=n>es</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let*</span> <span class=p>([</span><span class=n>flat</span> <span class=p>(</span><span class=nb>flatten</span> <span class=n>l</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>         <span class=p>[</span><span class=n>no-phi</span> <span class=p>(</span><span class=nb>filter-not</span> <span class=n>Void?</span> <span class=n>flat</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>         <span class=c1>;; 使用 eq-hash-code 排序，确保 ACI 规范化</span>
</span></span><span class=line><span class=cl>         <span class=p>[</span><span class=n>sorted</span> <span class=p>(</span><span class=nb>sort</span> <span class=n>no-phi</span> <span class=n>re-compare</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>         <span class=p>[</span><span class=n>unique</span> <span class=p>(</span><span class=nb>remove-duplicates</span> <span class=n>sorted</span> <span class=nb>eq?</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=nb>null?</span> <span class=n>unique</span><span class=p>)</span> <span class=n>phi</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=nb>null?</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>unique</span><span class=p>))</span> <span class=p>(</span><span class=nb>car</span> <span class=n>unique</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=k>else</span> <span class=p>(</span><span class=n>intern</span> <span class=p>(</span><span class=nb>vector</span> <span class=o>&#39;</span><span class=ss>Alt</span> <span class=n>unique</span><span class=p>)</span> <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=n>Alt</span> <span class=n>unique</span><span class=p>)))])))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 5. 导数与判空</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>re</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Eps</span><span class=p>)</span> <span class=no>#t</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Star</span> <span class=k>_</span><span class=p>)</span> <span class=no>#t</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Alt</span> <span class=n>es</span><span class=p>)</span> <span class=p>(</span><span class=nb>ormap</span> <span class=n>nullable?</span> <span class=n>es</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>e1</span><span class=p>)</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>e2</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=k>_</span> <span class=no>#f</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>derive</span> <span class=n>re</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>re</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Void</span><span class=p>)</span> <span class=n>phi</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Eps</span><span class=p>)</span> <span class=n>phi</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Dot</span><span class=p>)</span> <span class=n>eps</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Chr</span> <span class=n>ch</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>char=?</span> <span class=n>ch</span> <span class=n>c</span><span class=p>)</span> <span class=n>eps</span> <span class=n>phi</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Alt</span> <span class=n>es</span><span class=p>)</span> <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=nb>map</span> <span class=p>(</span><span class=k>λ</span> <span class=p>(</span><span class=n>e</span><span class=p>)</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e</span> <span class=n>c</span><span class=p>))</span> <span class=n>es</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>e1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=nb>list</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e1</span> <span class=n>c</span><span class=p>)</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e2</span> <span class=n>c</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e1</span> <span class=n>c</span><span class=p>)</span> <span class=n>e2</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Star</span> <span class=n>e</span><span class=p>)</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>derive</span> <span class=n>e</span> <span class=n>c</span><span class=p>)</span> <span class=n>re</span><span class=p>)]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>;; 1. 匹配器构造 (完全匹配)</span>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-matcher</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>cache</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>))</span> <span class=c1>;; 状态转移缓存: cur -&gt; char -&gt; next</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>cur</span> <span class=n>re</span><span class=p>]</span> <span class=p>[</span><span class=n>s</span> <span class=p>(</span><span class=nb>string-&gt;list</span> <span class=n>str</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>null?</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>nullable?</span> <span class=n>cur</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>next</span> <span class=p>(</span><span class=nb>hash-ref!</span> <span class=p>(</span><span class=nb>hash-ref!</span> <span class=n>cache</span> <span class=n>cur</span> <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                                 <span class=p>(</span><span class=nb>car</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                 <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=n>derive</span> <span class=n>cur</span> <span class=p>(</span><span class=nb>car</span> <span class=n>s</span><span class=p>))))])</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>Void?</span> <span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=no>#f</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=n>loop</span> <span class=n>next</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>s</span><span class=p>))))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>;; 2. 正则表达式反转</span>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>match</span> <span class=n>re</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Cat</span> <span class=n>e1</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e2</span><span class=p>)</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e1</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Alt</span> <span class=n>es</span><span class=p>)</span>    <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=nb>map</span> <span class=n>re-reverse</span> <span class=n>es</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=n>Star</span> <span class=n>e</span><span class=p>)</span>    <span class=p>(</span><span class=n>make-star</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>e</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=k>_</span>             <span class=n>re</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>;; 3. 搜索器构造 (子串匹配: 最左最短)</span>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>make-search</span> <span class=n>re</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>;; 前向搜索: 匹配 .*RE</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>forward-re</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>make-star</span> <span class=n>dot</span><span class=p>)</span> <span class=n>re</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=c1>;; 后向搜索: 匹配 RE_reversed</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>backward-re</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>re</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>f-cache</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>b-cache</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>step</span> <span class=n>cache</span> <span class=n>cur</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>hash-ref!</span> <span class=p>(</span><span class=nb>hash-ref!</span> <span class=n>cache</span> <span class=n>cur</span> <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=nb>make-hash</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>               <span class=n>c</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=k>λ</span> <span class=p>()</span> <span class=p>(</span><span class=n>derive</span> <span class=n>cur</span> <span class=n>c</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let*</span> <span class=p>([</span><span class=n>chars</span> <span class=p>(</span><span class=nb>string-&gt;list</span> <span class=n>str</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=c1>;; 1. 前向扫描：寻找第一个能让 (.*RE) 变成 nullable 的位置 E</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>E</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let</span> <span class=n>f-loop</span> <span class=p>([</span><span class=n>cur</span> <span class=n>forward-re</span><span class=p>]</span> <span class=p>[</span><span class=n>s</span> <span class=n>chars</span><span class=p>]</span> <span class=p>[</span><span class=n>idx</span> <span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>            <span class=p>[(</span><span class=n>nullable?</span> <span class=n>cur</span><span class=p>)</span> <span class=n>idx</span><span class=p>]</span> <span class=c1>;; 找到匹配终点</span>
</span></span><span class=line><span class=cl>            <span class=p>[(</span><span class=nb>null?</span> <span class=n>s</span><span class=p>)</span> <span class=no>#f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=k>else</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>next</span> <span class=p>(</span><span class=n>step</span> <span class=n>f-cache</span> <span class=n>cur</span> <span class=p>(</span><span class=nb>car</span> <span class=n>s</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>Void?</span> <span class=n>next</span><span class=p>)</span> <span class=no>#f</span> <span class=p>(</span><span class=n>f-loop</span> <span class=n>next</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>s</span><span class=p>)</span> <span class=p>(</span><span class=nb>add1</span> <span class=n>idx</span><span class=p>))))])))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>if</span> <span class=n>E</span>
</span></span><span class=line><span class=cl>          <span class=c1>;; 2. 后向扫描：从 E 位置开始向左匹配 RE_rev，寻找最短的起点</span>
</span></span><span class=line><span class=cl>          <span class=c1>;; 提取前 E 个字符并反转</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>let*</span> <span class=p>([</span><span class=n>prefix-rev</span> <span class=p>(</span><span class=nb>reverse</span> <span class=p>(</span><span class=nb>take</span> <span class=n>chars</span> <span class=n>E</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>                 <span class=p>[</span><span class=n>T</span> <span class=p>(</span><span class=k>let</span> <span class=n>b-loop</span> <span class=p>([</span><span class=n>cur</span> <span class=n>backward-re</span><span class=p>]</span> <span class=p>[</span><span class=n>s</span> <span class=n>prefix-rev</span><span class=p>]</span> <span class=p>[</span><span class=n>idx</span> <span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                      <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>                        <span class=p>[(</span><span class=n>nullable?</span> <span class=n>cur</span><span class=p>)</span> <span class=n>idx</span><span class=p>]</span> <span class=c1>;; 找到匹配起点（距离 E 的偏移）</span>
</span></span><span class=line><span class=cl>                        <span class=p>[(</span><span class=nb>null?</span> <span class=n>s</span><span class=p>)</span> <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>nullable?</span> <span class=n>cur</span><span class=p>)</span> <span class=n>idx</span> <span class=no>#f</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>                        <span class=p>[</span><span class=k>else</span>
</span></span><span class=line><span class=cl>                         <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>next</span> <span class=p>(</span><span class=n>step</span> <span class=n>b-cache</span> <span class=n>cur</span> <span class=p>(</span><span class=nb>car</span> <span class=n>s</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>                           <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>Void?</span> <span class=n>next</span><span class=p>)</span> <span class=no>#f</span> <span class=p>(</span><span class=n>b-loop</span> <span class=n>next</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>s</span><span class=p>)</span> <span class=p>(</span><span class=nb>add1</span> <span class=n>idx</span><span class=p>))))]))])</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=nb>-</span> <span class=n>E</span> <span class=n>T</span><span class=p>)</span> <span class=n>E</span><span class=p>))</span>
</span></span><span class=line><span class=cl>          <span class=no>#f</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>;; 测试脚本</span>
</span></span><span class=line><span class=cl><span class=c1>;; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>run-tests</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>a</span> <span class=p>(</span><span class=n>make-chr</span> <span class=sc>#\a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>b</span> <span class=p>(</span><span class=n>make-chr</span> <span class=sc>#\b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>c</span> <span class=p>(</span><span class=n>make-chr</span> <span class=sc>#\c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>d</span> <span class=p>(</span><span class=n>make-chr</span> <span class=sc>#\d</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>;; 正则: a(b|c)*d</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>my-re</span> <span class=p>(</span><span class=n>make-cat</span> <span class=n>a</span> <span class=p>(</span><span class=n>make-cat</span> <span class=p>(</span><span class=n>make-star</span> <span class=p>(</span><span class=n>make-alt</span> <span class=p>(</span><span class=nb>list</span> <span class=n>b</span> <span class=n>c</span><span class=p>)))</span> <span class=n>d</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;=== Testing Matcher ===</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>matches?</span> <span class=p>(</span><span class=n>make-matcher</span> <span class=n>my-re</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>ad</span>      <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;ad&#34;</span><span class=p>)))</span>       <span class=c1>; #t</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>abd</span>     <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;abd&#34;</span><span class=p>)))</span>      <span class=c1>; #t</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>abccbd</span>  <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;abccbd&#34;</span><span class=p>)))</span>   <span class=c1>; #t</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>add</span>     <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;add&#34;</span><span class=p>)))</span>      <span class=c1>; #f</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>a</span>       <span class=p>(</span><span class=n>matches?</span> <span class=s2>&#34;a&#34;</span><span class=p>)))</span>        <span class=c1>; #f</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>=== Testing Searcher ===</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>search</span> <span class=p>(</span><span class=n>make-search</span> <span class=n>my-re</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>search-ad</span>       <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;ad&#34;</span><span class=p>)))</span>           <span class=c1>; &#39;(0 . 2)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>search-xxxad</span>    <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;xxxad&#34;</span><span class=p>)))</span>        <span class=c1>; &#39;(3 . 5)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>search-adxxx</span>    <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;adxxx&#34;</span><span class=p>)))</span>        <span class=c1>; &#39;(0 . 2)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>search-abccbd</span>   <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;abccbd&#34;</span><span class=p>)))</span>       <span class=c1>; &#39;(0 . 6)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>search-none</span>     <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;xyz&#34;</span><span class=p>)))</span>          <span class=c1>; #f</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>=== Testing Complex Search (Shortest-Left) ===</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>;; 多个匹配，应该返回最左边的那个</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>multi-ad</span>   <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;ad...ad&#34;</span><span class=p>)))</span>           <span class=c1>; &#39;(0 . 2)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>;; 贪婪/非贪婪行为测试</span>
</span></span><span class=line><span class=cl>  <span class=c1>;; 在 &#34;abdbd&#34; 中，forward 会在第一个 d (index 3) 停止，然后 backward 找到 a。</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>abdbd</span>      <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;abdbd&#34;</span><span class=p>)))</span>             <span class=c1>; &#39;(0 . 3) -&gt; &#34;abd&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>;; 验证 a...d 在长字符串中的表现</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>long-str</span>   <span class=p>(</span><span class=n>search</span> <span class=s2>&#34;zzzaaaaaaddddzzz&#34;</span><span class=p>)))</span>   <span class=c1>; &#39;(8 . 10) -&gt; &#34;ad&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>=== Testing Reverse Logic ===</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>;; 测试反转后的匹配 (d (b|c)* a)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>define</span> <span class=n>rev-matches?</span> <span class=p>(</span><span class=n>make-matcher</span> <span class=p>(</span><span class=n>re-reverse</span> <span class=n>my-re</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>rev-da</span>     <span class=p>(</span><span class=n>rev-matches?</span> <span class=s2>&#34;da&#34;</span><span class=p>)))</span>          <span class=c1>; #t</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>rev-dbca</span>   <span class=p>(</span><span class=n>rev-matches?</span> <span class=s2>&#34;dbca&#34;</span><span class=p>)))</span>        <span class=c1>; #t</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=nb>list</span> <span class=o>&#39;</span><span class=ss>rev-ad</span>     <span class=p>(</span><span class=n>rev-matches?</span> <span class=s2>&#34;ad&#34;</span><span class=p>)))</span>          <span class=c1>; #f</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>All functional tests finished.</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>run-tests</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/lisp/scheme/racket/>Lisp/Scheme/Racket</a></li><li><a href=https://litjohn.github.io/tags/algorithms/>Algorithms</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://litjohn.github.io/>正确即是废话，废话亦是正确</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>