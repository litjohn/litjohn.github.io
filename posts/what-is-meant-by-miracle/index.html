<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>许愿机 | 正确即是废话，废话亦是正确</title><meta name=keywords content="PLT,lisp/scheme/racket"><meta name=description content='光剑的后日谈 #3. 这次来聊聊什么是许愿机。
Some examples
现在我们需要写一段代码，用矩阵快速幂求解一个递推数列：
$$
\begin{cases}
f(0)=f(1)=f(2)=1 \\
f(n)=f(n-1)+2f(n-2)+5f(n-3), n \geq 3
\end{cases}
$$
我们知道我们将数列中的相邻几项写成一个向量 $(f(i), f(i+1), f(i+2))$，然后找到一个矩阵乘上它转移到下一个向量 $(f(i+1), f(i+2), f(i+3))$，那么这个矩阵怎么算呢？
猜肯定是一个办法，但肯定不好。手动求解，待定系数也是一种方法。
然而，我们还有更加优雅的做法。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61


from z3 import *

def solve_transition_matrix():
    # 1. 创建求解器
    s = Solver()

    # 2. 定义我们需要求解的 3x3 转移矩阵 M
    # 变量 m_r_c 代表矩阵第 r 行第 c 列的元素 (全是整数)
    M = [[Int(f&#39;m_{r}_{c}&#39;) for c in range(3)] for r in range(3)]

    # 3. 定义“任意”时刻的输入向量状态
    # 设 f0, f1, f2 分别代表 f(i), f(i+1), f(i+2)
    # 我们使用 Ints 创建符号变量，这些将作为全称量词的变量
    f0, f1, f2 = Ints(&#39;f0 f1 f2&#39;)

    # 构造当前向量 V_i
    v_current = [f0, f1, f2]

    # 4. 根据递推公式定义期望的输出向量 V_{i+1}
    # 题目递推式: f(n) = f(n-1) + 2f(n-2) + 5f(n-3)
    # 对应到我们的符号: 下一项 f3 = f2 + 2*f1 + 5*f0
    f3 = f2 + 2 * f1 + 5 * f0

    # 构造下一刻向量 V_{i+1} = [f(i+1), f(i+2), f(i+3)]
    v_next = [f1, f2, f3]

    # 5. 核心逻辑：构造约束
    # 约束条件：M * v_current == v_next
    # 这个等式必须对“所有”的 f0, f1, f2 都成立

    constraints = []
    for r in range(3):
        # 矩阵乘法：第 r 行 点乘 输入向量
        row_product = sum(M[r][c] * v_current[c] for c in range(3))
        # 结果必须等于输出向量的对应项
        constraints.append(row_product == v_next[r])

    # 使用 ForAll (全称量词)
    # 读作：对于任意整数 f0, f1, f2，上述约束(And(constraints))都必须成立
    s.add(ForAll([f0, f1, f2], And(constraints)))

    # 6. 求解并打印结果
    if s.check() == sat:
        m = s.model()
        print("成功找到转移矩阵 M：")
        print("-" * 15)
        # 将 z3 的解转换为 Python 整数并格式化输出
        for r in range(3):
            row_vals = [m.evaluate(M[r][c]).as_long() for c in range(3)]
            print(f"| {row_vals[0]:^3} {row_vals[1]:^3} {row_vals[2]:^3} |")
        print("-" * 15)

        # 验证一下文章开头的直觉
        # 第一行应该是 0 1 0 (输出 f1)
        # 第二行应该是 0 0 1 (输出 f2)
        # 第三行应该是 5 2 1 (输出 5f0 + 2f1 + 1f2)
    else:
        print("未找到满足条件的矩阵。")

if __name__ == "__main__":
    solve_transition_matrix()


用 Python 运行这段代码（当然你需要先使用 pip install z3-solver 来解决库的依赖），你会得到这样的输出：'><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/what-is-meant-by-miracle/><link crossorigin=anonymous href=/assets/css/stylesheet.b915ce98f9f65cca5e346b24fc336009b3608a3eeb24ce4b0e53c4500eba9374.css integrity="sha256-uRXOmPn2XMpeNGsk/DNgCbNgij7rJM5LDlPEUA66k3Q=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/what-is-meant-by-miracle/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/what-is-meant-by-miracle/"><meta property="og:site_name" content="正确即是废话，废话亦是正确"><meta property="og:title" content="许愿机"><meta property="og:description" content='光剑的后日谈 #3. 这次来聊聊什么是许愿机。
Some examples 现在我们需要写一段代码，用矩阵快速幂求解一个递推数列：
$$ \begin{cases} f(0)=f(1)=f(2)=1 \\ f(n)=f(n-1)+2f(n-2)+5f(n-3), n \geq 3 \end{cases} $$
我们知道我们将数列中的相邻几项写成一个向量 $(f(i), f(i+1), f(i+2))$，然后找到一个矩阵乘上它转移到下一个向量 $(f(i+1), f(i+2), f(i+3))$，那么这个矩阵怎么算呢？
猜肯定是一个办法，但肯定不好。手动求解，待定系数也是一种方法。
然而，我们还有更加优雅的做法。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from z3 import * def solve_transition_matrix(): # 1. 创建求解器 s = Solver() # 2. 定义我们需要求解的 3x3 转移矩阵 M # 变量 m_r_c 代表矩阵第 r 行第 c 列的元素 (全是整数) M = [[Int(f&#39;m_{r}_{c}&#39;) for c in range(3)] for r in range(3)] # 3. 定义“任意”时刻的输入向量状态 # 设 f0, f1, f2 分别代表 f(i), f(i+1), f(i+2) # 我们使用 Ints 创建符号变量，这些将作为全称量词的变量 f0, f1, f2 = Ints(&#39;f0 f1 f2&#39;) # 构造当前向量 V_i v_current = [f0, f1, f2] # 4. 根据递推公式定义期望的输出向量 V_{i+1} # 题目递推式: f(n) = f(n-1) + 2f(n-2) + 5f(n-3) # 对应到我们的符号: 下一项 f3 = f2 + 2*f1 + 5*f0 f3 = f2 + 2 * f1 + 5 * f0 # 构造下一刻向量 V_{i+1} = [f(i+1), f(i+2), f(i+3)] v_next = [f1, f2, f3] # 5. 核心逻辑：构造约束 # 约束条件：M * v_current == v_next # 这个等式必须对“所有”的 f0, f1, f2 都成立 constraints = [] for r in range(3): # 矩阵乘法：第 r 行 点乘 输入向量 row_product = sum(M[r][c] * v_current[c] for c in range(3)) # 结果必须等于输出向量的对应项 constraints.append(row_product == v_next[r]) # 使用 ForAll (全称量词) # 读作：对于任意整数 f0, f1, f2，上述约束(And(constraints))都必须成立 s.add(ForAll([f0, f1, f2], And(constraints))) # 6. 求解并打印结果 if s.check() == sat: m = s.model() print("成功找到转移矩阵 M：") print("-" * 15) # 将 z3 的解转换为 Python 整数并格式化输出 for r in range(3): row_vals = [m.evaluate(M[r][c]).as_long() for c in range(3)] print(f"| {row_vals[0]:^3} {row_vals[1]:^3} {row_vals[2]:^3} |") print("-" * 15) # 验证一下文章开头的直觉 # 第一行应该是 0 1 0 (输出 f1) # 第二行应该是 0 0 1 (输出 f2) # 第三行应该是 5 2 1 (输出 5f0 + 2f1 + 1f2) else: print("未找到满足条件的矩阵。") if __name__ == "__main__": solve_transition_matrix() 用 Python 运行这段代码（当然你需要先使用 pip install z3-solver 来解决库的依赖），你会得到这样的输出：'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-06T08:53:37+08:00"><meta property="article:modified_time" content="2025-12-06T08:53:37+08:00"><meta property="article:tag" content="PLT"><meta property="article:tag" content="Lisp/Scheme/Racket"><meta property="og:see_also" content="https://litjohn.github.io/posts/bin-exp/"><meta property="og:see_also" content="https://litjohn.github.io/posts/start-to-build-a-compiler/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call-cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"><meta name=twitter:card content="summary"><meta name=twitter:title content="许愿机"><meta name=twitter:description content='光剑的后日谈 #3. 这次来聊聊什么是许愿机。
Some examples
现在我们需要写一段代码，用矩阵快速幂求解一个递推数列：
$$
\begin{cases}
f(0)=f(1)=f(2)=1 \\
f(n)=f(n-1)+2f(n-2)+5f(n-3), n \geq 3
\end{cases}
$$
我们知道我们将数列中的相邻几项写成一个向量 $(f(i), f(i+1), f(i+2))$，然后找到一个矩阵乘上它转移到下一个向量 $(f(i+1), f(i+2), f(i+3))$，那么这个矩阵怎么算呢？
猜肯定是一个办法，但肯定不好。手动求解，待定系数也是一种方法。
然而，我们还有更加优雅的做法。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61


from z3 import *

def solve_transition_matrix():
    # 1. 创建求解器
    s = Solver()

    # 2. 定义我们需要求解的 3x3 转移矩阵 M
    # 变量 m_r_c 代表矩阵第 r 行第 c 列的元素 (全是整数)
    M = [[Int(f&#39;m_{r}_{c}&#39;) for c in range(3)] for r in range(3)]

    # 3. 定义“任意”时刻的输入向量状态
    # 设 f0, f1, f2 分别代表 f(i), f(i+1), f(i+2)
    # 我们使用 Ints 创建符号变量，这些将作为全称量词的变量
    f0, f1, f2 = Ints(&#39;f0 f1 f2&#39;)

    # 构造当前向量 V_i
    v_current = [f0, f1, f2]

    # 4. 根据递推公式定义期望的输出向量 V_{i+1}
    # 题目递推式: f(n) = f(n-1) + 2f(n-2) + 5f(n-3)
    # 对应到我们的符号: 下一项 f3 = f2 + 2*f1 + 5*f0
    f3 = f2 + 2 * f1 + 5 * f0

    # 构造下一刻向量 V_{i+1} = [f(i+1), f(i+2), f(i+3)]
    v_next = [f1, f2, f3]

    # 5. 核心逻辑：构造约束
    # 约束条件：M * v_current == v_next
    # 这个等式必须对“所有”的 f0, f1, f2 都成立

    constraints = []
    for r in range(3):
        # 矩阵乘法：第 r 行 点乘 输入向量
        row_product = sum(M[r][c] * v_current[c] for c in range(3))
        # 结果必须等于输出向量的对应项
        constraints.append(row_product == v_next[r])

    # 使用 ForAll (全称量词)
    # 读作：对于任意整数 f0, f1, f2，上述约束(And(constraints))都必须成立
    s.add(ForAll([f0, f1, f2], And(constraints)))

    # 6. 求解并打印结果
    if s.check() == sat:
        m = s.model()
        print("成功找到转移矩阵 M：")
        print("-" * 15)
        # 将 z3 的解转换为 Python 整数并格式化输出
        for r in range(3):
            row_vals = [m.evaluate(M[r][c]).as_long() for c in range(3)]
            print(f"| {row_vals[0]:^3} {row_vals[1]:^3} {row_vals[2]:^3} |")
        print("-" * 15)

        # 验证一下文章开头的直觉
        # 第一行应该是 0 1 0 (输出 f1)
        # 第二行应该是 0 0 1 (输出 f2)
        # 第三行应该是 5 2 1 (输出 5f0 + 2f1 + 1f2)
    else:
        print("未找到满足条件的矩阵。")

if __name__ == "__main__":
    solve_transition_matrix()


用 Python 运行这段代码（当然你需要先使用 pip install z3-solver 来解决库的依赖），你会得到这样的输出：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"许愿机","item":"https://litjohn.github.io/posts/what-is-meant-by-miracle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"许愿机","name":"许愿机","description":"光剑的后日谈 #3. 这次来聊聊什么是许愿机。\nSome examples 现在我们需要写一段代码，用矩阵快速幂求解一个递推数列：\n$$ \\begin{cases} f(0)=f(1)=f(2)=1 \\\\ f(n)=f(n-1)+2f(n-2)+5f(n-3), n \\geq 3 \\end{cases} $$\n我们知道我们将数列中的相邻几项写成一个向量 $(f(i), f(i+1), f(i+2))$，然后找到一个矩阵乘上它转移到下一个向量 $(f(i+1), f(i+2), f(i+3))$，那么这个矩阵怎么算呢？\n猜肯定是一个办法，但肯定不好。手动求解，待定系数也是一种方法。\n然而，我们还有更加优雅的做法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from z3 import * def solve_transition_matrix(): # 1. 创建求解器 s = Solver() # 2. 定义我们需要求解的 3x3 转移矩阵 M # 变量 m_r_c 代表矩阵第 r 行第 c 列的元素 (全是整数) M = [[Int(f\u0026#39;m_{r}_{c}\u0026#39;) for c in range(3)] for r in range(3)] # 3. 定义“任意”时刻的输入向量状态 # 设 f0, f1, f2 分别代表 f(i), f(i+1), f(i+2) # 我们使用 Ints 创建符号变量，这些将作为全称量词的变量 f0, f1, f2 = Ints(\u0026#39;f0 f1 f2\u0026#39;) # 构造当前向量 V_i v_current = [f0, f1, f2] # 4. 根据递推公式定义期望的输出向量 V_{i+1} # 题目递推式: f(n) = f(n-1) + 2f(n-2) + 5f(n-3) # 对应到我们的符号: 下一项 f3 = f2 + 2*f1 + 5*f0 f3 = f2 + 2 * f1 + 5 * f0 # 构造下一刻向量 V_{i+1} = [f(i+1), f(i+2), f(i+3)] v_next = [f1, f2, f3] # 5. 核心逻辑：构造约束 # 约束条件：M * v_current == v_next # 这个等式必须对“所有”的 f0, f1, f2 都成立 constraints = [] for r in range(3): # 矩阵乘法：第 r 行 点乘 输入向量 row_product = sum(M[r][c] * v_current[c] for c in range(3)) # 结果必须等于输出向量的对应项 constraints.append(row_product == v_next[r]) # 使用 ForAll (全称量词) # 读作：对于任意整数 f0, f1, f2，上述约束(And(constraints))都必须成立 s.add(ForAll([f0, f1, f2], And(constraints))) # 6. 求解并打印结果 if s.check() == sat: m = s.model() print(\u0026#34;成功找到转移矩阵 M：\u0026#34;) print(\u0026#34;-\u0026#34; * 15) # 将 z3 的解转换为 Python 整数并格式化输出 for r in range(3): row_vals = [m.evaluate(M[r][c]).as_long() for c in range(3)] print(f\u0026#34;| {row_vals[0]:^3} {row_vals[1]:^3} {row_vals[2]:^3} |\u0026#34;) print(\u0026#34;-\u0026#34; * 15) # 验证一下文章开头的直觉 # 第一行应该是 0 1 0 (输出 f1) # 第二行应该是 0 0 1 (输出 f2) # 第三行应该是 5 2 1 (输出 5f0 + 2f1 + 1f2) else: print(\u0026#34;未找到满足条件的矩阵。\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: solve_transition_matrix() 用 Python 运行这段代码（当然你需要先使用 pip install z3-solver 来解决库的依赖），你会得到这样的输出：\n","keywords":["PLT","lisp/scheme/racket"],"articleBody":"光剑的后日谈 #3. 这次来聊聊什么是许愿机。\nSome examples 现在我们需要写一段代码，用矩阵快速幂求解一个递推数列：\n$$ \\begin{cases} f(0)=f(1)=f(2)=1 \\\\ f(n)=f(n-1)+2f(n-2)+5f(n-3), n \\geq 3 \\end{cases} $$\n我们知道我们将数列中的相邻几项写成一个向量 $(f(i), f(i+1), f(i+2))$，然后找到一个矩阵乘上它转移到下一个向量 $(f(i+1), f(i+2), f(i+3))$，那么这个矩阵怎么算呢？\n猜肯定是一个办法，但肯定不好。手动求解，待定系数也是一种方法。\n然而，我们还有更加优雅的做法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from z3 import * def solve_transition_matrix(): # 1. 创建求解器 s = Solver() # 2. 定义我们需要求解的 3x3 转移矩阵 M # 变量 m_r_c 代表矩阵第 r 行第 c 列的元素 (全是整数) M = [[Int(f'm_{r}_{c}') for c in range(3)] for r in range(3)] # 3. 定义“任意”时刻的输入向量状态 # 设 f0, f1, f2 分别代表 f(i), f(i+1), f(i+2) # 我们使用 Ints 创建符号变量，这些将作为全称量词的变量 f0, f1, f2 = Ints('f0 f1 f2') # 构造当前向量 V_i v_current = [f0, f1, f2] # 4. 根据递推公式定义期望的输出向量 V_{i+1} # 题目递推式: f(n) = f(n-1) + 2f(n-2) + 5f(n-3) # 对应到我们的符号: 下一项 f3 = f2 + 2*f1 + 5*f0 f3 = f2 + 2 * f1 + 5 * f0 # 构造下一刻向量 V_{i+1} = [f(i+1), f(i+2), f(i+3)] v_next = [f1, f2, f3] # 5. 核心逻辑：构造约束 # 约束条件：M * v_current == v_next # 这个等式必须对“所有”的 f0, f1, f2 都成立 constraints = [] for r in range(3): # 矩阵乘法：第 r 行 点乘 输入向量 row_product = sum(M[r][c] * v_current[c] for c in range(3)) # 结果必须等于输出向量的对应项 constraints.append(row_product == v_next[r]) # 使用 ForAll (全称量词) # 读作：对于任意整数 f0, f1, f2，上述约束(And(constraints))都必须成立 s.add(ForAll([f0, f1, f2], And(constraints))) # 6. 求解并打印结果 if s.check() == sat: m = s.model() print(\"成功找到转移矩阵 M：\") print(\"-\" * 15) # 将 z3 的解转换为 Python 整数并格式化输出 for r in range(3): row_vals = [m.evaluate(M[r][c]).as_long() for c in range(3)] print(f\"| {row_vals[0]:^3} {row_vals[1]:^3} {row_vals[2]:^3} |\") print(\"-\" * 15) # 验证一下文章开头的直觉 # 第一行应该是 0 1 0 (输出 f1) # 第二行应该是 0 0 1 (输出 f2) # 第三行应该是 5 2 1 (输出 5f0 + 2f1 + 1f2) else: print(\"未找到满足条件的矩阵。\") if __name__ == \"__main__\": solve_transition_matrix() 用 Python 运行这段代码（当然你需要先使用 pip install z3-solver 来解决库的依赖），你会得到这样的输出：\n1 2 3 4 5 6 成功找到转移矩阵 M： --------------- | 0 1 0 | | 0 0 1 | | 5 2 1 | --------------- 看上去非常对。\n当然你可能还会说：“这不就是一个自动解线性方程组的机器吗？没什么特别的。”不过 Z3 的威力不止于此。看看下面这个场景：\n你正在写一段底层高性能代码，需要计算一个 32 位整数的绝对值 abs(x)。\n但是，CPU 的分支预测（Branch Prediction）失败代价很高，你不希望使用 if (x \u003c 0) 这种跳转指令。\n你听说高手都用位运算骚操作（Bit Hacks）来实现无分支编程，但你不知道公式是什么。\n我们给出一个计算模板，让 Z3 帮我们要找到对应的位移常数，自动“写”出这段黑客代码。\n我们猜测公式大概长这样：(x + A) ^ A （这是一种常见的异或技巧）。\n我们要让 Z3 帮我们确定 A 到底应该等于多少（A 可能是 x 移位后的结果）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from z3 import * def synthesize_abs_hack(): # 1. 创建求解器 s = Solver() # 2. 定义输入 x 是一个 32 位的位向量 (BitVector) x = BitVec('x', 32) # 3. 定义我们的“目标规范” (Specification) # 即我们希望代码实现的功能：如果是负数取反，否则不变 # 注意：在位运算世界里，-x 等价于 (~x + 1) target = If(x \u003c 0, -x, x) # 4. 定义我们的“实现模板” (Implementation Template) # 我们猜测无分支绝对值可以通过 (x + mask) ^ mask 来实现 # 其中 mask 是 x 向右移动 k 位得到的 # 我们不知道 k 是多少，让 Z3 去找这个 k k = BitVec('k', 32) # k 是我们要寻找的“魔法常数” # 算术右移 (x \u003e\u003e k) 生成掩码 mask = x \u003e\u003e k # 我们的猜想公式 implementation = (x + mask) ^ mask # 5. 核心约束：等价性验证 # 我们要求：对于“任意”一个 32 位整数 x，实现必须等于目标 # 注意：k 必须是一个固定的常数，不能随 x 变化，所以 k 在 ForAll 之外 s.add(ForAll([x], implementation == target)) # 6. 添加一些合理的范围约束，加速求解 # 移位位数 k 应该在 0 到 31 之间 s.add(k \u003e= 0, k \u003c 32) # 7. 求解 if s.check() == sat: m = s.model() print(\"Z3 找到了魔法常数 k！\") k_val = m[k].as_long() print(f\"k = {k_val}\") print(\"-\" * 30) print(\"生成的无分支绝对值代码 (C/C++):\") print(f\"int abs_hack(int x) {{\") print(f\" int mask = x \u003e\u003e {k_val};\") print(f\" return (x + mask) ^ mask;\") print(f\"}}\") else: print(\"也就是个猜想，看来这个模板行不通。\") if __name__ == \"__main__\": synthesize_abs_hack() 很快，你就会得到这样的输出：\n1 2 3 4 5 6 7 8 Z3 找到了魔法常数 k！ k = 31 ------------------------------ 生成的无分支绝对值代码 (C/C++): int abs_hack(int x) { int mask = x \u003e\u003e 31; return (x + mask) ^ mask; } 于是我们就解决了这个问题。\nWhat is meant by miracle? 奇迹的力量 聊了这么久，你可能会发现我还没有讲 Z3 是什么？\n事实上，正如这篇文章的标题，Z3 是一个许愿机。\n它是一个 SMT（模理论可满足性）求解器。核心是一个 SAT（布尔可满足性，就是那个著名的 NPC）求解器，外部加上了许多理论的扩展。\n理论扩展使得 SMT 求解器远比 SAT 更强大。\nSAT 中变量是原子，求解器看不到里面，就像 0 阶逻辑（命题逻辑）。\n而 SMT 中，理论让求解器可以拆开一个公式子句，并获取不同子句间更深层的关系（比如 x\u003e0 和 x\u003c0 是矛盾的）。也让我们能够用更丰富的语言写给求解器的公式。\n我们用求解器支持的语言给它一个公式，它就自动判定这个公式是否是可满足的，如果可满足，就会给出一组解。\n就像我们用公式向许愿机许下一个愿望，它就自动显灵。\n奇迹的代价 强大的奇迹自然也有它的代价。众所周知，SAT 是一个 NPC 问题。也就是说，SMT 求解器在最坏情况下的复杂度是指数级（或至少超多项式）的。\n而 Z3 中的一些理论甚至比 SAT 还要困难，达到了 Pspace-complete 甚至 undecidable 边缘的程度。比如说 NRA（非线性实数算术），求解复杂度是双指数（$2^{2^n}$）。而 NIA（非线性整数算术）等一些理论，甚至是不可判定的（停机问题可以规约到 NIA）\nSMT 求解器之所以有用，是因为它使用了强大的启发式搜索算法（最重要的是 CDCL，冲突驱动子句学习），利用工业实例的特殊结构化特性达到了非常优秀的平均复杂度。\n奇迹的应用 上面已经展示了两个例子。不过这些还不够复杂。并且不是 racket 写的\n接下来我们将用求解器解决一些更复杂的问题。这里需要提到 Rosette，一个 racket 项目，也是一个杀手级应用。你可以用 raco pkg install rosette 下载它。\n2024 年提高组初赛有这么一道题：\n1 2 3 int logic(int x, int y) { return (x \u0026 y) ^ ((x ^ y) | (~x \u0026 y)); } 以上函数的功能是什么？\n硬分析当然可以，但是太吃操作。大部分人场上可能是代入具体值做的，然而这不能保证 100% 正确，并且场上的 D 选项还是“以上都不是”。\n让我们来向许愿机许下这个愿望。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #lang rosette ; 1. 定义类型：模拟 C++ 的 int (32位有符号整数) (define int32? (bitvector 32)) ; --------------------------------------------------------- ; 2. 目标函数 (C++ 逻辑的精确翻译) ; --------------------------------------------------------- ; C++: (x \u0026 y) ^ ((x ^ y) | (~x \u0026 y)) ; ; Rosette 映射表: ; \u0026 -\u003e bvand ; | -\u003e bvor ; ^ -\u003e bvxor ; ~ -\u003e bvnot (define (target-logic x y) (bvxor (bvand x y) (bvor (bvxor x y) (bvand (bvnot x) y)))) ; --------------------------------------------------------- ; 3. 用户待验证的函数 (在这里填入你的实现) ; --------------------------------------------------------- (define (user-logic x y) ; 猜测：原逻辑推导后其实等价于 (x | y) ; 你可以试着把这里改成 (bvxor x y) 看看验证失败的效果 (bvor x y) ) ; --------------------------------------------------------- ; 4. 验证过程 ; --------------------------------------------------------- ; 定义两个符号变量，类型为 32位位向量 (define-symbolic x-sym int32?) (define-symbolic y-sym int32?) ; 验证查询：是否存在一组输入 (x, y)，使得两函数输出不相等？ ; verify 会尝试寻找反例 (counterexample) (define ce (verify (assert (equal? (target-logic x-sym y-sym) (user-logic x-sym y-sym))))) ; --------------------------------------------------------- ; 5. 输出结果处理 ; --------------------------------------------------------- (if (unsat? ce) (printf \"验证成功：两个函数在 32 位整数范围内是完全等价的！\\n\") (begin (printf \"验证失败：函数不等价。\\n\") (printf \"找到反例 (Counterexample):\\n\") ; 从模型中提取具体的位向量值 (define ce-x (evaluate x-sym ce)) (define ce-y (evaluate y-sym ce)) ; 为了方便阅读，将位向量转换为普通整数显示 (printf \"x = ~a (Hex: ~a)\\n\" (bitvector-\u003einteger ce-x) ce-x) (printf \"y = ~a (Hex: ~a)\\n\" (bitvector-\u003einteger ce-y) ce-y) (printf \"------------------------\\n\") (printf \"Target 输出: ~a\\n\" (target-logic ce-x ce-y)) (printf \"User 输出: ~a\\n\" (user-logic ce-x ce-y)) )) 我们发现 bvor（即按位或）正是这个函数的等价物。而如果你改成 bvand/bvxor 则会得到 unsat 以及反例。这个问题就解决了。\n这类东西在夺旗赛（CTF）中非常有用。你可以猜测一个被混淆了的表达式实际上是什么，然后利用 Rosette 的 verify 去验证是不是这么回事。\n在形式化验证领域也非常有用。你可以写好一些规范，然后 verify 一下你的程序是否符合这些规范。一个特例是 verify 你的程序的输出是否和暴力相同，即对拍。不过形式化方法可以确保程序 100% 必定符合规范，而不像对拍可能会遗漏 corner。\n到这里我们就展示了 Rosette 的 synthesize 和 verify 能力，它们一个给指定的规范寻找解（exist 量词），另一个判断指定规范是否永远正确（forall 量词）。Rosette 还有一个“天使执行”能力，可以造出让你的代码运行到某个指定 case 的数据，但是太复杂所以我们不讲（在入门中也用不到）。\nracket 真是一个秘密武器。在某些领域威力简直无可匹敌。比如说形式化验证。又比如，写一个求解数独的程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #lang rosette ; 0. 初始时等待完善的数独。0 代表空位。 (define org #(#(0 0 0 0 0 0 0 0 0) #(0 0 0 0 0 0 0 0 0) #(0 0 0 0 0 0 0 0 0) #(0 0 0 0 0 0 0 0 0) #(0 0 0 0 0 0 0 0 0) #(0 0 0 0 0 0 0 0 0) #(0 0 0 0 0 0 0 0 0) #(0 0 0 0 0 0 0 0 0) #(0 0 0 0 0 0 0 0 0))) ; 1. 定义 9x9 的符号变量矩阵 (define a (for/vector ([i (in-range 9)]) (for/vector ([j (in-range 9)]) (let ([x (vector-ref (vector-ref org i) j)]) (if (zero? x) (begin (define-symbolic* sym integer?) sym) x))))) ; 2. 定义约束并求解 (define solution (solve (begin ; 约束 A: 所有数字必须在 1 到 9 之间 (for* ([row a] [x row]) (assert (and (\u003e= x 1) (\u003c= x 9)))) ; 约束 B: 每一行必须互不相同 (Row restriction) (for ([row a]) ; distinct? 接受变长参数，所以我们要把 vector 转为 list 并 apply (assert (apply distinct? (vector-\u003elist row)))) ; 约束 C: 每一列必须互不相同 (for ([j (in-range 9)]) (define col (for/list ([i (in-range 9)]) (vector-ref (vector-ref a i) j))) (assert (apply distinct? col))) ; 约束 D: 每个宫格不能有相同数字 (for* ([i '(0 3 6)] [j '(0 3 6)]) (assert (apply distinct? (for*/list ([k (in-range 3)] [l (in-range 3)]) (vector-ref (vector-ref a (+ i k)) (+ j l))))))))) ; 3. 输出结果 (if (sat? solution) (let ([concrete-a (evaluate a solution)]) (displayln \"Found a solution:\") (displayln concrete-a)) (displayln \"No solution!\")) 求解数独是（迄今为止）不能多项式的（数独是 NPC）。经典算法是 DLX。但假如说我增加一些限制，比如 9*9 网格的两条对角线上也不能有相同元素呢？或者比如说第一列有恰好两个 1，第 i 列有恰好两个 i 呢？DLX 就比较难以拓展了。\nSMT 则能够方便地添加更多的约束以适应种种变体。你可以自己试一试。\n","wordCount":"1388","inLanguage":"en","datePublished":"2025-12-06T08:53:37+08:00","dateModified":"2025-12-06T08:53:37+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/what-is-meant-by-miracle/"},"publisher":{"@type":"Organization","name":"正确即是废话，废话亦是正确","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="正确即是废话，废话亦是正确 (Alt + H)">正确即是废话，废话亦是正确</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://litjohn.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">许愿机</h1><div class=post-meta><span title='2025-12-06 08:53:37 +0800 +0800'>December 6, 2025</span></div></header><div class=post-content><p>光剑的后日谈 #3. 这次来聊聊什么是许愿机。</p><h2 id=some-examples>Some examples<a hidden class=anchor aria-hidden=true href=#some-examples>#</a></h2><p>现在我们需要写一段代码，用矩阵快速幂求解一个递推数列：</p><p>$$
\begin{cases}
f(0)=f(1)=f(2)=1 \\
f(n)=f(n-1)+2f(n-2)+5f(n-3), n \geq 3
\end{cases}
$$</p><p>我们知道我们将数列中的相邻几项写成一个向量 $(f(i), f(i+1), f(i+2))$，然后找到一个矩阵乘上它转移到下一个向量 $(f(i+1), f(i+2), f(i+3))$，那么这个矩阵怎么算呢？</p><p>猜肯定是一个办法，但肯定不好。手动求解，待定系数也是一种方法。</p><p>然而，我们还有更加优雅的做法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>z3</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_transition_matrix</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 1. 创建求解器</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>Solver</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 2. 定义我们需要求解的 3x3 转移矩阵 M</span>
</span></span><span class=line><span class=cl>    <span class=c1># 变量 m_r_c 代表矩阵第 r 行第 c 列的元素 (全是整数)</span>
</span></span><span class=line><span class=cl>    <span class=n>M</span> <span class=o>=</span> <span class=p>[[</span><span class=n>Int</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;m_</span><span class=si>{</span><span class=n>r</span><span class=si>}</span><span class=s1>_</span><span class=si>{</span><span class=n>c</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>)]</span> <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 3. 定义“任意”时刻的输入向量状态</span>
</span></span><span class=line><span class=cl>    <span class=c1># 设 f0, f1, f2 分别代表 f(i), f(i+1), f(i+2)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 我们使用 Ints 创建符号变量，这些将作为全称量词的变量</span>
</span></span><span class=line><span class=cl>    <span class=n>f0</span><span class=p>,</span> <span class=n>f1</span><span class=p>,</span> <span class=n>f2</span> <span class=o>=</span> <span class=n>Ints</span><span class=p>(</span><span class=s1>&#39;f0 f1 f2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 构造当前向量 V_i</span>
</span></span><span class=line><span class=cl>    <span class=n>v_current</span> <span class=o>=</span> <span class=p>[</span><span class=n>f0</span><span class=p>,</span> <span class=n>f1</span><span class=p>,</span> <span class=n>f2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 4. 根据递推公式定义期望的输出向量 V_{i+1}</span>
</span></span><span class=line><span class=cl>    <span class=c1># 题目递推式: f(n) = f(n-1) + 2f(n-2) + 5f(n-3)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 对应到我们的符号: 下一项 f3 = f2 + 2*f1 + 5*f0</span>
</span></span><span class=line><span class=cl>    <span class=n>f3</span> <span class=o>=</span> <span class=n>f2</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>f1</span> <span class=o>+</span> <span class=mi>5</span> <span class=o>*</span> <span class=n>f0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 构造下一刻向量 V_{i+1} = [f(i+1), f(i+2), f(i+3)]</span>
</span></span><span class=line><span class=cl>    <span class=n>v_next</span> <span class=o>=</span> <span class=p>[</span><span class=n>f1</span><span class=p>,</span> <span class=n>f2</span><span class=p>,</span> <span class=n>f3</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 5. 核心逻辑：构造约束</span>
</span></span><span class=line><span class=cl>    <span class=c1># 约束条件：M * v_current == v_next</span>
</span></span><span class=line><span class=cl>    <span class=c1># 这个等式必须对“所有”的 f0, f1, f2 都成立</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>constraints</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 矩阵乘法：第 r 行 点乘 输入向量</span>
</span></span><span class=line><span class=cl>        <span class=n>row_product</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>M</span><span class=p>[</span><span class=n>r</span><span class=p>][</span><span class=n>c</span><span class=p>]</span> <span class=o>*</span> <span class=n>v_current</span><span class=p>[</span><span class=n>c</span><span class=p>]</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1># 结果必须等于输出向量的对应项</span>
</span></span><span class=line><span class=cl>        <span class=n>constraints</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>row_product</span> <span class=o>==</span> <span class=n>v_next</span><span class=p>[</span><span class=n>r</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 使用 ForAll (全称量词)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 读作：对于任意整数 f0, f1, f2，上述约束(And(constraints))都必须成立</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>ForAll</span><span class=p>([</span><span class=n>f0</span><span class=p>,</span> <span class=n>f1</span><span class=p>,</span> <span class=n>f2</span><span class=p>],</span> <span class=n>And</span><span class=p>(</span><span class=n>constraints</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 6. 求解并打印结果</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>s</span><span class=o>.</span><span class=n>check</span><span class=p>()</span> <span class=o>==</span> <span class=n>sat</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=n>model</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;成功找到转移矩阵 M：&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;-&#34;</span> <span class=o>*</span> <span class=mi>15</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 将 z3 的解转换为 Python 整数并格式化输出</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>row_vals</span> <span class=o>=</span> <span class=p>[</span><span class=n>m</span><span class=o>.</span><span class=n>evaluate</span><span class=p>(</span><span class=n>M</span><span class=p>[</span><span class=n>r</span><span class=p>][</span><span class=n>c</span><span class=p>])</span><span class=o>.</span><span class=n>as_long</span><span class=p>()</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;| </span><span class=si>{</span><span class=n>row_vals</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=si>:</span><span class=s2>^3</span><span class=si>}</span><span class=s2> </span><span class=si>{</span><span class=n>row_vals</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=si>:</span><span class=s2>^3</span><span class=si>}</span><span class=s2> </span><span class=si>{</span><span class=n>row_vals</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=si>:</span><span class=s2>^3</span><span class=si>}</span><span class=s2> |&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;-&#34;</span> <span class=o>*</span> <span class=mi>15</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 验证一下文章开头的直觉</span>
</span></span><span class=line><span class=cl>        <span class=c1># 第一行应该是 0 1 0 (输出 f1)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 第二行应该是 0 0 1 (输出 f2)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 第三行应该是 5 2 1 (输出 5f0 + 2f1 + 1f2)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;未找到满足条件的矩阵。&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>solve_transition_matrix</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>用 Python 运行这段代码（当然你需要先使用 <code>pip install z3-solver</code> 来解决库的依赖），你会得到这样的输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>成功找到转移矩阵 M：
</span></span><span class=line><span class=cl>---------------
</span></span><span class=line><span class=cl>|  0   1   0  |
</span></span><span class=line><span class=cl>|  0   0   1  |
</span></span><span class=line><span class=cl>|  5   2   1  |
</span></span><span class=line><span class=cl>---------------
</span></span></code></pre></td></tr></table></div></div><p>看上去非常对。</p><p>当然你可能还会说：“这不就是一个自动解线性方程组的机器吗？没什么特别的。”不过 Z3 的威力不止于此。看看下面这个场景：</p><p>你正在写一段底层高性能代码，需要计算一个 32 位整数的绝对值 <code>abs(x)</code>。<br>但是，CPU 的分支预测（Branch Prediction）失败代价很高，你不希望使用 <code>if (x &lt; 0)</code> 这种跳转指令。<br>你听说高手都用位运算骚操作（Bit Hacks）来实现无分支编程，但你不知道公式是什么。</p><p>我们给出一个计算模板，让 Z3 帮我们要找到对应的位移常数，自动“写”出这段黑客代码。<br>我们猜测公式大概长这样：(x + A) ^ A （这是一种常见的异或技巧）。<br>我们要让 Z3 帮我们确定 A 到底应该等于多少（A 可能是 x 移位后的结果）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>z3</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>synthesize_abs_hack</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 1. 创建求解器</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>Solver</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 2. 定义输入 x 是一个 32 位的位向量 (BitVector)</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>BitVec</span><span class=p>(</span><span class=s1>&#39;x&#39;</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 3. 定义我们的“目标规范” (Specification)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 即我们希望代码实现的功能：如果是负数取反，否则不变</span>
</span></span><span class=line><span class=cl>    <span class=c1># 注意：在位运算世界里，-x 等价于 (~x + 1)</span>
</span></span><span class=line><span class=cl>    <span class=n>target</span> <span class=o>=</span> <span class=n>If</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=n>x</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 4. 定义我们的“实现模板” (Implementation Template)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 我们猜测无分支绝对值可以通过 (x + mask) ^ mask 来实现</span>
</span></span><span class=line><span class=cl>    <span class=c1># 其中 mask 是 x 向右移动 k 位得到的</span>
</span></span><span class=line><span class=cl>    <span class=c1># 我们不知道 k 是多少，让 Z3 去找这个 k</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>=</span> <span class=n>BitVec</span><span class=p>(</span><span class=s1>&#39;k&#39;</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span> <span class=c1># k 是我们要寻找的“魔法常数”</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 算术右移 (x &gt;&gt; k) 生成掩码</span>
</span></span><span class=line><span class=cl>    <span class=n>mask</span> <span class=o>=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=n>k</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 我们的猜想公式</span>
</span></span><span class=line><span class=cl>    <span class=n>implementation</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>mask</span><span class=p>)</span> <span class=o>^</span> <span class=n>mask</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 5. 核心约束：等价性验证</span>
</span></span><span class=line><span class=cl>    <span class=c1># 我们要求：对于“任意”一个 32 位整数 x，实现必须等于目标</span>
</span></span><span class=line><span class=cl>    <span class=c1># 注意：k 必须是一个固定的常数，不能随 x 变化，所以 k 在 ForAll 之外</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>ForAll</span><span class=p>([</span><span class=n>x</span><span class=p>],</span> <span class=n>implementation</span> <span class=o>==</span> <span class=n>target</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 6. 添加一些合理的范围约束，加速求解</span>
</span></span><span class=line><span class=cl>    <span class=c1># 移位位数 k 应该在 0 到 31 之间</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>k</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=mi>32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 7. 求解</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>s</span><span class=o>.</span><span class=n>check</span><span class=p>()</span> <span class=o>==</span> <span class=n>sat</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=n>model</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Z3 找到了魔法常数 k！&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>k_val</span> <span class=o>=</span> <span class=n>m</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>.</span><span class=n>as_long</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;k = </span><span class=si>{</span><span class=n>k_val</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;-&#34;</span> <span class=o>*</span> <span class=mi>30</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;生成的无分支绝对值代码 (C/C++):&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;int abs_hack(int x) </span><span class=se>{{</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    int mask = x &gt;&gt; </span><span class=si>{</span><span class=n>k_val</span><span class=si>}</span><span class=s2>;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    return (x + mask) ^ mask;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=se>}}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;也就是个猜想，看来这个模板行不通。&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>synthesize_abs_hack</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>很快，你就会得到这样的输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>Z3 找到了魔法常数 k！
</span></span><span class=line><span class=cl>k = 31
</span></span><span class=line><span class=cl>------------------------------
</span></span><span class=line><span class=cl>生成的无分支绝对值代码 (C/C++):
</span></span><span class=line><span class=cl>int abs_hack(int x) {
</span></span><span class=line><span class=cl>    int mask = x &gt;&gt; 31;
</span></span><span class=line><span class=cl>    return (x + mask) ^ mask;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>于是我们就解决了这个问题。</p><h2 id=what-is-meant-by-miracle>What is meant by miracle?<a hidden class=anchor aria-hidden=true href=#what-is-meant-by-miracle>#</a></h2><h3 id=奇迹的力量>奇迹的力量<a hidden class=anchor aria-hidden=true href=#奇迹的力量>#</a></h3><p>聊了这么久，你可能会发现我还没有讲 Z3 是什么？</p><p>事实上，正如这篇文章的标题，Z3 是一个许愿机。</p><p>它是一个 SMT（模理论可满足性）求解器。核心是一个 SAT（布尔可满足性，就是那个著名的 NPC）求解器，外部加上了许多理论的扩展。</p><p>理论扩展使得 SMT 求解器远比 SAT 更强大。</p><p>SAT 中变量是原子，求解器看不到里面，就像 0 阶逻辑（命题逻辑）。<br>而 SMT 中，理论让求解器可以拆开一个公式子句，并获取不同子句间更深层的关系（比如 <code>x>0</code> 和 <code>x&lt;0</code> 是矛盾的）。也让我们能够用更丰富的语言写给求解器的公式。</p><p>我们用求解器支持的语言给它一个公式，它就自动判定这个公式是否是可满足的，如果可满足，就会给出一组解。</p><p>就像我们用公式向许愿机许下一个愿望，它就自动显灵。</p><h3 id=奇迹的代价>奇迹的代价<a hidden class=anchor aria-hidden=true href=#奇迹的代价>#</a></h3><p>强大的奇迹自然也有它的代价。众所周知，SAT 是一个 NPC 问题。也就是说，SMT 求解器在最坏情况下的复杂度是指数级（或至少超多项式）的。</p><p>而 Z3 中的一些理论甚至比 SAT 还要困难，达到了 Pspace-complete 甚至 undecidable 边缘的程度。比如说 NRA（非线性实数算术），求解复杂度是双指数（$2^{2^n}$）。而 NIA（非线性整数算术）等一些理论，甚至是不可判定的（停机问题可以规约到 NIA）</p><p>SMT 求解器之所以有用，是因为它使用了强大的启发式搜索算法（最重要的是 CDCL，冲突驱动子句学习），利用工业实例的特殊结构化特性达到了非常优秀的平均复杂度。</p><h3 id=奇迹的应用>奇迹的应用<a hidden class=anchor aria-hidden=true href=#奇迹的应用>#</a></h3><p>上面已经展示了两个例子。不过这些还不够复杂。<del>并且不是 racket 写的</del></p><p>接下来我们将用求解器解决一些更复杂的问题。这里需要提到 Rosette，一个 racket 项目，也是一个杀手级应用。你可以用 <code>raco pkg install rosette</code> 下载它。</p><p>2024 年提高组初赛有这么一道题：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>logic</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>y</span><span class=p>)</span> <span class=o>^</span> <span class=p>((</span><span class=n>x</span> <span class=o>^</span> <span class=n>y</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=o>~</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>以上函数的功能是什么？</p><p>硬分析当然可以，但是太吃操作。大部分人场上可能是代入具体值做的，然而这不能保证 100% 正确，并且场上的 D 选项还是“以上都不是”。</p><p>让我们来向许愿机许下这个愿望。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>rosette</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 1. 定义类型：模拟 C++ 的 int (32位有符号整数)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>int32?</span> <span class=p>(</span><span class=n>bitvector</span> <span class=mi>32</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>; 2. 目标函数 (C++ 逻辑的精确翻译)</span>
</span></span><span class=line><span class=cl><span class=c1>; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>; C++: (x &amp; y) ^ ((x ^ y) | (~x &amp; y))</span>
</span></span><span class=line><span class=cl><span class=c1>;</span>
</span></span><span class=line><span class=cl><span class=c1>; Rosette 映射表:</span>
</span></span><span class=line><span class=cl><span class=c1>; &amp;  -&gt; bvand</span>
</span></span><span class=line><span class=cl><span class=c1>; |  -&gt; bvor</span>
</span></span><span class=line><span class=cl><span class=c1>; ^  -&gt; bvxor</span>
</span></span><span class=line><span class=cl><span class=c1>; ~  -&gt; bvnot</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>target-logic</span> <span class=n>x</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>bvxor</span> <span class=p>(</span><span class=n>bvand</span> <span class=n>x</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>bvor</span> <span class=p>(</span><span class=n>bvxor</span> <span class=n>x</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=n>bvand</span> <span class=p>(</span><span class=n>bvnot</span> <span class=n>x</span><span class=p>)</span> <span class=n>y</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>; 3. 用户待验证的函数 (在这里填入你的实现)</span>
</span></span><span class=line><span class=cl><span class=c1>; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>user-logic</span> <span class=n>x</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>; 猜测：原逻辑推导后其实等价于 (x | y)</span>
</span></span><span class=line><span class=cl>  <span class=c1>; 你可以试着把这里改成 (bvxor x y) 看看验证失败的效果</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>bvor</span> <span class=n>x</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>; 4. 验证过程</span>
</span></span><span class=line><span class=cl><span class=c1>; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 定义两个符号变量，类型为 32位位向量</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>define-symbolic</span> <span class=n>x-sym</span> <span class=n>int32?</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>define-symbolic</span> <span class=n>y-sym</span> <span class=n>int32?</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 验证查询：是否存在一组输入 (x, y)，使得两函数输出不相等？</span>
</span></span><span class=line><span class=cl><span class=c1>; verify 会尝试寻找反例 (counterexample)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>ce</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>verify</span> <span class=p>(</span><span class=n>assert</span> <span class=p>(</span><span class=nb>equal?</span> <span class=p>(</span><span class=n>target-logic</span> <span class=n>x-sym</span> <span class=n>y-sym</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                          <span class=p>(</span><span class=n>user-logic</span> <span class=n>x-sym</span> <span class=n>y-sym</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1>; 5. 输出结果处理</span>
</span></span><span class=line><span class=cl><span class=c1>; ---------------------------------------------------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>unsat?</span> <span class=n>ce</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;验证成功：两个函数在 32 位整数范围内是完全等价的！</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>begin</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;验证失败：函数不等价。</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;找到反例 (Counterexample):</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>; 从模型中提取具体的位向量值</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>ce-x</span> <span class=p>(</span><span class=n>evaluate</span> <span class=n>x-sym</span> <span class=n>ce</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>define</span> <span class=n>ce-y</span> <span class=p>(</span><span class=n>evaluate</span> <span class=n>y-sym</span> <span class=n>ce</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>; 为了方便阅读，将位向量转换为普通整数显示</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;x = ~a (Hex: ~a)</span><span class=se>\n</span><span class=s2>&#34;</span> <span class=p>(</span><span class=n>bitvector-&gt;integer</span> <span class=n>ce-x</span><span class=p>)</span> <span class=n>ce-x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;y = ~a (Hex: ~a)</span><span class=se>\n</span><span class=s2>&#34;</span> <span class=p>(</span><span class=n>bitvector-&gt;integer</span> <span class=n>ce-y</span><span class=p>)</span> <span class=n>ce-y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;------------------------</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;Target 输出: ~a</span><span class=se>\n</span><span class=s2>&#34;</span> <span class=p>(</span><span class=n>target-logic</span> <span class=n>ce-x</span> <span class=n>ce-y</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>printf</span> <span class=s2>&#34;User   输出: ~a</span><span class=se>\n</span><span class=s2>&#34;</span> <span class=p>(</span><span class=n>user-logic</span> <span class=n>ce-x</span> <span class=n>ce-y</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>我们发现 bvor（即按位或）正是这个函数的等价物。而如果你改成 bvand/bvxor 则会得到 unsat 以及反例。这个问题就解决了。</p><p>这类东西在夺旗赛（CTF）中非常有用。你可以猜测一个被混淆了的表达式实际上是什么，然后利用 Rosette 的 verify 去验证是不是这么回事。</p><p>在形式化验证领域也非常有用。你可以写好一些规范，然后 verify 一下你的程序是否符合这些规范。一个特例是 verify 你的程序的输出是否和暴力相同，即对拍。不过形式化方法可以确保程序 100% 必定符合规范，而不像对拍可能会遗漏 corner。</p><p>到这里我们就展示了 Rosette 的 synthesize 和 verify 能力，它们一个给指定的规范寻找解（exist 量词），另一个判断指定规范是否永远正确（forall 量词）。Rosette 还有一个“天使执行”能力，可以造出让你的代码运行到某个指定 case 的数据，但是太复杂所以我们不讲（在入门中也用不到）。</p><p>racket 真是一个秘密武器。在某些领域威力简直无可匹敌。比如说形式化验证。又比如，写一个求解数独的程序。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>rosette</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 0. 初始时等待完善的数独。0 代表空位。</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>org</span>
</span></span><span class=line><span class=cl>  <span class=o>#</span><span class=p>(</span><span class=o>#</span><span class=p>(</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>#</span><span class=p>(</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>#</span><span class=p>(</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>#</span><span class=p>(</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>#</span><span class=p>(</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>#</span><span class=p>(</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>#</span><span class=p>(</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>#</span><span class=p>(</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>#</span><span class=p>(</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 1. 定义 9x9 的符号变量矩阵</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>for/vector</span> <span class=p>([</span><span class=n>i</span> <span class=p>(</span><span class=nb>in-range</span> <span class=mi>9</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>for/vector</span> <span class=p>([</span><span class=n>j</span> <span class=p>(</span><span class=nb>in-range</span> <span class=mi>9</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>x</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>org</span> <span class=n>i</span><span class=p>)</span> <span class=n>j</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>zero?</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=k>begin</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=n>define-symbolic*</span> <span class=n>sym</span> <span class=nb>integer?</span><span class=p>)</span>
</span></span><span class=line><span class=cl>             <span class=n>sym</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=n>x</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 2. 定义约束并求解</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>solution</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>solve</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=k>begin</span>
</span></span><span class=line><span class=cl>     <span class=c1>; 约束 A: 所有数字必须在 1 到 9 之间</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>for*</span> <span class=p>([</span><span class=n>row</span> <span class=n>a</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=n>x</span> <span class=n>row</span><span class=p>])</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=n>assert</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>&gt;=</span> <span class=n>x</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=nb>&lt;=</span> <span class=n>x</span> <span class=mi>9</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     <span class=c1>; 约束 B: 每一行必须互不相同 (Row restriction)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>for</span> <span class=p>([</span><span class=n>row</span> <span class=n>a</span><span class=p>])</span>
</span></span><span class=line><span class=cl>       <span class=c1>; distinct? 接受变长参数，所以我们要把 vector 转为 list 并 apply</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=n>assert</span> <span class=p>(</span><span class=nb>apply</span> <span class=n>distinct?</span> <span class=p>(</span><span class=nb>vector-&gt;list</span> <span class=n>row</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     <span class=c1>; 约束 C: 每一列必须互不相同</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>for</span> <span class=p>([</span><span class=n>j</span> <span class=p>(</span><span class=nb>in-range</span> <span class=mi>9</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=k>define</span> <span class=n>col</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>for/list</span> <span class=p>([</span><span class=n>i</span> <span class=p>(</span><span class=nb>in-range</span> <span class=mi>9</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=nb>vector-ref</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>i</span><span class=p>)</span> <span class=n>j</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=n>assert</span> <span class=p>(</span><span class=nb>apply</span> <span class=n>distinct?</span> <span class=n>col</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     <span class=c1>; 约束 D: 每个宫格不能有相同数字</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=k>for*</span> <span class=p>([</span><span class=n>i</span> <span class=o>&#39;</span><span class=p>(</span><span class=mi>0</span> <span class=mi>3</span> <span class=mi>6</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=n>j</span> <span class=o>&#39;</span><span class=p>(</span><span class=mi>0</span> <span class=mi>3</span> <span class=mi>6</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=n>assert</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>apply</span> <span class=n>distinct?</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=k>for*/list</span> <span class=p>([</span><span class=n>k</span> <span class=p>(</span><span class=nb>in-range</span> <span class=mi>3</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>                           <span class=p>[</span><span class=n>l</span> <span class=p>(</span><span class=nb>in-range</span> <span class=mi>3</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>vector-ref</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=n>k</span><span class=p>))</span> <span class=p>(</span><span class=nb>+</span> <span class=n>j</span> <span class=n>l</span><span class=p>)))))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 3. 输出结果</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>sat?</span> <span class=n>solution</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>concrete-a</span> <span class=p>(</span><span class=n>evaluate</span> <span class=n>a</span> <span class=n>solution</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;Found a solution:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>displayln</span> <span class=n>concrete-a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;No solution!&#34;</span><span class=p>))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>求解数独是（迄今为止）不能多项式的（数独是 NPC）。经典算法是 DLX。但假如说我增加一些限制，比如 9*9 网格的两条对角线上也不能有相同元素呢？或者比如说第一列有恰好两个 1，第 i 列有恰好两个 i 呢？DLX 就比较难以拓展了。</p><p>SMT 则能够方便地添加更多的约束以适应种种变体。你可以自己试一试。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/plt/>PLT</a></li><li><a href=https://litjohn.github.io/tags/lisp/scheme/racket/>Lisp/Scheme/Racket</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>正确即是废话，废话亦是正确</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>