<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>May the force be with you | 正确即是废话，废话亦是正确</title><meta name=keywords content><meta name=description content="假设你刚刚看过这篇文章：浅谈valarray。
现在我们需要模仿 valarray 写一个科学计算库。其中，我们需要支持形如 a + b 的写法，a 和 b 是两个向量，这个表达式的值是两个向量的和，即逐元素相加得到的新向量。
没错。这是运算符重载板子。你也许会写出类似这样的代码：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20


template<typename T>
struct Vector {
    std::vector<T> data;

    // 构造函数，方便初始化
    Vector(size_t n = 0) : data(n) {}
    Vector(std::initializer_list<T> l) : data(l) {}

    T operator[](size_t i) const { return data[i]; }
    T &amp;operator[](size_t i) { return data[i]; }
    size_t size() const { return data.size(); }

    Vector operator+(const Vector &amp;rhs) const {
        Vector res(size()); // 初始化大小
        for (size_t i = 0; i < size(); ++i) {
            res[i] = data[i] + rhs[i];
        }
        return res; // 依赖 NRVO
    }
};


题外话：
注意加法中的 const& 参数类型。它是为了方便接受临时 Vector 对象（右值）：普通左值引用会 CE。"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/the-dark-side-of-the-force/><link crossorigin=anonymous href=/assets/css/stylesheet.b915ce98f9f65cca5e346b24fc336009b3608a3eeb24ce4b0e53c4500eba9374.css integrity="sha256-uRXOmPn2XMpeNGsk/DNgCbNgij7rJM5LDlPEUA66k3Q=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/the-dark-side-of-the-force/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/the-dark-side-of-the-force/"><meta property="og:site_name" content="正确即是废话，废话亦是正确"><meta property="og:title" content="May the force be with you"><meta property="og:description" content="假设你刚刚看过这篇文章：浅谈valarray。
现在我们需要模仿 valarray 写一个科学计算库。其中，我们需要支持形如 a + b 的写法，a 和 b 是两个向量，这个表达式的值是两个向量的和，即逐元素相加得到的新向量。
没错。这是运算符重载板子。你也许会写出类似这样的代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template<typename T> struct Vector { std::vector<T> data; // 构造函数，方便初始化 Vector(size_t n = 0) : data(n) {} Vector(std::initializer_list<T> l) : data(l) {} T operator[](size_t i) const { return data[i]; } T &amp;operator[](size_t i) { return data[i]; } size_t size() const { return data.size(); } Vector operator+(const Vector &amp;rhs) const { Vector res(size()); // 初始化大小 for (size_t i = 0; i < size(); ++i) { res[i] = data[i] + rhs[i]; } return res; // 依赖 NRVO } }; 题外话：
注意加法中的 const& 参数类型。它是为了方便接受临时 Vector 对象（右值）：普通左值引用会 CE。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-27T14:25:42+08:00"><meta property="article:modified_time" content="2025-12-27T14:25:42+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="May the force be with you"><meta name=twitter:description content="假设你刚刚看过这篇文章：浅谈valarray。
现在我们需要模仿 valarray 写一个科学计算库。其中，我们需要支持形如 a + b 的写法，a 和 b 是两个向量，这个表达式的值是两个向量的和，即逐元素相加得到的新向量。
没错。这是运算符重载板子。你也许会写出类似这样的代码：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20


template<typename T>
struct Vector {
    std::vector<T> data;

    // 构造函数，方便初始化
    Vector(size_t n = 0) : data(n) {}
    Vector(std::initializer_list<T> l) : data(l) {}

    T operator[](size_t i) const { return data[i]; }
    T &amp;operator[](size_t i) { return data[i]; }
    size_t size() const { return data.size(); }

    Vector operator+(const Vector &amp;rhs) const {
        Vector res(size()); // 初始化大小
        for (size_t i = 0; i < size(); ++i) {
            res[i] = data[i] + rhs[i];
        }
        return res; // 依赖 NRVO
    }
};


题外话：
注意加法中的 const& 参数类型。它是为了方便接受临时 Vector 对象（右值）：普通左值引用会 CE。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"May the force be with you","item":"https://litjohn.github.io/posts/the-dark-side-of-the-force/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"May the force be with you","name":"May the force be with you","description":"假设你刚刚看过这篇文章：浅谈valarray。\n现在我们需要模仿 valarray 写一个科学计算库。其中，我们需要支持形如 a + b 的写法，a 和 b 是两个向量，这个表达式的值是两个向量的和，即逐元素相加得到的新向量。\n没错。这是运算符重载板子。你也许会写出类似这样的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;typename T\u0026gt; struct Vector { std::vector\u0026lt;T\u0026gt; data; // 构造函数，方便初始化 Vector(size_t n = 0) : data(n) {} Vector(std::initializer_list\u0026lt;T\u0026gt; l) : data(l) {} T operator[](size_t i) const { return data[i]; } T \u0026amp;operator[](size_t i) { return data[i]; } size_t size() const { return data.size(); } Vector operator+(const Vector \u0026amp;rhs) const { Vector res(size()); // 初始化大小 for (size_t i = 0; i \u0026lt; size(); ++i) { res[i] = data[i] + rhs[i]; } return res; // 依赖 NRVO } }; 题外话：\n注意加法中的 const\u0026amp; 参数类型。它是为了方便接受临时 Vector 对象（右值）：普通左值引用会 CE。\n","keywords":[],"articleBody":"假设你刚刚看过这篇文章：浅谈valarray。\n现在我们需要模仿 valarray 写一个科学计算库。其中，我们需要支持形如 a + b 的写法，a 和 b 是两个向量，这个表达式的值是两个向量的和，即逐元素相加得到的新向量。\n没错。这是运算符重载板子。你也许会写出类似这样的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u003ctypename T\u003e struct Vector { std::vector\u003cT\u003e data; // 构造函数，方便初始化 Vector(size_t n = 0) : data(n) {} Vector(std::initializer_list\u003cT\u003e l) : data(l) {} T operator[](size_t i) const { return data[i]; } T \u0026operator[](size_t i) { return data[i]; } size_t size() const { return data.size(); } Vector operator+(const Vector \u0026rhs) const { Vector res(size()); // 初始化大小 for (size_t i = 0; i \u003c size(); ++i) { res[i] = data[i] + rhs[i]; } return res; // 依赖 NRVO } }; 题外话：\n注意加法中的 const\u0026 参数类型。它是为了方便接受临时 Vector 对象（右值）：普通左值引用会 CE。\n而在 C++ 规范中，const 左值引用（const T\u0026）是一个“万能引用”，它可以绑定到临时对象（右值）。\nC++ 标准规定：常量左值引用可以延长临时对象的生命周期，直到该引用本身被销毁。这使得 const T\u0026 成了 C++ 历史上最通用的参数传递方式：它既能接左值（变量），也能接右值（临时对象），且保证不会修改它。\n看上去非常正确。然而，这个写法在嵌套的表达式（比如 a+b+c 三个向量相加）时，会多次循环遍历数组，并且生成和废弃大量的向量对象（res 的分配，以及右值在表达式中当加法调用完毕生命周期就结束，从而被释放）。\n这是不好的。如果手写，我们只需要 res[i] = a[i] + b[i] + c[i]; 就行了，根本不需要这么多中间变量的分配，循环遍历和缓存未命中开销也会更小。\n但是手写看上去丑陋和费事的多。能不能使用一些手法，使得我们能够兼顾优雅和高性能呢？\n有的，兄弟！有的。\n表达式模板 前人想到了一个非常天才的主意：利用模板系统的元编程能力，将表达式信息编码在类型中，自动展开为高效的计算过程。\n这样说比较抽象。具体的，a+b 这个表达式不会被立即求值，而是会生成一棵 addexp 类型的表达式树。这个表达式树可以被随机访问，访问它的第 i 个位置时，编译器会自动从它的数据源计算出第 i 个位置的值。\n在上面的具体例子中，第 i 个位置的值就是 a[i]+b[i]。\n而这棵树可以赋值给普通的 Vector。赋值时，我们遍历 $i\\in [0, \\text{size})$，将目标 Vector 的第 $i$ 个位置赋值为表达式树的第 $i$ 个位置的值。\n这就是表达式模板技术。\n统一表示 在工程实现中，我们一般会实现一个基类 Exp，它有一个 operator[] 声明。而所有的表达式类，包括二元表达式以及 Vector 自己，都继承它，并实现 operator[] 作为随机访问的接口。\n这样做的优势是可扩展性强，表示统一简洁。\n奇异递归模板模式 你可能注意到了，这个思想其实要求我们实现多态。多态的一般写法是 virtual 声明虚函数，override 重写实现。然而，这里无法使用这种一般做法。\n因为虚函数需要查表和维护 RTTI（运行时类型信息），有内存和时间的双重开销。对于科学计算，这是不可容忍的。\n前人又有一种惊世骇俗的方法，专门用于实现零开销的静态多态。也就是“奇异递归模板模式”。\n看起来像是这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 template\u003ctypename T\u003e struct Exp { auto operator[](size_t i) const { return static_cast\u003cT\u003e(*this)[i]; } }; template\u003ctypename T\u003e struct Vector : public Exp\u003cVector\u003cT\u003e\u003e { std::vector\u003cT\u003e data; // 构造函数，方便初始化 Vector(size_t n = 0) : data(n) {} Vector(std::initializer_list\u003cT\u003e l) : data(l) {} T operator[](size_t i) const { return data[i]; } T \u0026operator[](size_t i) { return data[i]; } size_t size() const { return data.size(); } // 修正后的加法实现 Vector operator+(const Vector \u0026rhs) const { Vector res(size()); // 初始化大小 for (size_t i = 0; i \u003c size(); ++i) { res[i] = data[i] + rhs[i]; } return res; // 依赖 NRVO } }; 我想你应该能看懂。基类是一个模板类，子类则继承自基类，并将基类的模板参数填入自己。基类中的多态函数在被调用时，把基类强转为子类，并调用子类的实现。\n本来，从超类型到子类型的转换其实是不安全的（需要 dynamic_cast）。不过，这里我们可以确保强转的那个子类一定是数据的真实类型，不会出锅。\n某种意义上，其实是我们手动实现了一个 Union type，在模板参数中记录它的类型信息。\n原力闪电 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 template\u003ctypename T\u003e struct Exp { auto operator[](size_t i) const { return static_cast\u003cconst T \u0026\u003e(*this)[i]; } size_t size() const { return static_cast\u003cconst T \u0026\u003e(*this).size(); } }; template\u003ctypename L, typename R\u003e struct Add_exp : public Exp\u003cAdd_exp\u003cL, R\u003e\u003e { const L \u0026l; const R \u0026r; size_t size() const { return l.size(); } Add_exp(const L \u0026l, const R \u0026r) : l(l), r(r) {} auto operator[](size_t i) const { return l[i] + r[i]; } }; template\u003ctypename T\u003e struct Vector : public Exp\u003cVector\u003cT\u003e\u003e { std::vector\u003cT\u003e data; // 构造函数，方便初始化 Vector(size_t n = 0) : data(n) {} Vector(std::initializer_list\u003cT\u003e l) : data(l) {} T operator[](size_t i) const { return data[i]; } T \u0026operator[](size_t i) { return data[i]; } size_t size() const { return data.size(); } template\u003ctypename T2\u003e void operator=(const Exp\u003cT2\u003e \u0026rhs) { // clog \u003c\u003c rhs.size() \u003c\u003c \"\\n\"; data.resize(rhs.size()); // clog \u003c\u003c data.size() \u003c\u003c \"\\n\"; for (size_t i = 0; i \u003c size(); ++i) { data[i] = rhs[i]; } } }; template\u003ctypename L, typename R\u003e auto operator+(const Exp\u003cL\u003e \u0026l, const Exp\u003cR\u003e \u0026r) { return Add_exp\u003cL, R\u003e(static_cast\u003cconst L \u0026\u003e(l), static_cast\u003cconst R \u0026\u003e(r)); } 一个简陋的表达式模板。\n测试：\n1 2 3 4 5 6 7 8 int main() { Vector\u003cint\u003e res; res = (Vector{1, 2, 3} + Vector{4, 5, 6} + Vector{4, 2, 0}); for (int i = 0; i \u003c res.size(); ++i) { cout \u003c\u003c res[i] \u003c\u003c \" \"; } return 0; } 输出 9 9 9。\n代码看上去非常简单，实际上也非常简单。但是你在复现的时候就会发现其中隐藏了大量的 C++ 语法和语义细节。这些偶发复杂性极其烦人。\n建议自己复现一下。遇到疑难杂症可以询问 AI。\n可扩展性的演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 template\u003ctypename T\u003e struct Exp { auto operator[](size_t i) const { return static_cast\u003cconst T \u0026\u003e(*this)[i]; } size_t size() const { return static_cast\u003cconst T \u0026\u003e(*this).size(); } }; template\u003ctypename L, typename R, typename OP\u003e struct Bin_exp : public Exp\u003cBin_exp\u003cL, R, OP\u003e\u003e { const L \u0026l; const R \u0026r; OP op; size_t size() const { return l.size(); } Bin_exp(const L \u0026l, const R \u0026r) : l(l), r(r), op() {} auto operator[](size_t i) const { return op(l[i], r[i]); } }; struct Add { auto operator()(auto a, auto b) const { return a + b; } }; template\u003ctypename L, typename R\u003e using Add_exp = Bin_exp\u003cL, R, Add\u003e; template\u003ctypename T\u003e struct Vector : public Exp\u003cVector\u003cT\u003e\u003e { std::vector\u003cT\u003e data; // 构造函数，方便初始化 Vector(size_t n = 0) : data(n) {} Vector(std::initializer_list\u003cT\u003e l) : data(l) {} T operator[](size_t i) const { return data[i]; } T \u0026operator[](size_t i) { return data[i]; } size_t size() const { return data.size(); } template\u003ctypename T2\u003e void operator=(const Exp\u003cT2\u003e \u0026rhs) { // clog \u003c\u003c rhs.size() \u003c\u003c \"\\n\"; data.resize(rhs.size()); // clog \u003c\u003c data.size() \u003c\u003c \"\\n\"; for (size_t i = 0; i \u003c size(); ++i) { data[i] = rhs[i]; } } }; template\u003ctypename L, typename R\u003e auto operator+(const Exp\u003cL\u003e \u0026l, const Exp\u003cR\u003e \u0026r) { return Add_exp\u003cL, R\u003e(static_cast\u003cconst L \u0026\u003e(l), static_cast\u003cconst R \u0026\u003e(r)); } 注意到仿函数的使用。C++ 的函数式特性支持奇差无比，这种时候我竟然不能使用 lambda（或者考虑 std::function 包装一层，但是堆分配和类型擦除都有开销）。\n当然，想要用 lambda 也是可以的。可以考虑在构造函数中传入 lambda，或者使用更加高级的 TMP 黑魔法。\n然后你会惊讶地注意到，如果你写了\n1 2 3 4 5 6 7 8 9 int main() { Vector\u003cint\u003e res; auto tmp = (Vector{1, 2, 3} + Vector{4, 5, 6} + Vector{4, 2, 0}); res = tmp; for (int i = 0; i \u003c res.size(); ++i) { cout \u003c\u003c res[i] \u003c\u003c \" \"; } return 0; } 程序会爆掉，并（可能，实际上此时是未定义的）抛出 std::bad_alloc 异常。\n为什么？因为极其不幸的，tmp 的声明那一行结束之后，几个 Vector 临时对象的生命周期就结束了。于是 tmp 中存储的引用变成了悬垂引用。然后 res = tmp; 就寄了。\n另一个坑：如果你以后增加了一些不是逐元素进行的操作，比如类似 bitset 的右移，v = (v \u003c\u003c 1); 之类的写法可能就会出锅。\n因为它会展开为一个 v[i] = v[i - 1] 的循环。这样，就会让原始数据被覆盖掉（类似于 01 背包的转移），于是得到错误的结果。\n这些都需要大量复杂的手法来解决（比如你可以试着使用 SFINAE 等手法对于左值和右值进行逻辑分派，分别存储原值和常量引用）。所以我暂时按下。\nThese are your father’s parens… elegant weapons, belong to a more civilized era 考虑这段 racket 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #lang racket (define-syntax get-pos (lambda (stx) (syntax-case stx () [(_ (op a b) i) #'(op (get-pos a i) (get-pos b i))] [(_ a i) #'(vector-ref a i)]))) (define-syntax get-len (lambda (stx) (syntax-case stx () [(_ (op a b)) #'(get-len a)] [(_ a) #'(vector-length a)]))) (define-syntax vec-binexp (lambda (stx) (syntax-case stx () [(_ (op a b)) #'(for/vector ([i (in-range (get-len a))]) (get-pos (op a b) i))] [(_ a i) #'a]))) (define a #(1 2 3)) (define b #(4 5 6)) (displayln (vec-binexp (* (+ #(3 4 5) #(2 1 0)) (+ a b)))) 事实上，它做到了与上面的 C++ 黑魔法同样的事。\n当然，racket 有一些弱点。\n比如，如果你想要加入向量数乘，你就会惊讶地发现你不得不使用一个 if 做向量和数值的类型分派。racket 的宏难以利用类型信息，甚至在 typed/racket 中也一样：typed/racket 的实现是类型擦除的，它在普通 racket 上用宏构建了一层类型推导、检查与优化器。但真正运行时，typed/racket 已经被展开为了普通的 racket 代码。而宏展开阶段时 typed/racket 的类型推导和检查机制还没有开始介入，自己写的宏也就无法利用类型信息。\n怎么办？一种方法是利用前人的工作，比如 #lang turnstile。它是专门为类型化语言构建的，甚至可以用来实现 haskell（比如著名的 haskett）。但是机制极端复杂，还有 Unicode 字符代码比较超标。\n简单的 hack 就是手写类型标注。比如说数值 x 写成 (Number x)。然后宏中进行特判，消除类型分派。本质上是自己维护了类型系统。\n说到这里，有没有大神愿意教我实现一个 typed/racket 并且让宏能够利用类型信息啊？求带飞 /bx\n","wordCount":"1167","inLanguage":"en","datePublished":"2025-12-27T14:25:42+08:00","dateModified":"2025-12-27T14:25:42+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/the-dark-side-of-the-force/"},"publisher":{"@type":"Organization","name":"正确即是废话，废话亦是正确","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="正确即是废话，废话亦是正确 (Alt + H)">正确即是废话，废话亦是正确</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://litjohn.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">May the force be with you</h1><div class=post-meta><span title='2025-12-27 14:25:42 +0800 +0800'>December 27, 2025</span></div></header><div class=post-content><p>假设你刚刚看过这篇文章：<a href=https://www.luogu.com.cn/article/i4twa64m>浅谈valarray</a>。</p><p>现在我们需要模仿 valarray 写一个科学计算库。其中，我们需要支持形如 <code>a + b</code> 的写法，<code>a</code> 和 <code>b</code> 是两个向量，这个表达式的值是两个向量的和，即逐元素相加得到的新向量。</p><p>没错。这是运算符重载板子。你也许会写出类似这样的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Vector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 构造函数，方便初始化
</span></span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=p>(</span><span class=n>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>:</span> <span class=n>data</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>l</span><span class=p>)</span> <span class=o>:</span> <span class=n>data</span><span class=p>(</span><span class=n>l</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>&amp;</span><span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Vector</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Vector</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector</span> <span class=nf>res</span><span class=p>(</span><span class=n>size</span><span class=p>());</span> <span class=c1>// 初始化大小
</span></span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>rhs</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>res</span><span class=p>;</span> <span class=c1>// 依赖 NRVO
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>题外话：<br>注意加法中的 const& 参数类型。它是为了方便接受临时 Vector 对象（右值）：普通左值引用会 CE。</p><p>而在 C++ 规范中，const 左值引用（const T&）是一个“万能引用”，它可以绑定到临时对象（右值）。</p><p>C++ 标准规定：常量左值引用可以延长临时对象的生命周期，直到该引用本身被销毁。这使得 const T& 成了 C++ 历史上最通用的参数传递方式：它既能接左值（变量），也能接右值（临时对象），且保证不会修改它。</p><hr><p>看上去非常正确。然而，这个写法在嵌套的表达式（比如 <code>a+b+c</code> 三个向量相加）时，会多次循环遍历数组，并且生成和废弃大量的向量对象（<code>res</code> 的分配，以及右值在表达式中当加法调用完毕生命周期就结束，从而被释放）。</p><p>这是不好的。如果手写，我们只需要 <code>res[i] = a[i] + b[i] + c[i];</code> 就行了，根本不需要这么多中间变量的分配，循环遍历和缓存未命中开销也会更小。</p><p>但是手写看上去丑陋和费事的多。能不能使用一些手法，使得我们能够兼顾优雅和高性能呢？</p><p>有的，兄弟！有的。</p><h2 id=表达式模板>表达式模板<a hidden class=anchor aria-hidden=true href=#表达式模板>#</a></h2><p>前人想到了一个非常天才的主意：利用模板系统的元编程能力，将表达式信息编码在类型中，自动展开为高效的计算过程。</p><p>这样说比较抽象。具体的，<code>a+b</code> 这个表达式不会被立即求值，而是会生成一棵 <code>addexp&lt;Vector, Vector></code> 类型的表达式树。这个表达式树可以被随机访问，访问它的第 <code>i</code> 个位置时，编译器会自动从它的数据源计算出第 <code>i</code> 个位置的值。</p><p>在上面的具体例子中，第 <code>i</code> 个位置的值就是 <code>a[i]+b[i]</code>。</p><p>而这棵树可以赋值给普通的 Vector。赋值时，我们遍历 $i\in [0, \text{size})$，将目标 Vector 的第 $i$ 个位置赋值为表达式树的第 $i$ 个位置的值。</p><p>这就是表达式模板技术。</p><h3 id=统一表示>统一表示<a hidden class=anchor aria-hidden=true href=#统一表示>#</a></h3><p>在工程实现中，我们一般会实现一个基类 Exp，它有一个 operator[] 声明。而所有的表达式类，包括二元表达式以及 Vector 自己，都继承它，并实现 operator[] 作为随机访问的接口。</p><p>这样做的优势是可扩展性强，表示统一简洁。</p><h3 id=奇异递归模板模式>奇异递归模板模式<a hidden class=anchor aria-hidden=true href=#奇异递归模板模式>#</a></h3><p>你可能注意到了，这个思想其实要求我们实现多态。多态的一般写法是 <code>virtual</code> 声明虚函数，<code>override</code> 重写实现。然而，这里无法使用这种一般做法。</p><p>因为虚函数需要查表和维护 RTTI（运行时类型信息），有内存和时间的双重开销。对于科学计算，这是不可容忍的。</p><p>前人又有一种惊世骇俗的方法，专门用于实现零开销的静态多态。也就是“奇异递归模板模式”。</p><p>看起来像是这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Exp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>)[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Vector</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>Vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 构造函数，方便初始化
</span></span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=p>(</span><span class=n>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>:</span> <span class=n>data</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>l</span><span class=p>)</span> <span class=o>:</span> <span class=n>data</span><span class=p>(</span><span class=n>l</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>&amp;</span><span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 修正后的加法实现
</span></span></span><span class=line><span class=cl>    <span class=n>Vector</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Vector</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector</span> <span class=nf>res</span><span class=p>(</span><span class=n>size</span><span class=p>());</span> <span class=c1>// 初始化大小
</span></span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>rhs</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>res</span><span class=p>;</span> <span class=c1>// 依赖 NRVO
</span></span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>我想你应该能看懂。基类是一个模板类，子类则继承自基类，并将基类的模板参数填入自己。基类中的多态函数在被调用时，把基类强转为子类，并调用子类的实现。</p><p>本来，从超类型到子类型的转换其实是不安全的（需要 dynamic_cast）。不过，这里我们可以确保强转的那个子类一定是数据的真实类型，不会出锅。</p><p>某种意义上，其实是我们手动实现了一个 Union type，在模板参数中记录它的类型信息。</p><h3 id=原力闪电>原力闪电<a hidden class=anchor aria-hidden=true href=#原力闪电>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Exp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>)[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>).</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>L</span><span class=p>,</span> <span class=k>typename</span> <span class=n>R</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Add_exp</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>Add_exp</span><span class=o>&lt;</span><span class=n>L</span><span class=p>,</span> <span class=n>R</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>L</span> <span class=o>&amp;</span><span class=n>l</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>R</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>l</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Add_exp</span><span class=p>(</span><span class=k>const</span> <span class=n>L</span> <span class=o>&amp;</span><span class=n>l</span><span class=p>,</span> <span class=k>const</span> <span class=n>R</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>)</span> <span class=o>:</span> <span class=n>l</span><span class=p>(</span><span class=n>l</span><span class=p>),</span> <span class=n>r</span><span class=p>(</span><span class=n>r</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>l</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Vector</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>Vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 构造函数，方便初始化
</span></span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=p>(</span><span class=n>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>:</span> <span class=n>data</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>l</span><span class=p>)</span> <span class=o>:</span> <span class=n>data</span><span class=p>(</span><span class=n>l</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>&amp;</span><span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>T2</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// clog &lt;&lt; rhs.size() &lt;&lt; &#34;\n&#34;;
</span></span></span><span class=line><span class=cl>        <span class=n>data</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=c1>// clog &lt;&lt; data.size() &lt;&lt; &#34;\n&#34;;
</span></span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>L</span><span class=p>,</span> <span class=k>typename</span> <span class=n>R</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>L</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>l</span><span class=p>,</span> <span class=k>const</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Add_exp</span><span class=o>&lt;</span><span class=n>L</span><span class=p>,</span> <span class=n>R</span><span class=o>&gt;</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>L</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>l</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>R</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>r</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>一个简陋的表达式模板。</p><p>测试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span> <span class=o>=</span> <span class=p>(</span><span class=n>Vector</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span> <span class=o>+</span> <span class=n>Vector</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>}</span> <span class=o>+</span> <span class=n>Vector</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>res</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出 <code>9 9 9</code>。</p><p>代码看上去非常简单，实际上也非常简单。但是你在复现的时候就会发现其中隐藏了大量的 C++ 语法和语义细节。这些偶发复杂性极其烦人。</p><p>建议自己复现一下。遇到疑难杂症可以询问 AI。</p><h3 id=可扩展性的演示>可扩展性的演示<a hidden class=anchor aria-hidden=true href=#可扩展性的演示>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Exp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>)[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>).</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>L</span><span class=p>,</span> <span class=k>typename</span> <span class=n>R</span><span class=p>,</span> <span class=k>typename</span> <span class=n>OP</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Bin_exp</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>Bin_exp</span><span class=o>&lt;</span><span class=n>L</span><span class=p>,</span> <span class=n>R</span><span class=p>,</span> <span class=n>OP</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>L</span> <span class=o>&amp;</span><span class=n>l</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>R</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>OP</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>l</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Bin_exp</span><span class=p>(</span><span class=k>const</span> <span class=n>L</span> <span class=o>&amp;</span><span class=n>l</span><span class=p>,</span> <span class=k>const</span> <span class=n>R</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>)</span> <span class=o>:</span> <span class=n>l</span><span class=p>(</span><span class=n>l</span><span class=p>),</span> <span class=n>r</span><span class=p>(</span><span class=n>r</span><span class=p>),</span> <span class=n>op</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>op</span><span class=p>(</span><span class=n>l</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Add</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>auto</span> <span class=n>a</span><span class=p>,</span> <span class=k>auto</span> <span class=n>b</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>L</span><span class=p>,</span> <span class=k>typename</span> <span class=n>R</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>Add_exp</span> <span class=o>=</span> <span class=n>Bin_exp</span><span class=o>&lt;</span><span class=n>L</span><span class=p>,</span> <span class=n>R</span><span class=p>,</span> <span class=n>Add</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Vector</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>Vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 构造函数，方便初始化
</span></span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=p>(</span><span class=n>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>:</span> <span class=n>data</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>l</span><span class=p>)</span> <span class=o>:</span> <span class=n>data</span><span class=p>(</span><span class=n>l</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>&amp;</span><span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>T2</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// clog &lt;&lt; rhs.size() &lt;&lt; &#34;\n&#34;;
</span></span></span><span class=line><span class=cl>        <span class=n>data</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=c1>// clog &lt;&lt; data.size() &lt;&lt; &#34;\n&#34;;
</span></span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>L</span><span class=p>,</span> <span class=k>typename</span> <span class=n>R</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>L</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>l</span><span class=p>,</span> <span class=k>const</span> <span class=n>Exp</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Add_exp</span><span class=o>&lt;</span><span class=n>L</span><span class=p>,</span> <span class=n>R</span><span class=o>&gt;</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>L</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>l</span><span class=p>),</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>R</span> <span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>r</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>注意到仿函数的使用。C++ 的函数式特性支持奇差无比，这种时候我竟然不能使用 lambda（或者考虑 <code>std::function</code> 包装一层，但是堆分配和类型擦除都有开销）。</p><blockquote><p>当然，想要用 lambda 也是可以的。可以考虑在构造函数中传入 lambda，或者使用更加高级的 TMP 黑魔法。</p></blockquote><p>然后你会惊讶地注意到，如果你写了</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>tmp</span> <span class=o>=</span> <span class=p>(</span><span class=n>Vector</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span> <span class=o>+</span> <span class=n>Vector</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>}</span> <span class=o>+</span> <span class=n>Vector</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>res</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>程序会爆掉，并（可能，实际上此时是未定义的）抛出 <code>std::bad_alloc</code> 异常。</p><p>为什么？因为极其不幸的，<code>tmp</code> 的声明那一行结束之后，几个 Vector 临时对象的生命周期就结束了。于是 <code>tmp</code> 中存储的引用变成了悬垂引用。然后 <code>res = tmp;</code> 就寄了。</p><hr><p>另一个坑：如果你以后增加了一些不是逐元素进行的操作，比如类似 bitset 的右移，<code>v = (v &lt;&lt; 1);</code> 之类的写法可能就会出锅。</p><p>因为它会展开为一个 <code>v[i] = v[i - 1]</code> 的循环。这样，就会让原始数据被覆盖掉（类似于 01 背包的转移），于是得到错误的结果。</p><hr><p>这些都需要大量复杂的手法来解决（比如你可以试着使用 SFINAE 等手法对于左值和右值进行逻辑分派，分别存储原值和常量引用）。所以我暂时按下。</p><h2 id=these-are-your-fathers-parens-elegant-weapons-belong-to-a-more-civilized-era>These are your father&rsquo;s parens&mldr; elegant weapons, belong to a more civilized era<a hidden class=anchor aria-hidden=true href=#these-are-your-fathers-parens-elegant-weapons-belong-to-a-more-civilized-era>#</a></h2><p>考虑这段 racket 代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax</span> <span class=n>get-pos</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=n>stx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>syntax-case</span> <span class=n>stx</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=k>_</span> <span class=p>(</span><span class=n>op</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=o>#&#39;</span><span class=p>(</span><span class=n>op</span> <span class=p>(</span><span class=n>get-pos</span> <span class=n>a</span> <span class=n>i</span><span class=p>)</span> <span class=p>(</span><span class=n>get-pos</span> <span class=n>b</span> <span class=n>i</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=k>_</span> <span class=n>a</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=o>#&#39;</span><span class=p>(</span><span class=nb>vector-ref</span> <span class=n>a</span> <span class=n>i</span><span class=p>)])))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax</span> <span class=n>get-len</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=n>stx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>syntax-case</span> <span class=n>stx</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=k>_</span> <span class=p>(</span><span class=n>op</span> <span class=n>a</span> <span class=n>b</span><span class=p>))</span> <span class=o>#&#39;</span><span class=p>(</span><span class=n>get-len</span> <span class=n>a</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=k>_</span> <span class=n>a</span><span class=p>)</span> <span class=o>#&#39;</span><span class=p>(</span><span class=nb>vector-length</span> <span class=n>a</span><span class=p>)])))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax</span> <span class=n>vec-binexp</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda</span> <span class=p>(</span><span class=n>stx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>syntax-case</span> <span class=n>stx</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=k>_</span> <span class=p>(</span><span class=n>op</span> <span class=n>a</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>       <span class=o>#&#39;</span><span class=p>(</span><span class=k>for/vector</span> <span class=p>([</span><span class=n>i</span> <span class=p>(</span><span class=nb>in-range</span> <span class=p>(</span><span class=n>get-len</span> <span class=n>a</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=n>get-pos</span> <span class=p>(</span><span class=n>op</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=n>i</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>[(</span><span class=k>_</span> <span class=n>a</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=o>#&#39;</span><span class=n>a</span><span class=p>])))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>a</span> <span class=o>#</span><span class=p>(</span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>b</span> <span class=o>#</span><span class=p>(</span><span class=mi>4</span> <span class=mi>5</span> <span class=mi>6</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>vec-binexp</span> <span class=p>(</span><span class=nb>*</span> <span class=p>(</span><span class=nb>+</span> <span class=o>#</span><span class=p>(</span><span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span><span class=p>)</span> <span class=o>#</span><span class=p>(</span><span class=mi>2</span> <span class=mi>1</span> <span class=mi>0</span><span class=p>))</span> <span class=p>(</span><span class=nb>+</span> <span class=n>a</span> <span class=n>b</span><span class=p>))))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>事实上，它做到了与上面的 C++ 黑魔法同样的事。</p><p>当然，racket 有一些弱点。</p><p>比如，如果你想要加入向量数乘，你就会惊讶地发现你不得不使用一个 if 做向量和数值的类型分派。racket 的宏难以利用类型信息，甚至在 typed/racket 中也一样：typed/racket 的实现是类型擦除的，它在普通 racket 上用宏构建了一层类型推导、检查与优化器。但真正运行时，typed/racket 已经被展开为了普通的 racket 代码。而宏展开阶段时 typed/racket 的类型推导和检查机制还没有开始介入，自己写的宏也就无法利用类型信息。</p><p>怎么办？一种方法是利用前人的工作，比如 <a href=https://docs.racket-lang.org/turnstile/><code>#lang turnstile</code></a>。它是专门为类型化语言构建的，甚至可以用来实现 haskell（比如著名的 haskett）。但是机制极端复杂，还有 Unicode 字符代码比较超标。</p><p>简单的 hack 就是手写类型标注。比如说数值 <code>x</code> 写成 <code>(Number x)</code>。然后宏中进行特判，消除类型分派。本质上是自己维护了类型系统。</p><p>说到这里，有没有大神愿意教我实现一个 typed/racket 并且让宏能够利用类型信息啊？求带飞 /bx</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://litjohn.github.io/>正确即是废话，废话亦是正确</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>