<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>惰性求值、无穷流与发生的魔法 | litjohn's blog</title><meta name=keywords content="PLT,lisp/scheme/racket"><meta name=description content="光剑第二作！
前言：什么是魔法？
（注：这个前言可以跳过。它是最终成果展示。感到迷惑很正常，请先阅读正文。）
什么是魔法？


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39


(define-syntax delay
  (syntax-rules ()
    ((delay x) (lambda () x))))

(define (lazy-variable thunk)
  (cons #f thunk))

(define (is-calculated? variable)
  (car variable))

(define (force variable)
  (if (is-calculated? variable)
    (cdr variable)
    (begin
      (set-car! variable #t)
      (set-cdr! variable ((cdr variable)))
      (cdr variable))))

(define-syntax stream-cons
  (syntax-rules ()
    ((stream-cons a b)
     (cons
       a
       (lazy-variable
         (delay b))))))

(define (stream-car x)
  (car x))

(define (stream-cdr x)
  (force (cdr x)))

(define (int-from n)
  (stream-cons
    n
    (int-from
      (+ n 1))))

(define nature-numbers (int-from 1))


真成四十行代码了。感兴趣的读者可以数一数，刚好 39 行。"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/"><meta property="og:site_name" content="litjohn's blog"><meta property="og:title" content="惰性求值、无穷流与发生的魔法"><meta property="og:description" content="光剑第二作！
前言：什么是魔法？ （注：这个前言可以跳过。它是最终成果展示。感到迷惑很正常，请先阅读正文。）
什么是魔法？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 (define-syntax delay (syntax-rules () ((delay x) (lambda () x)))) (define (lazy-variable thunk) (cons #f thunk)) (define (is-calculated? variable) (car variable)) (define (force variable) (if (is-calculated? variable) (cdr variable) (begin (set-car! variable #t) (set-cdr! variable ((cdr variable))) (cdr variable)))) (define-syntax stream-cons (syntax-rules () ((stream-cons a b) (cons a (lazy-variable (delay b)))))) (define (stream-car x) (car x)) (define (stream-cdr x) (force (cdr x))) (define (int-from n) (stream-cons n (int-from (+ n 1)))) (define nature-numbers (int-from 1)) 真成四十行代码了。感兴趣的读者可以数一数，刚好 39 行。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-13T15:15:17+08:00"><meta property="article:modified_time" content="2025-10-13T15:15:17+08:00"><meta property="article:tag" content="PLT"><meta property="article:tag" content="Lisp/Scheme/Racket"><meta property="og:see_also" content="https://litjohn.github.io/posts/start-to-build-a-compiler/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call-cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"><meta property="og:see_also" content="https://litjohn.github.io/posts/lets-build-our-mathematics-by-using-lambda-calculus--church-encoding/"><meta name=twitter:card content="summary"><meta name=twitter:title content="惰性求值、无穷流与发生的魔法"><meta name=twitter:description content="光剑第二作！
前言：什么是魔法？
（注：这个前言可以跳过。它是最终成果展示。感到迷惑很正常，请先阅读正文。）
什么是魔法？


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39


(define-syntax delay
  (syntax-rules ()
    ((delay x) (lambda () x))))

(define (lazy-variable thunk)
  (cons #f thunk))

(define (is-calculated? variable)
  (car variable))

(define (force variable)
  (if (is-calculated? variable)
    (cdr variable)
    (begin
      (set-car! variable #t)
      (set-cdr! variable ((cdr variable)))
      (cdr variable))))

(define-syntax stream-cons
  (syntax-rules ()
    ((stream-cons a b)
     (cons
       a
       (lazy-variable
         (delay b))))))

(define (stream-car x)
  (car x))

(define (stream-cdr x)
  (force (cdr x)))

(define (int-from n)
  (stream-cons
    n
    (int-from
      (+ n 1))))

(define nature-numbers (int-from 1))


真成四十行代码了。感兴趣的读者可以数一数，刚好 39 行。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"惰性求值、无穷流与发生的魔法","item":"https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"惰性求值、无穷流与发生的魔法","name":"惰性求值、无穷流与发生的魔法","description":"光剑第二作！\n前言：什么是魔法？ （注：这个前言可以跳过。它是最终成果展示。感到迷惑很正常，请先阅读正文。）\n什么是魔法？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 (define-syntax delay (syntax-rules () ((delay x) (lambda () x)))) (define (lazy-variable thunk) (cons #f thunk)) (define (is-calculated? variable) (car variable)) (define (force variable) (if (is-calculated? variable) (cdr variable) (begin (set-car! variable #t) (set-cdr! variable ((cdr variable))) (cdr variable)))) (define-syntax stream-cons (syntax-rules () ((stream-cons a b) (cons a (lazy-variable (delay b)))))) (define (stream-car x) (car x)) (define (stream-cdr x) (force (cdr x))) (define (int-from n) (stream-cons n (int-from (+ n 1)))) (define nature-numbers (int-from 1)) 真成四十行代码了。感兴趣的读者可以数一数，刚好 39 行。\n","keywords":["PLT","lisp/scheme/racket"],"articleBody":"光剑第二作！\n前言：什么是魔法？ （注：这个前言可以跳过。它是最终成果展示。感到迷惑很正常，请先阅读正文。）\n什么是魔法？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 (define-syntax delay (syntax-rules () ((delay x) (lambda () x)))) (define (lazy-variable thunk) (cons #f thunk)) (define (is-calculated? variable) (car variable)) (define (force variable) (if (is-calculated? variable) (cdr variable) (begin (set-car! variable #t) (set-cdr! variable ((cdr variable))) (cdr variable)))) (define-syntax stream-cons (syntax-rules () ((stream-cons a b) (cons a (lazy-variable (delay b)))))) (define (stream-car x) (car x)) (define (stream-cdr x) (force (cdr x))) (define (int-from n) (stream-cons n (int-from (+ n 1)))) (define nature-numbers (int-from 1)) 真成四十行代码了。感兴趣的读者可以数一数，刚好 39 行。\n然后下面还有一些有趣的小工具：\n1 2 3 4 5 6 7 8 9 10 11 (define (get a pos) (if (= pos 0) (stream-car a) (get (stream-cdr a) (- pos 1)))) (define (take a len) (if (= len 0) '() (cons (stream-car a) (take (stream-cdr a) (- len 1))))) 这些有什么用呢？请见下文。\n1 2 3 4 5 6 7 8 9 10 (define org '(1 2 3 4 5)) (define (twice a) (if (null? a) '() (stream-cons (* 2 (car a)) (twice (cdr a))))) (define new (twice org)) 这里实现了类似于 C++ 20 std::views 库中的视窗的东西。具备类似的惰性求值特性。\n更加抽象的范式。我们发现上面的具体的“将一个元素变成它的二倍”的操作其实是和整体框架的“构建一个流，每个元素是原始列表/流中对应元素经过一个变换后得到的”的语义无关的。\n于是把框架提取出来，变成类似于列表的 map 的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 (define (transfer-to-stream operator a) (if (null? a) '() (stream-cons (operator (car a)) (transfer-to-stream operator (cdr a))))) (define (stream-map operator a) (if (null? a) '() (stream-cons (operator (stream-car a)) (stream-map operator (stream-cdr a))))) 正文 好了好了炫技到此结束。如果看到这里你都能看懂的话就可以离开了，这篇文章大概不会对您这样的大佬产生什么帮助。\n而如果你一头雾水也完全不要紧。正文从这里才刚刚开始。\n目标 · 魔法 “一个存储着所有自然数的、无穷大的列表”。\n在有着有限内存的计算机中，这是不可能达成的任务。然而，今天我们将亲手实现它。用非常少的代码。\n惰性求值 · 魔法的机理 各位听说过“惰性求值”（lazy-evaluation）吗？大概的思想就是，一个变量我们不立刻算出它的值，而是把它背后的“计算”保存起来，直到要用的时候才算出它的值。以此避免不必要的计算。\n举个例子：\n1 2 3 4 5 6 7 myClass foo() { myClass res(); // lots of work return res; } auto x = foo(); 假设 C++ 是惰性求值的，这里程序就不会在 x 定义时立刻执行 foo() 并计算返回值。而是会到你真正使用 x 的值的时候再执行 foo() 并计算出 x 的真实值。\n不过，我们熟悉的 C++ 和大多数主流语言都是严格求值/应用序求值的。并不（默认）支持这种特性。一个表达式被绑定到变量上，它立刻就被求值。函数调用时，也先对函数本身以及各个参数进行求值。比如这个函数：\n1 2 3 int foo(int x) { return x * 2; } 调用 foo(3 + 3) 时就会先求值 foo 发现它是一个函数。然后求值参数 x，发现它是 3 + 3，等于 6.函数体里面 x 的值直接就是 6.\n但是某些语言是默认惰性求值的。一个著名的例子是 haskell。它们在这种地方会让 x 变成一个未完成的计算 3 + 3，直到使用了 x * 2 时才求出 x 的值是 6，并返回 6 * 2 = 12.\n这是第一项前置知识。它是整个魔法的基础，我们能够创造出无穷大的列表，正是因为我们并没有创造出它！\n我们只需要创造出那些我们需要使用的部分就可以了。比如说，如果我们的程序只访问了自然数列表的前十项，就只计算出这前十项。\n手动实现惰性求值 · 魔法的材料 在一门严格求值的语言中，我们也是可以通过一些手法实现惰性求值机制的。\n最经典的方法是利用 lambda。\n我们知道，一个函数的函数体只有在调用时才会被求值。这个特性是容易理解的：函数需要知道参数以及引用的自由变量的值才能确定函数体的值。你不可能在函数定义时就准确地知道每次调用它产生的副作用和返回值。\n这就产生了一个天然的惰性求值对象！我们可以用它来构建惰性求值系统。\n具体地。我们知道这样的东西：\n对于任意一个函数 $g$，定义 $$f:=\\lambda x.(g\\ x)$$ 则有 $f$ 和 $g$ 等价。\n从感性上，这是显然的。对于任意输入，$f$ 和 $g$ 的输出都一模一样。$f$ 干的唯一一件事就是把输入扔给了 $g$ 处理。它自己什么都没干。\n在 lambda 演算的体系中，这是三条计算法则之一 η 变换。\n那么，我们就可以用一层 lambda（lambda 本质上是匿名函数/函数字面量）来包裹住表达式！\n这样，表达式就不会立即被求值了。而如果我们要获取表达式的值，只需要应用那个 lambda，就能得到表达式的求值结果。\nlambda 的参数具体是什么不重要，因为我们只是想要创建一个延迟求值的计算或者得到被延迟的计算的值。所以，干脆就不要参数了！一个无参数的 lambda 能够最简洁清晰地达成我们的目的。\n有一个术语用来描述这些：thunk。它指的是被延迟求值的计算。\n下面不得不涉及到一些细节。用 C++ 来写本文的代码会非常痛苦，需要和类型系统搏斗，给代码加上大量的模板技巧……那会完全掩盖思想的优雅本质。所以本文的代码不采用 C++。\n相反地，我们采用 scheme。scheme 是一门 lisp 方言，具有动态类型和函数式特性。也是一门严格求值的语言。\nscheme 的代码是以“S 表达式”（符号表达式）的形式组织的。\n快速了解一下 S-表达式：\n核心是列表 (List)： S-表达式的基本形式是由圆括号 () 包围起来的列表。 结构：(操作符 参数1 参数2 ...)： 列表中的第一个元素通常是操作符（即要应用的函数），其余元素则是传递给该操作符的参数。 原子 (Atom) 与嵌套： 列表中的元素可以是原子（如数字 123、符号 x、+），也可以是另一个 S-表达式。这种嵌套能力使得 S-表达式可以表示复杂的树状结构。 例如，表达式 (+ 1 (* 2 3)) 在 Scheme 中表示数学上的 1 + (2 * 3)。 这里：\n最外层的 (+ 1 (* 2 3)) 是一个 S-表达式。+ 是操作符，1 和 (* 2 3) 是它的参数。 (* 2 3) 本身也是一个 S-表达式。* 是操作符，2 和 3 是它的参数。执行它会得到 6。 所以整个表达式 (+ 1 6) 最终会计算得到 7。 你可以通过搜索、查阅文档或者询问 AI 得到 scheme 的更多信息。本文不过多赘述。\n于是我们就可以理解前言的第一段，delay、force 以及 lazy-variable 是在干什么了。delay 接受一个表达式，把它用 lambda 包装起来变成一个 thunk。force 对一个惰性求值的变量求取值，得到它的真实值。\nlazy-variable 是在干什么？它对 delay 给出的 thunk 进行了进一步的封装，加上了一个标志说明它是否已被求值。因为如果每次 force 取值都重新调用一遍 thunk，我们会不停地重复计算一模一样的东西，时间复杂度就寄了。\n所以，我们需要记忆化。第一次对于一个惰性变量的取值会求值 thunk，之后它的值就被存储在一个普通变量里了，不需要重复计算。\nforce 如何区分一个惰性变量是否被求值过了？就是靠 lazy-variable 引入的那个标志位。\n注意到 delay 是一个宏。因为 scheme 是应用序求值的。如果用一般的函数，参数会被先求值，就无法实现惰性求值了。\n到这里，我们就在 scheme 这门严格求值的语言中手动实现了惰性求值系统。\n流 · 魔法现身！ 有了惰性的变量，我们自然可以定义惰性求值的数据结构！\n“流”就是一个这样的惰性数据结构。具体的，它是一个列表。不过，它并不从一开始就存储着所有的数据，而是在访问时才生成真实的元素。（惰性求值特性）\n流可以是无穷大的，因为它只有被访问的项才会被生成。这就是我们最开始提出的魔法。\n我们如何实现一个流呢？我们发现，一个流的被计算完成的 cons 单元，它的数据域（car）就是一个普通的值。而指针域指向的，“下一项”却有可能是依然没有被生成的 thunk。\n所以就有了前言中的这些：\n1 2 3 4 5 6 7 8 9 10 11 12 13 (define-syntax stream-cons (syntax-rules () ((stream-cons a b) (cons a (lazy-variable (delay b)))))) (define (stream-car x) (car x)) (define (stream-cdr x) (force (cdr x))) 有了这些，我们如何构造出一个具体的流呢？比如一个全部项都是 1 的无穷流？\n你可能会想，一个全部都是 1 的无穷流，和它自己前面加上一个 1 是完全等价的。于是你可能会写出：\n1 2 (define one (stream-cons 1 one)) 然而这是错的。你会惊讶地发现，把上面代码中的 stream-cons 换成 cons，也能运行并且生成一个循环列表。这是 scheme 的一个特性。\n所以，上面的代码并不是你想象中被延迟无穷递归的无穷流，而只是一个普通的循环列表，指针域被延迟求值了而已。\n真正的实现利用的是函数被延迟的无穷递归。\n1 2 3 4 (define (one) (stream-cons 1 (one))) (define stream-of-one (one)) 当你在这个流上遍历的时候，你会不断地触及到被延迟求值的 one 调用。而它返回 1 和另一个被延迟的 one 调用构成的 cons 单元，永无休止。这是一个无穷流。\n以及，我们可以完成那个魔法了！自然数流，启动！\n1 2 3 4 5 6 7 (define (int-from n) (stream-cons n (int-from (+ n 1)))) (define nature-numbers (int-from 1)) 魔法现身之后的应用 我们需要一些操纵流的方法。我们已经有了 stream-car 和 stream-cdr 来访问它。不过还不够。\n前言中的 take 和 get，一个用来取一个流的前若干项（项数不足就 RE），一个用来取一个流的第 i 项（0-base，流的第一项是第 0 项）\n这些都很简单。不过下面的才是真正的重量级，也是流的实际应用。\n1 2 3 4 5 6 (define (twice a) (if (null? a) '() (stream-cons (* 2 (car a)) (twice (cdr a))))) 从一个列表创建一个流，流的每一项是原始列表对应项的两倍。\n这里前言里面有介绍。\n然后是 transfer-to-stream 和 stream-map。都是类似于普通列表的 map 的操作（将每个元素做给定变换，然后用变换后的元素创建并返回新的列表）。不过一个是从列表 map 到流，一个是流 map 到流。\n操作的组合 · 管道 这里不得不提到另外一个概念：管道。\n管道是一种高阶函数。它描述的是这样的一种东西：数据进入第一个函数，流出来变成返回值，然后继续进入第二个函数……就像水流过管道，数据流过一系列处理它的函数。\n下面就是一个简单的管道实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (define combine (lambda (f g) (lambda x (g (apply f x))))) (define tunnel (lambda list-of-params (let ((x (car list-of-params)) (tmp (cdr list-of-params))) (if (null? tmp) x (let ((y (car tmp)) (rest (cdr tmp))) (apply tunnel (cons (combine x y) rest))))))) 管道使得我们可以组合对一个流的不同操作，制造“数据的流水线”。\n1 2 3 4 5 6 7 (define example (stream-map (tunnel (lambda (x) (* x x)) (lambda (x) (+ x 3)) (lambda (x) (log x 2))) nature-numbers)) 魔法的代价：惰性与可变状态的冲突 scheme 中函数的闭包对作用域是默认按引用捕获的。也就是说，如果我包装的 thunk 在被计算之前，内部引用的自由变量被修改了或者生命周期结束，惰性求值的结果就会和严格求值不同。\n一个问题发生的示例：\n1 2 3 4 5 \u003e (define x 10) \u003e (define my-lazy-value (lazy-variable (delay (* x 2)))) ; 值是 2x = 20 \u003e (set! x 100) \u003e (force my-lazy-value) 200 ; something strange happened! haskell 就没有这种问题。因为它是“纯”的，状态不会被莫名其妙地改掉。而我们上面的构建流的代码也是纯的，所以它们是安全的。\n想要在可变状态中避免这种惨案的发生，我们需要一个“按值捕获”。\n1 2 3 4 5 6 7 8 9 10 11 12 (define x 10) ; 使用 let 来“冻结”x 当前的值 (define my-safe-lazy-value (let ((frozen-x x)) ; frozen-x 是一个全新的绑定，其值为 10 (lazy-variable (delay (* frozen-x 2))))) (set! x 100) (force my-safe-lazy-value) ; ==\u003e 20 不过，需要注意的是，仅仅修改 delay 很难做到按值捕获。因为你无法预料哪些变量是自由的。或者你不可能先求值表达式再存储，那样惰性求值就不存在了。\n我们只能手动按值捕获。\n我们实现的 delay 机制，其默认行为是捕获变量的“绑定”而非“值”。这在处理可变状态时会带来非预期的结果。这并非 delay 实现的缺陷，而是 Scheme 语言设计哲学的一种体现。它要求我们，作为魔法的施法者，必须清楚地知道自己法术的边界。当需要“固化”状态时，我们必须亲手使用 let 咒语来创建一个不可变的副本，从而保证魔法效果的确定性。这种对控制权的明确要求，正是这门语言强大而迷人的一部分。\n后记 到此，本文就结束了。我们成功使用惰性求值将“创建一个无穷大的列表”这样不可能的魔法化作了现实。\n我们亲手实现了一种声明式的方法。流可以让我们声明并组合对于列表的种种操作，而无需手动管理中间临时列表。\n代码即思想，我们描述的是“是什么”，而不是“怎么算”，将逻辑与控制分离。\n（BTW，也许你会好奇用 C++ 如何作到这些。那么你可以看看这个：https://www.luogu.com.cn/article/jomps7w6，AI生成的代码，能够过编和运行，并且实现了和本文一样的 功能。）\n","wordCount":"869","inLanguage":"en","datePublished":"2025-10-13T15:15:17+08:00","dateModified":"2025-10-13T15:15:17+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/"},"publisher":{"@type":"Organization","name":"litjohn's blog","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="litjohn's blog (Alt + H)">litjohn's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">惰性求值、无穷流与发生的魔法</h1><div class=post-meta><span title='2025-10-13 15:15:17 +0800 +0800'>October 13, 2025</span></div></header><div class=post-content><p>光剑第二作！</p><h2 id=前言什么是魔法>前言：什么是魔法？<a hidden class=anchor aria-hidden=true href=#前言什么是魔法>#</a></h2><p>（注：这个前言可以跳过。它是最终成果展示。感到迷惑很正常，请先阅读正文。）</p><p>什么是魔法？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax </span><span class=nv>delay</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>syntax-rules </span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>((</span><span class=k>delay </span><span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=k>lambda </span><span class=p>()</span> <span class=nv>x</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>lazy-variable</span> <span class=nv>thunk</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>cons </span><span class=no>#f</span> <span class=nv>thunk</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>is-calculated?</span> <span class=nv>variable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>car </span><span class=nv>variable</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nb>force </span><span class=nv>variable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nf>is-calculated?</span> <span class=nv>variable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>cdr </span><span class=nv>variable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>begin</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>set-car! </span><span class=nv>variable</span> <span class=no>#t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>set-cdr! </span><span class=nv>variable</span> <span class=p>((</span><span class=nb>cdr </span><span class=nv>variable</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>cdr </span><span class=nv>variable</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax </span><span class=nv>stream-cons</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>syntax-rules </span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>((</span><span class=nf>stream-cons</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=nf>cons</span>
</span></span><span class=line><span class=cl>       <span class=nv>a</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nf>lazy-variable</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>delay </span><span class=nv>b</span><span class=p>))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>stream-car</span> <span class=nv>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>car </span><span class=nv>x</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>stream-cdr</span> <span class=nv>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>force </span><span class=p>(</span><span class=nb>cdr </span><span class=nv>x</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>int-from</span> <span class=nv>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>stream-cons</span>
</span></span><span class=line><span class=cl>    <span class=nv>n</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>int-from</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>+ </span><span class=nv>n</span> <span class=mi>1</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>nature-numbers</span> <span class=p>(</span><span class=nf>int-from</span> <span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>真成四十行代码了。感兴趣的读者可以数一数，刚好 39 行。</p><p>然后下面还有一些有趣的小工具：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>get</span> <span class=nv>a</span> <span class=nv>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>= </span><span class=nv>pos</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>stream-car</span> <span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>get</span> <span class=p>(</span><span class=nf>stream-cdr</span> <span class=nv>a</span><span class=p>)</span> <span class=p>(</span><span class=nb>- </span><span class=nv>pos</span> <span class=mi>1</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>take</span> <span class=nv>a</span> <span class=nv>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>= </span><span class=nv>len</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=o>&#39;</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   <span class=p>(</span><span class=nf>cons</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=nf>stream-car</span> <span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=nf>take</span> <span class=p>(</span><span class=nf>stream-cdr</span> <span class=nv>a</span><span class=p>)</span> <span class=p>(</span><span class=nb>- </span><span class=nv>len</span> <span class=mi>1</span><span class=p>)))))</span>
</span></span></code></pre></td></tr></table></div></div><p>这些有什么用呢？请见下文。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>org</span> <span class=o>&#39;</span><span class=p>(</span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>twice</span> <span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>null? </span><span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>&#39;</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>stream-cons</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>* </span><span class=mi>2</span> <span class=p>(</span><span class=nb>car </span><span class=nv>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>twice</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>a</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>new</span> <span class=p>(</span><span class=nf>twice</span> <span class=nv>org</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>这里实现了类似于 C++ 20 <code>std::views</code> 库中的视窗的东西。具备类似的惰性求值特性。</p><p>更加抽象的范式。我们发现上面的具体的“将一个元素变成它的二倍”的操作其实是和整体框架的“构建一个流，每个元素是原始列表/流中对应元素经过一个变换后得到的”的语义无关的。</p><p>于是把框架提取出来，变成类似于列表的 map 的操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>transfer-to-stream</span> <span class=nv>operator</span> <span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>null? </span><span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>&#39;</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>stream-cons</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>operator</span> <span class=p>(</span><span class=nb>car </span><span class=nv>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>transfer-to-stream</span> <span class=nv>operator</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>a</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>stream-map</span> <span class=nv>operator</span> <span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>null? </span><span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>&#39;</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>stream-cons</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>operator</span> <span class=p>(</span><span class=nf>stream-car</span> <span class=nv>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>stream-map</span> <span class=nv>operator</span> <span class=p>(</span><span class=nf>stream-cdr</span> <span class=nv>a</span><span class=p>)))))</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=正文>正文<a hidden class=anchor aria-hidden=true href=#正文>#</a></h2><p>好了好了炫技到此结束。如果看到这里你都能看懂的话就可以离开了，这篇文章大概不会对您这样的大佬产生什么帮助。</p><p>而如果你一头雾水也完全不要紧。正文从这里才刚刚开始。</p><h3 id=目标--魔法>目标 · 魔法<a hidden class=anchor aria-hidden=true href=#目标--魔法>#</a></h3><p>“一个存储着所有自然数的、无穷大的列表”。</p><p>在有着有限内存的计算机中，这是不可能达成的任务。然而，今天我们将亲手实现它。用非常少的代码。</p><h3 id=惰性求值--魔法的机理>惰性求值 · 魔法的机理<a hidden class=anchor aria-hidden=true href=#惰性求值--魔法的机理>#</a></h3><p>各位听说过“惰性求值”（lazy-evaluation）吗？大概的思想就是，一个变量我们不立刻算出它的值，而是把它背后的“计算”保存起来，直到要用的时候才算出它的值。以此避免不必要的计算。</p><p>举个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>myClass</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>myClass</span> <span class=n>res</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// lots of work
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>x</span> <span class=o>=</span> <span class=n>foo</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>假设 C++ 是惰性求值的，这里程序就不会在 <code>x</code> 定义时立刻执行 <code>foo()</code> 并计算返回值。而是会到你真正使用 <code>x</code> 的值的时候再执行 <code>foo()</code> 并计算出 <code>x</code> 的真实值。</p><p>不过，我们熟悉的 C++ 和大多数主流语言都是严格求值/应用序求值的。并不（默认）支持这种特性。一个表达式被绑定到变量上，它立刻就被求值。函数调用时，也先对函数本身以及各个参数进行求值。比如这个函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>调用 <code>foo(3 + 3)</code> 时就会先求值 <code>foo</code> 发现它是一个函数。然后求值参数 <code>x</code>，发现它是 <code>3 + 3</code>，等于 6.函数体里面 <code>x</code> 的值直接就是 6.</p><p>但是某些语言是默认惰性求值的。一个著名的例子是 haskell。它们在这种地方会让 <code>x</code> 变成一个未完成的计算 <code>3 + 3</code>，直到使用了 <code>x * 2</code> 时才求出 <code>x</code> 的值是 6，并返回 <code>6 * 2</code> = 12.</p><hr><p>这是第一项前置知识。它是整个魔法的基础，我们能够创造出无穷大的列表，正是因为我们并没有创造出它！</p><p>我们只需要创造出那些我们需要使用的部分就可以了。比如说，如果我们的程序只访问了自然数列表的前十项，就只计算出这前十项。</p><h3 id=手动实现惰性求值--魔法的材料>手动实现惰性求值 · 魔法的材料<a hidden class=anchor aria-hidden=true href=#手动实现惰性求值--魔法的材料>#</a></h3><p>在一门严格求值的语言中，我们也是可以通过一些手法实现惰性求值机制的。</p><p>最经典的方法是利用 lambda。</p><p>我们知道，一个函数的函数体只有在调用时才会被求值。这个特性是容易理解的：函数需要知道参数以及引用的自由变量的值才能确定函数体的值。你不可能在函数定义时就准确地知道每次调用它产生的副作用和返回值。</p><p>这就产生了一个天然的惰性求值对象！我们可以用它来构建惰性求值系统。</p><p>具体地。我们知道这样的东西：</p><p>对于任意一个函数 $g$，定义
$$f:=\lambda x.(g\ x)$$
则有 $f$ 和 $g$ 等价。</p><p>从感性上，这是显然的。对于任意输入，$f$ 和 $g$ 的输出都一模一样。$f$ 干的唯一一件事就是把输入扔给了 $g$ 处理。它自己什么都没干。</p><p>在 lambda 演算的体系中，这是三条计算法则之一 η 变换。</p><p>那么，我们就可以用一层 lambda（lambda 本质上是匿名函数/函数字面量）来包裹住表达式！</p><p>这样，表达式就不会立即被求值了。而如果我们要获取表达式的值，只需要应用那个 lambda，就能得到表达式的求值结果。</p><p>lambda 的参数具体是什么不重要，因为我们只是想要创建一个延迟求值的计算或者得到被延迟的计算的值。所以，干脆就不要参数了！一个无参数的 lambda 能够最简洁清晰地达成我们的目的。</p><p>有一个术语用来描述这些：thunk。它指的是被延迟求值的计算。</p><hr><p>下面不得不涉及到一些细节。用 C++ 来写本文的代码会非常痛苦，需要和类型系统搏斗，给代码加上大量的模板技巧……那会完全掩盖思想的优雅本质。所以本文的代码不采用 C++。</p><p>相反地，我们采用 scheme。scheme 是一门 lisp 方言，具有动态类型和函数式特性。也是一门严格求值的语言。</p><p>scheme 的代码是以“S 表达式”（符号表达式）的形式组织的。</p><p>快速了解一下 S-表达式：</p><ul><li><strong>核心是列表 (List)：</strong> S-表达式的基本形式是由圆括号 <code>()</code> 包围起来的列表。</li><li><strong>结构：<code>(操作符 参数1 参数2 ...)</code>：</strong> 列表中的第一个元素通常是<strong>操作符</strong>（即要应用的函数），其余元素则是传递给该操作符的<strong>参数</strong>。</li><li><strong>原子 (Atom) 与嵌套：</strong> 列表中的元素可以是<strong>原子</strong>（如数字 <code>123</code>、符号 <code>x</code>、<code>+</code>），也可以是另一个 S-表达式。这种嵌套能力使得 S-表达式可以表示复杂的树状结构。</li></ul><p>例如，表达式 <code>(+ 1 (* 2 3))</code> 在 Scheme 中表示数学上的 <code>1 + (2 * 3)</code>。
这里：</p><ol><li>最外层的 <code>(+ 1 (* 2 3))</code> 是一个 S-表达式。<code>+</code> 是操作符，<code>1</code> 和 <code>(* 2 3)</code> 是它的参数。</li><li><code>(* 2 3)</code> 本身也是一个 S-表达式。<code>*</code> 是操作符，<code>2</code> 和 <code>3</code> 是它的参数。执行它会得到 <code>6</code>。</li><li>所以整个表达式 <code>(+ 1 6)</code> 最终会计算得到 <code>7</code>。</li></ol><p>你可以通过搜索、查阅文档或者询问 AI 得到 scheme 的更多信息。本文不过多赘述。</p><hr><p>于是我们就可以理解前言的第一段，delay、force 以及 lazy-variable 是在干什么了。delay 接受一个表达式，把它用 lambda 包装起来变成一个 thunk。force 对一个惰性求值的变量求取值，得到它的真实值。</p><p>lazy-variable 是在干什么？它对 delay 给出的 thunk 进行了进一步的封装，加上了一个标志说明它是否已被求值。因为如果每次 force 取值都重新调用一遍 thunk，我们会不停地重复计算一模一样的东西，时间复杂度就寄了。</p><p>所以，我们需要记忆化。第一次对于一个惰性变量的取值会求值 thunk，之后它的值就被存储在一个普通变量里了，不需要重复计算。</p><p>force 如何区分一个惰性变量是否被求值过了？就是靠 lazy-variable 引入的那个标志位。</p><p>注意到 delay 是一个宏。因为 scheme 是应用序求值的。如果用一般的函数，参数会被先求值，就无法实现惰性求值了。</p><hr><p>到这里，我们就在 scheme 这门严格求值的语言中手动实现了惰性求值系统。</p><h3 id=流--魔法现身>流 · 魔法现身！<a hidden class=anchor aria-hidden=true href=#流--魔法现身>#</a></h3><p>有了惰性的变量，我们自然可以定义惰性求值的数据结构！</p><p>“流”就是一个这样的惰性数据结构。具体的，它是一个列表。不过，它并不从一开始就存储着所有的数据，而是在访问时才生成真实的元素。（惰性求值特性）</p><p>流可以是无穷大的，因为它只有被访问的项才会被生成。这就是我们最开始提出的魔法。</p><p>我们如何实现一个流呢？我们发现，一个流的被计算完成的 cons 单元，它的数据域（car）就是一个普通的值。而指针域指向的，“下一项”却有可能是依然没有被生成的 thunk。</p><p>所以就有了前言中的这些：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define-syntax </span><span class=nv>stream-cons</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>syntax-rules </span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>((</span><span class=nf>stream-cons</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=nf>cons</span>
</span></span><span class=line><span class=cl>       <span class=nv>a</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=nf>lazy-variable</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=k>delay </span><span class=nv>b</span><span class=p>))))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>stream-car</span> <span class=nv>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>car </span><span class=nv>x</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>stream-cdr</span> <span class=nv>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>force </span><span class=p>(</span><span class=nb>cdr </span><span class=nv>x</span><span class=p>)))</span>
</span></span></code></pre></td></tr></table></div></div><p>有了这些，我们如何构造出一个具体的流呢？比如一个全部项都是 1 的无穷流？</p><p>你可能会想，一个全部都是 1 的无穷流，和它自己前面加上一个 1 是完全等价的。于是你可能会写出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>one</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>stream-cons</span> <span class=mi>1</span> <span class=nv>one</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>然而这是错的。你会惊讶地发现，把上面代码中的 stream-cons 换成 cons，也能运行并且生成一个循环列表。这是 scheme 的一个特性。</p><p>所以，上面的代码并不是你想象中被延迟无穷递归的无穷流，而只是一个普通的循环列表，指针域被延迟求值了而已。</p><p>真正的实现利用的是函数被延迟的无穷递归。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>one</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>stream-cons</span> <span class=mi>1</span> <span class=p>(</span><span class=nf>one</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>stream-of-one</span> <span class=p>(</span><span class=nf>one</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>当你在这个流上遍历的时候，你会不断地触及到被延迟求值的 one 调用。而它返回 1 和另一个被延迟的 one 调用构成的 cons 单元，永无休止。这是一个无穷流。</p><p>以及，我们可以完成那个魔法了！自然数流，启动！</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>int-from</span> <span class=nv>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>stream-cons</span>
</span></span><span class=line><span class=cl>    <span class=nv>n</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>int-from</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>+ </span><span class=nv>n</span> <span class=mi>1</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>nature-numbers</span> <span class=p>(</span><span class=nf>int-from</span> <span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=魔法现身之后的应用>魔法现身之后的应用<a hidden class=anchor aria-hidden=true href=#魔法现身之后的应用>#</a></h3><p>我们需要一些操纵流的方法。我们已经有了 stream-car 和 stream-cdr 来访问它。不过还不够。</p><p>前言中的 take 和 get，一个用来取一个流的前若干项（项数不足就 RE），一个用来取一个流的第 i 项（0-base，流的第一项是第 0 项）</p><p>这些都很简单。不过下面的才是真正的重量级，也是流的实际应用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=p>(</span><span class=nf>twice</span> <span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>null? </span><span class=nv>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>&#39;</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>stream-cons</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>* </span><span class=mi>2</span> <span class=p>(</span><span class=nb>car </span><span class=nv>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>twice</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>a</span><span class=p>)))))</span>
</span></span></code></pre></td></tr></table></div></div><p>从一个列表创建一个流，流的每一项是原始列表对应项的两倍。</p><p>这里前言里面有介绍。</p><p>然后是 transfer-to-stream 和 stream-map。都是类似于普通列表的 map 的操作（将每个元素做给定变换，然后用变换后的元素创建并返回新的列表）。不过一个是从列表 map 到流，一个是流 map 到流。</p><h3 id=操作的组合--管道>操作的组合 · 管道<a hidden class=anchor aria-hidden=true href=#操作的组合--管道>#</a></h3><p>这里不得不提到另外一个概念：管道。</p><p>管道是一种高阶函数。它描述的是这样的一种东西：数据进入第一个函数，流出来变成返回值，然后继续进入第二个函数……就像水流过管道，数据流过一系列处理它的函数。</p><p>下面就是一个简单的管道实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>combine</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>f</span> <span class=nv>g</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>lambda </span><span class=nv>x</span> <span class=p>(</span><span class=nf>g</span> <span class=p>(</span><span class=nb>apply </span><span class=nv>f</span> <span class=nv>x</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>tunnel</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>lambda </span><span class=nv>list-of-params</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>x</span> <span class=p>(</span><span class=nb>car </span><span class=nv>list-of-params</span><span class=p>))</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nf>tmp</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>list-of-params</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>null? </span><span class=nv>tmp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nv>x</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>y</span> <span class=p>(</span><span class=nb>car </span><span class=nv>tmp</span><span class=p>))</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nf>rest</span> <span class=p>(</span><span class=nb>cdr </span><span class=nv>tmp</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nb>apply </span><span class=nv>tunnel</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nf>cons</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nf>combine</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=nv>rest</span><span class=p>)))))))</span>
</span></span></code></pre></td></tr></table></div></div><p>管道使得我们可以组合对一个流的不同操作，制造“数据的流水线”。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>example</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>stream-map</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>tunnel</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>* </span><span class=nv>x</span> <span class=nv>x</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>x</span> <span class=mi>3</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>lambda </span><span class=p>(</span><span class=nf>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>log </span><span class=nv>x</span> <span class=mi>2</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nv>nature-numbers</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=魔法的代价惰性与可变状态的冲突>魔法的代价：惰性与可变状态的冲突<a hidden class=anchor aria-hidden=true href=#魔法的代价惰性与可变状态的冲突>#</a></h3><p>scheme 中函数的闭包对作用域是默认按引用捕获的。也就是说，如果我包装的 thunk 在被计算之前，内部引用的自由变量被修改了或者生命周期结束，惰性求值的结果就会和严格求值不同。</p><p>一个问题发生的示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=nv>&gt;</span> <span class=p>(</span><span class=k>define </span><span class=nv>x</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nv>&gt;</span> <span class=p>(</span><span class=k>define </span><span class=nv>my-lazy-value</span> <span class=p>(</span><span class=nf>lazy-variable</span> <span class=p>(</span><span class=k>delay </span><span class=p>(</span><span class=nb>* </span><span class=nv>x</span> <span class=mi>2</span><span class=p>))))</span>  <span class=c1>; 值是 2x = 20</span>
</span></span><span class=line><span class=cl><span class=nv>&gt;</span> <span class=p>(</span><span class=k>set! </span><span class=nv>x</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nv>&gt;</span> <span class=p>(</span><span class=nb>force </span><span class=nv>my-lazy-value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=mi>200</span> <span class=c1>; something strange happened!</span>
</span></span></code></pre></td></tr></table></div></div><p>haskell 就没有这种问题。因为它是“纯”的，状态不会被莫名其妙地改掉。而我们上面的构建流的代码也是纯的，所以它们是安全的。</p><p>想要在可变状态中避免这种惨案的发生，我们需要一个“按值捕获”。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>x</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 使用 let 来“冻结”x 当前的值</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define </span><span class=nv>my-safe-lazy-value</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let </span><span class=p>((</span><span class=nf>frozen-x</span> <span class=nv>x</span><span class=p>))</span> <span class=c1>; frozen-x 是一个全新的绑定，其值为 10</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>lazy-variable</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>delay </span><span class=p>(</span><span class=nb>* </span><span class=nv>frozen-x</span> <span class=mi>2</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>set! </span><span class=nv>x</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>force </span><span class=nv>my-safe-lazy-value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>; ==&gt; 20</span>
</span></span></code></pre></td></tr></table></div></div><p>不过，需要注意的是，仅仅修改 delay 很难做到按值捕获。因为你无法预料哪些变量是自由的。或者你不可能先求值表达式再存储，那样惰性求值就不存在了。</p><p>我们只能手动按值捕获。</p><p>我们实现的 <code>delay</code> 机制，其默认行为是捕获变量的“绑定”而非“值”。这在处理可变状态时会带来非预期的结果。这并非 <code>delay</code> 实现的缺陷，而是 Scheme 语言设计哲学的一种体现。它要求我们，作为魔法的施法者，必须清楚地知道自己法术的边界。当需要“固化”状态时，我们必须亲手使用 <code>let</code> 咒语来创建一个不可变的副本，从而保证魔法效果的确定性。这种对控制权的明确要求，正是这门语言强大而迷人的一部分。</p><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>到此，本文就结束了。我们成功使用惰性求值将“创建一个无穷大的列表”这样不可能的魔法化作了现实。</p><p>我们亲手实现了一种声明式的方法。流可以让我们声明并组合对于列表的种种操作，而无需手动管理中间临时列表。</p><p>代码即思想，我们描述的是“是什么”，而不是“怎么算”，将逻辑与控制分离。</p><p>（BTW，也许你会好奇用 C++ 如何作到这些。那么你可以看看这个：<a href=https://www.luogu.com.cn/article/jomps7w6>https://www.luogu.com.cn/article/jomps7w6</a>，AI生成的代码，能够过编和运行，并且实现了和本文一样的 功能。）</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/plt/>PLT</a></li><li><a href=https://litjohn.github.io/tags/lisp/scheme/racket/>Lisp/Scheme/Racket</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>litjohn's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>