<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Start to Build a Compiler | litjohn's blog</title><meta name=keywords content="PLT,lisp/scheme/racket"><meta name=description content="光剑的后日谈 #1. 在文艺复兴之后，FP 也要大胜利！
在这篇文章的讨论区中，我进行了引流。为了报答作者，我写了这篇文章。
上面那篇文章中使用了一种伪代码语法来表示 lambda calculus。不过这种语法并不能直接运行。怎么办呢？让我们来构建一个源到源编译器！
要写一种语言的编译器，显然我们需要知道它的语法和词法。这是第一步。另外还有语义，但是它是 lambda 的一种表示法，所以语义已经被 lambda 定义了，无需考虑。
首先是词法。这种语言会出现哪些 tokens？
分类一下。lambda 的核心是函数抽象和函数应用。函数抽象用到哪些 tokens？

func 关键字。
冒号。
return 关键字。
参数列表和括号。

函数应用？

括号

另外还有一个扩展语法，绑定创建。

等号（赋值运算符）

然后我们需要定义它的语法。这篇文章使用的是单参数的原始 lambda，方便了我们的实现。


1
2
3
4
5
6


identifier ::= symbol
abstract-exp ::= func : (identifier) { return val-exp }
apply-exp ::= val-exp(val-exp)
bind-exp ::= identifier = val-exp
val-exp ::= identifier | abstract-exp | apply-exp
lc-exp ::= val-exp | bind-exp


看来挺简单的。"><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/start-to-build-a-compiler/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/start-to-build-a-compiler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/start-to-build-a-compiler/"><meta property="og:site_name" content="litjohn's blog"><meta property="og:title" content="Start to Build a Compiler"><meta property="og:description" content="光剑的后日谈 #1. 在文艺复兴之后，FP 也要大胜利！
在这篇文章的讨论区中，我进行了引流。为了报答作者，我写了这篇文章。
上面那篇文章中使用了一种伪代码语法来表示 lambda calculus。不过这种语法并不能直接运行。怎么办呢？让我们来构建一个源到源编译器！
要写一种语言的编译器，显然我们需要知道它的语法和词法。这是第一步。另外还有语义，但是它是 lambda 的一种表示法，所以语义已经被 lambda 定义了，无需考虑。
首先是词法。这种语言会出现哪些 tokens？
分类一下。lambda 的核心是函数抽象和函数应用。函数抽象用到哪些 tokens？
func 关键字。 冒号。 return 关键字。 参数列表和括号。 函数应用？
括号 另外还有一个扩展语法，绑定创建。
等号（赋值运算符） 然后我们需要定义它的语法。这篇文章使用的是单参数的原始 lambda，方便了我们的实现。
1 2 3 4 5 6 identifier ::= symbol abstract-exp ::= func : (identifier) { return val-exp } apply-exp ::= val-exp(val-exp) bind-exp ::= identifier = val-exp val-exp ::= identifier | abstract-exp | apply-exp lc-exp ::= val-exp | bind-exp 看来挺简单的。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-13T20:51:18+08:00"><meta property="article:modified_time" content="2025-10-13T20:51:18+08:00"><meta property="article:tag" content="PLT"><meta property="article:tag" content="Lisp/Scheme/Racket"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E8%B0%83%E7%94%A8%E6%A0%88de-bruijn-%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E5%8D%8F%E7%A8%8B%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E-call/cc-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"><meta property="og:see_also" content="https://litjohn.github.io/posts/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%97%A0%E7%A9%B7%E6%B5%81%E4%B8%8E%E5%8F%91%E7%94%9F%E7%9A%84%E9%AD%94%E6%B3%95/"><meta property="og:see_also" content="https://litjohn.github.io/posts/lets-build-our-mathematics-by-using-lambda-calculus--church-encoding/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Start to Build a Compiler"><meta name=twitter:description content="光剑的后日谈 #1. 在文艺复兴之后，FP 也要大胜利！
在这篇文章的讨论区中，我进行了引流。为了报答作者，我写了这篇文章。
上面那篇文章中使用了一种伪代码语法来表示 lambda calculus。不过这种语法并不能直接运行。怎么办呢？让我们来构建一个源到源编译器！
要写一种语言的编译器，显然我们需要知道它的语法和词法。这是第一步。另外还有语义，但是它是 lambda 的一种表示法，所以语义已经被 lambda 定义了，无需考虑。
首先是词法。这种语言会出现哪些 tokens？
分类一下。lambda 的核心是函数抽象和函数应用。函数抽象用到哪些 tokens？

func 关键字。
冒号。
return 关键字。
参数列表和括号。

函数应用？

括号

另外还有一个扩展语法，绑定创建。

等号（赋值运算符）

然后我们需要定义它的语法。这篇文章使用的是单参数的原始 lambda，方便了我们的实现。


1
2
3
4
5
6


identifier ::= symbol
abstract-exp ::= func : (identifier) { return val-exp }
apply-exp ::= val-exp(val-exp)
bind-exp ::= identifier = val-exp
val-exp ::= identifier | abstract-exp | apply-exp
lc-exp ::= val-exp | bind-exp


看来挺简单的。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Start to Build a Compiler","item":"https://litjohn.github.io/posts/start-to-build-a-compiler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Start to Build a Compiler","name":"Start to Build a Compiler","description":"光剑的后日谈 #1. 在文艺复兴之后，FP 也要大胜利！\n在这篇文章的讨论区中，我进行了引流。为了报答作者，我写了这篇文章。\n上面那篇文章中使用了一种伪代码语法来表示 lambda calculus。不过这种语法并不能直接运行。怎么办呢？让我们来构建一个源到源编译器！\n要写一种语言的编译器，显然我们需要知道它的语法和词法。这是第一步。另外还有语义，但是它是 lambda 的一种表示法，所以语义已经被 lambda 定义了，无需考虑。\n首先是词法。这种语言会出现哪些 tokens？\n分类一下。lambda 的核心是函数抽象和函数应用。函数抽象用到哪些 tokens？\nfunc 关键字。 冒号。 return 关键字。 参数列表和括号。 函数应用？\n括号 另外还有一个扩展语法，绑定创建。\n等号（赋值运算符） 然后我们需要定义它的语法。这篇文章使用的是单参数的原始 lambda，方便了我们的实现。\n1 2 3 4 5 6 identifier ::= symbol abstract-exp ::= func : (identifier) { return val-exp } apply-exp ::= val-exp(val-exp) bind-exp ::= identifier = val-exp val-exp ::= identifier | abstract-exp | apply-exp lc-exp ::= val-exp | bind-exp 看来挺简单的。\n","keywords":["PLT","lisp/scheme/racket"],"articleBody":"光剑的后日谈 #1. 在文艺复兴之后，FP 也要大胜利！\n在这篇文章的讨论区中，我进行了引流。为了报答作者，我写了这篇文章。\n上面那篇文章中使用了一种伪代码语法来表示 lambda calculus。不过这种语法并不能直接运行。怎么办呢？让我们来构建一个源到源编译器！\n要写一种语言的编译器，显然我们需要知道它的语法和词法。这是第一步。另外还有语义，但是它是 lambda 的一种表示法，所以语义已经被 lambda 定义了，无需考虑。\n首先是词法。这种语言会出现哪些 tokens？\n分类一下。lambda 的核心是函数抽象和函数应用。函数抽象用到哪些 tokens？\nfunc 关键字。 冒号。 return 关键字。 参数列表和括号。 函数应用？\n括号 另外还有一个扩展语法，绑定创建。\n等号（赋值运算符） 然后我们需要定义它的语法。这篇文章使用的是单参数的原始 lambda，方便了我们的实现。\n1 2 3 4 5 6 identifier ::= symbol abstract-exp ::= func : (identifier) { return val-exp } apply-exp ::= val-exp(val-exp) bind-exp ::= identifier = val-exp val-exp ::= identifier | abstract-exp | apply-exp lc-exp ::= val-exp | bind-exp 看来挺简单的。\n在定义了词法和语法之后，就是解析环节了。我们需要把字符串解析成 token 流，从而需要一个 lexer。\n等于号，冒号和括号是可用的分隔符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #lang racket (define (get-a-token str) (define res '()) (let loop ([i 0]) (if (\u003c i (string-length str)) (case (string-ref str i) [(#\\space) (if (null? res) (loop (+ i 1)) (values #f (string-\u003esymbol (list-\u003estring (reverse res))) (substring str (+ i 1) (string-length str))))] [(#\\: #\\( #\\) #\\= #\\{ #\\}) (values (if (null? res) #f (string-\u003esymbol (list-\u003estring (reverse res)))) (string-\u003esymbol (string (string-ref str i))) (substring str (+ i 1) (string-length str)))] [else (set! res (cons (string-ref str i) res)) (loop (+ i 1))]) (values (string-\u003esymbol (list-\u003estring (reverse res))) #f \"\")))) (define (lexer str) (if (= (string-length str) 0) '() (let-values ([(s1 s2 rest) (get-a-token str)]) (cond [(and s1 s2) (cons s1 (cons s2 (lexer rest)))] [s1 (list s1)] [s2 (cons s2 (lexer rest))] [else (error \"There's something wrong with lexer!\")])))) 写的非常唐，不过能用就行了。存在一个问题是换行符，但是这里又有 CRLF，CR 和 LF 的问题，就很难处理。索性不处理了，压行算了。\n这里还有另一个更严重的问题：我们调用了很多 substring，这导致复杂度退化成平方了。如何解决呢？\n其实很简单，我们的扫描步骤是顺序访问的，那么使用 racket 的经典数据结构列表就可以了。下面是重写之后的 lexer：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #lang racket ;;; ====================================================== ;;; 新版 Lexer (基于列表处理的函数式风格) ;;; ====================================================== ;; 辅助函数: 判断一个字符是否为分隔符 (define (delimiter? c) (member c '(#\\: #\\( #\\) #\\= #\\{ #\\}))) ;; 辅助函数: 判断一个字符是否为空白符 (define (whitespace? c) (char-whitespace? c)) ;; 核心辅助函数: 从字符列表开头读取一个完整的单词(标识符或关键字) ;; 返回两个值: 1. 单词转换成的符号 2. 剩余的字符列表 (define (read-word char-list) (let loop ([cs char-list] [acc '()]) (if (or (null? cs) (let ([c (car cs)]) (or (whitespace? c) (delimiter? c)))) ;; 遇到空白或分隔符，或者列表为空，结束读取 (values (string-\u003esymbol (list-\u003estring (reverse acc))) cs) ;; 否则，将当前字符加入累加器，继续处理剩余列表 (loop (cdr cs) (cons (car cs) acc))))) ;; 主词法分析循环 (define (tokenize-loop char-list) (if (null? char-list) '() ; 输入列表为空，返回空列表 (let ([c (car char-list)]) (cond ;; 1. 如果是空白符，则忽略它，直接处理剩余部分 [(whitespace? c) (tokenize-loop (cdr char-list))] ;; 2. 如果是单个字符的分隔符，将其作为 token，然后处理剩余部分 [(delimiter? c) (cons (string-\u003esymbol (string c)) (tokenize-loop (cdr char-list)))] ;; 3. 否则，它是一个单词的开始，调用 read-word 来读取它 [else (let-values ([(word remaining-chars) (read-word char-list)]) (cons word (tokenize-loop remaining-chars)))])))) ;; Lexer 的公共接口 ;; 它将字符串转换为字符列表，然后启动主循环 (define (lexer str) (tokenize-loop (string-\u003elist str))) 下一步是可爱的 parser。把 token 流解析成 AST。这一步用 EOPL 模块的 define-datatype 会很好，但是我不想用。于是使用 racket 自己的 struct 作为 AST 节点。\n另外在这一步我用了一些不是非常 lisp-style 的做法，具体而言把符号列表的 token 流转化为 vector 来操作，用下标区间来标定当前在解析哪部分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; 1. AST Node Definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (struct identifier (name) #:transparent) (struct abstract-exp (param body) #:transparent) (struct apply-exp (rator rand) #:transparent) (struct bind-exp (name val) #:transparent) (define (is-keyword? s) (member s '(func : ( ) { } return =))) (define (is-identifier-token? t) (and (symbol? t) (not (is-keyword? t)))) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; 2. Parser ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (define (parse tokens) (let-values ([(ast next-i) (parse-lc-exp (list-\u003evector tokens) 0)]) (if (= next-i (vector-length (list-\u003evector tokens))) ast (error \"Parsing failed: unexpected tokens remain at the end.\" (vector-ref (list-\u003evector tokens) next-i))))) (define (parse-lc-exp tokens i) (let ([tok1 (vector-ref tokens i)]) (if (and (is-identifier-token? tok1) (\u003c (+ i 1) (vector-length tokens)) (eq? (vector-ref tokens (+ i 1)) '=)) (parse-bind-exp tokens i) (parse-val-exp tokens i)))) (define (parse-bind-exp tokens i) (let* ([id-name (vector-ref tokens i)] [val-start-i (+ i 2)]) (let-values ([(val-ast next-i) (parse-val-exp tokens val-start-i)]) (values (bind-exp (identifier id-name) val-ast) next-i)))) ; 使用 |(|, |)|, |{|, |}| 以防止与读取器冲突 (define (parse-abstract-exp tokens i) (let* ([param-name (vector-ref tokens (+ i 3))] [body-start-i (+ i 7)]) (unless (and (eq? (vector-ref tokens i) 'func) (eq? (vector-ref tokens (+ i 1)) ':) (eq? (vector-ref tokens (+ i 2)) '|(|) (is-identifier-token? param-name) (eq? (vector-ref tokens (+ i 4)) '|)|) (eq? (vector-ref tokens (+ i 5)) '|{|) (eq? (vector-ref tokens (+ i 6)) 'return)) (error \"Invalid function definition syntax\")) (let-values ([(body-ast body-end-i) (parse-val-exp tokens body-start-i)]) (unless (and (\u003c body-end-i (vector-length tokens)) (eq? (vector-ref tokens body-end-i) '|}|)) (error \"Expected '}' at the end of function body\")) (values (abstract-exp (identifier param-name) body-ast) (+ body-end-i 1))))) (define (parse-val-exp tokens i) (let-values ([(left-ast next-i) (let ([tok (vector-ref tokens i)]) (cond [(eq? tok 'func) (parse-abstract-exp tokens i)] [(is-identifier-token? tok) (values (identifier tok) (+ i 1))] [else (error \"Invalid value expression: expected identifier or function at index\" i)]))]) (let loop ([current-ast left-ast] [current-i next-i]) ; 检查是否是函数应用 (if (and (\u003c current-i (vector-length tokens)) (eq? (vector-ref tokens current-i) '|(|)) ; 是: 解析参数, 构建 apply-exp, 然后继续循环 (let-values ([(arg-ast arg-end-i) (parse-val-exp tokens (+ current-i 1))]) (unless (and (\u003c arg-end-i (vector-length tokens)) (eq? (vector-ref tokens arg-end-i) '|)|)) (error \"Expected ')' to close function application\")) (loop (apply-exp current-ast arg-ast) (+ arg-end-i 1))) ; 否: 循环结束, 返回当前积累的 AST 和索引 (values current-ast current-i))))) 看着有点令人头大。其实这是 AIGC 代码，感谢 Gemini 2.5 Pro 给予的帮助。\nparser 写起来确实令人无比头大。各种神秘的位置编码和 hack……我开始怀疑自己为什么不使用（或者不打算使用）match 来进行分发。这段代码让人完全没有调试的想法。\n这些解析大致使用了递归下降法。这是一种非常经典的方法，具体而言，我们一开始以归纳（inductive）的形式定义了语言的语法。然后我们将具体语法转换为抽象语法，为每种语法元素定义一种节点类型，为每种节点类型定义一个过程进行解析，解析的过程就变成了这些函数互相递归的过程。\n也即是一种数据驱动的编程：一个语法元素对应一种 AST 节点和一个 struct 定义，解析它对应一个过程，元素可能的多种情形对应 cond 的不同分支，归纳的定义对应函数间的相互递归。\n要进行更多的了解，推荐阅读《essential of programming languages》（即 EOPL）。\n进行一些测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; 3. Testing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (define test-str-1 \"id = func : (x) { return x }\") (define test-str-2 \"apply = func : (f) { return func : (x) { return f(x) } }\") (define test-str-3 \"id(y)\") (define test-str-4 \"get-y(f)(x)\") (displayln \"--- Test 1: Binding ---\") (pretty-print (parse (lexer test-str-1))) (displayln \"--- Test 2: Currying ---\") (pretty-print (parse (lexer test-str-2))) (displayln \"--- Test 3: Simple Application ---\") (pretty-print (parse (lexer test-str-3))) (displayln \"--- Test 4: Chained Application ---\") (pretty-print (parse (lexer test-str-4))) 结果：\n1 2 3 4 5 6 7 8 9 10 11 12 --- Test 1: Binding --- (bind-exp (identifier 'id) (abstract-exp (identifier 'x) (identifier 'x))) --- Test 2: Currying --- (bind-exp (identifier 'apply) (abstract-exp (identifier 'f) (abstract-exp (identifier 'x) (apply-exp (identifier 'f) (identifier 'x))))) --- Test 3: Simple Application --- (apply-exp (identifier 'id) (identifier 'y)) --- Test 4: Chained Application --- (apply-exp (apply-exp (identifier 'get-y) (identifier 'f)) (identifier 'x)) 可以看到，parse 的结果是正确的。\n在建出 AST 之后，进行语法转换就非常容易了。因为源语言和目标语言只不过是 lc-exp 的两种不同表示法（具体语法，concrete syntax）。有了抽象语法，转换为不同的具体语法易如反掌。\n吸取了 parser 的惨痛教训，这次我们使用 match 进行操作。\n1 2 3 4 5 6 (define (convert node) (match node [(bind-exp name val) `(define ,(convert name) ,(convert val))] [(apply-exp rator rand) `(,(convert rator) ,(convert rand))] [(abstract-exp arg body) `(lambda (,(convert arg)) ,(convert body))] [(identifier id) id])) 然后一些测试。我们用上次的老例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (define test-str-1 \"id = func : (x) { return x }\") (define test-str-2 \"apply = func : (f) { return func : (x) { return f(x) } }\") (define test-str-3 \"id(y)\") (define test-str-4 \"get-y(f)(x)\") (displayln \"--- Test 1: Binding ---\") (displayln (convert (parse (lexer test-str-1)))) (displayln \"--- Test 2: Currying ---\") (displayln (convert (parse (lexer test-str-2)))) (displayln \"--- Test 3: Simple Application ---\") (displayln (convert (parse (lexer test-str-3)))) (displayln \"--- Test 4: Chained Application ---\") (displayln (convert (parse (lexer test-str-4)))) 结果：\n1 2 3 4 5 6 7 8 --- Test 1: Binding --- (define id (lambda (x) x)) --- Test 2: Currying --- (define apply (lambda (f) (lambda (x) (f x)))) --- Test 3: Simple Application --- (id y) --- Test 4: Chained Application --- ((get-y f) x) 成功了！\n这样，我们就可以将伪代码直接送进 chez scheme 或者 racket 运行了！\n更重要的是，我们亲手走了一遍扫描（词法分析）、解析（语法分析）和代码生成的编译流程。构建了一个简易的源到源编译器。\n如果想要了解更多，推荐阅读 EOPL（《essential of programming languages》），friedman 教授的著作。其中第一章就是归纳式的语法，全书会带领你实现各种各样语言的解释器以学习种种语言特性。\n最后是完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #lang racket ;;; ====================================================== ;;; 新版 Lexer (基于列表处理的函数式风格) ;;; ====================================================== ;; 辅助函数: 判断一个字符是否为分隔符 (define (delimiter? c) (member c '(#\\: #\\( #\\) #\\= #\\{ #\\}))) ;; 辅助函数: 判断一个字符是否为空白符 (define (whitespace? c) (char-whitespace? c)) ;; 核心辅助函数: 从字符列表开头读取一个完整的单词(标识符或关键字) ;; 返回两个值: 1. 单词转换成的符号 2. 剩余的字符列表 (define (read-word char-list) (let loop ([cs char-list] [acc '()]) (if (or (null? cs) (let ([c (car cs)]) (or (whitespace? c) (delimiter? c)))) ;; 遇到空白或分隔符，或者列表为空，结束读取 (values (string-\u003esymbol (list-\u003estring (reverse acc))) cs) ;; 否则，将当前字符加入累加器，继续处理剩余列表 (loop (cdr cs) (cons (car cs) acc))))) ;; 主词法分析循环 (define (tokenize-loop char-list) (if (null? char-list) '() ; 输入列表为空，返回空列表 (let ([c (car char-list)]) (cond ;; 1. 如果是空白符，则忽略它，直接处理剩余部分 [(whitespace? c) (tokenize-loop (cdr char-list))] ;; 2. 如果是单个字符的分隔符，将其作为 token，然后处理剩余部分 [(delimiter? c) (cons (string-\u003esymbol (string c)) (tokenize-loop (cdr char-list)))] ;; 3. 否则，它是一个单词的开始，调用 read-word 来读取它 [else (let-values ([(word remaining-chars) (read-word char-list)]) (cons word (tokenize-loop remaining-chars)))])))) ;; Lexer 的公共接口 ;; 它将字符串转换为字符列表，然后启动主循环 (define (lexer str) (tokenize-loop (string-\u003elist str))) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; 1. AST Node Definitions (保持不变) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (struct identifier (name) #:transparent) (struct abstract-exp (param body) #:transparent) (struct apply-exp (rator rand) #:transparent) (struct bind-exp (name val) #:transparent) (define (is-keyword? s) (member s '(func : ( ) { } return =))) (define (is-identifier-token? t) (and (symbol? t) (not (is-keyword? t)))) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; 2. Parser (修正版) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (define (parse tokens) (let-values ([(ast next-i) (parse-lc-exp (list-\u003evector tokens) 0)]) (if (= next-i (vector-length (list-\u003evector tokens))) ast (error \"Parsing failed: unexpected tokens remain at the end.\" (vector-ref (list-\u003evector tokens) next-i))))) (define (parse-lc-exp tokens i) (let ([tok1 (vector-ref tokens i)]) (if (and (is-identifier-token? tok1) (\u003c (+ i 1) (vector-length tokens)) (eq? (vector-ref tokens (+ i 1)) '=)) (parse-bind-exp tokens i) (parse-val-exp tokens i)))) (define (parse-bind-exp tokens i) (let* ([id-name (vector-ref tokens i)] [val-start-i (+ i 2)]) (let-values ([(val-ast next-i) (parse-val-exp tokens val-start-i)]) (values (bind-exp (identifier id-name) val-ast) next-i)))) ; 修正: 使用 |(|, |)|, |{|, |}| (define (parse-abstract-exp tokens i) (let* ([param-name (vector-ref tokens (+ i 3))] [body-start-i (+ i 7)]) (unless (and (eq? (vector-ref tokens i) 'func) (eq? (vector-ref tokens (+ i 1)) ':) (eq? (vector-ref tokens (+ i 2)) '|(|) (is-identifier-token? param-name) (eq? (vector-ref tokens (+ i 4)) '|)|) (eq? (vector-ref tokens (+ i 5)) '|{|) (eq? (vector-ref tokens (+ i 6)) 'return)) (error \"Invalid function definition syntax\")) (let-values ([(body-ast body-end-i) (parse-val-exp tokens body-start-i)]) (unless (and (\u003c body-end-i (vector-length tokens)) (eq? (vector-ref tokens body-end-i) '|}|)) (error \"Expected '}' at the end of function body\")) (values (abstract-exp (identifier param-name) body-ast) (+ body-end-i 1))))) ; 修正: 修复 loop 的逻辑, 确保有 else 分支, 并使用正确的符号 (define (parse-val-exp tokens i) (let-values ([(left-ast next-i) (let ([tok (vector-ref tokens i)]) (cond [(eq? tok 'func) (parse-abstract-exp tokens i)] [(is-identifier-token? tok) (values (identifier tok) (+ i 1))] [else (error \"Invalid value expression: expected identifier or function at index\" i)]))]) (let loop ([current-ast left-ast] [current-i next-i]) ; 检查是否是函数应用 (if (and (\u003c current-i (vector-length tokens)) (eq? (vector-ref tokens current-i) '|(|)) ; 是: 解析参数, 构建 apply-exp, 然后继续循环 (let-values ([(arg-ast arg-end-i) (parse-val-exp tokens (+ current-i 1))]) (unless (and (\u003c arg-end-i (vector-length tokens)) (eq? (vector-ref tokens arg-end-i) '|)|)) (error \"Expected ')' to close function application\")) (loop (apply-exp current-ast arg-ast) (+ arg-end-i 1))) ; 否: 循环结束, 返回当前积累的 AST 和索引 (values current-ast current-i))))) (define (convert node) (match node [(bind-exp name val) `(define ,(convert name) ,(convert val))] [(apply-exp rator rand) `(,(convert rator) ,(convert rand))] [(abstract-exp arg body) `(lambda (,(convert arg)) ,(convert body))] [(identifier id) id])) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; 3. Testing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #| (define test-str-1 \"id = func : (x) { return x }\") (define test-str-2 \"apply = func : (f) { return func : (x) { return f(x) } }\") (define test-str-3 \"id(y)\") (define test-str-4 \"get-y(f)(x)\") (displayln \"--- Test 1: Binding ---\") (displayln (convert (parse (lexer test-str-1)))) (displayln \"--- Test 2: Currying ---\") (displayln (convert (parse (lexer test-str-2)))) (displayln \"--- Test 3: Simple Application ---\") (displayln (convert (parse (lexer test-str-3)))) (displayln \"--- Test 4: Chained Application ---\") (displayln (convert (parse (lexer test-str-4)))) |# ","wordCount":"2080","inLanguage":"en","datePublished":"2025-10-13T20:51:18+08:00","dateModified":"2025-10-13T20:51:18+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/start-to-build-a-compiler/"},"publisher":{"@type":"Organization","name":"litjohn's blog","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="litjohn's blog (Alt + H)">litjohn's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Start to Build a Compiler</h1><div class=post-meta><span title='2025-10-13 20:51:18 +0800 +0800'>October 13, 2025</span></div></header><div class=post-content><p>光剑的后日谈 #1. 在文艺复兴之后，FP 也要大胜利！</p><p>在<a href=https://www.luogu.com.cn/article/ha4xtgpc>这篇文章</a>的讨论区中，我进行了引流。为了报答作者，我写了这篇文章。</p><p>上面那篇文章中使用了一种伪代码语法来表示 lambda calculus。不过这种语法并不能直接运行。怎么办呢？让我们来构建一个源到源编译器！</p><p>要写一种语言的编译器，显然我们需要知道它的语法和词法。这是第一步。另外还有语义，但是它是 lambda 的一种表示法，所以语义已经被 lambda 定义了，无需考虑。</p><p>首先是词法。这种语言会出现哪些 tokens？</p><p>分类一下。lambda 的核心是函数抽象和函数应用。函数抽象用到哪些 tokens？</p><ul><li>func 关键字。</li><li>冒号。</li><li>return 关键字。</li><li>参数列表和括号。</li></ul><p>函数应用？</p><ul><li>括号</li></ul><p>另外还有一个扩展语法，绑定创建。</p><ul><li>等号（赋值运算符）</li></ul><p>然后我们需要定义它的语法。这篇文章使用的是单参数的原始 lambda，方便了我们的实现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>identifier ::= symbol
</span></span><span class=line><span class=cl>abstract-exp ::= func : (identifier) { return val-exp }
</span></span><span class=line><span class=cl>apply-exp ::= val-exp(val-exp)
</span></span><span class=line><span class=cl>bind-exp ::= identifier = val-exp
</span></span><span class=line><span class=cl>val-exp ::= identifier | abstract-exp | apply-exp
</span></span><span class=line><span class=cl>lc-exp ::= val-exp | bind-exp
</span></span></code></pre></td></tr></table></div></div><p>看来挺简单的。</p><p>在定义了词法和语法之后，就是解析环节了。我们需要把字符串解析成 token 流，从而需要一个 lexer。</p><p>等于号，冒号和括号是可用的分隔符。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>get-a-token</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>define</span> <span class=n>res</span> <span class=o>&#39;</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>i</span> <span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>i</span> <span class=p>(</span><span class=nb>string-length</span> <span class=n>str</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>case</span> <span class=p>(</span><span class=nb>string-ref</span> <span class=n>str</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>[(</span><span class=sc>#\space</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>null?</span> <span class=n>res</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=nb>values</span> <span class=no>#f</span> 
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=nb>string-&gt;symbol</span> <span class=p>(</span><span class=nb>list-&gt;string</span> <span class=p>(</span><span class=nb>reverse</span> <span class=n>res</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=nb>substring</span> <span class=n>str</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=nb>string-length</span> <span class=n>str</span><span class=p>))))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=p>[(</span><span class=sc>#\:</span> <span class=sc>#\(</span> <span class=sc>#\)</span> <span class=sc>#\=</span> <span class=sc>#\{</span> <span class=sc>#\}</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>values</span> 
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>null?</span> <span class=n>res</span><span class=p>)</span> <span class=no>#f</span> <span class=p>(</span><span class=nb>string-&gt;symbol</span> <span class=p>(</span><span class=nb>list-&gt;string</span> <span class=p>(</span><span class=nb>reverse</span> <span class=n>res</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=nb>string-&gt;symbol</span> <span class=p>(</span><span class=nb>string</span> <span class=p>(</span><span class=nb>string-ref</span> <span class=n>str</span> <span class=n>i</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=nb>substring</span> <span class=n>str</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=nb>string-length</span> <span class=n>str</span><span class=p>)))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=p>[</span><span class=k>else</span> <span class=p>(</span><span class=k>set!</span> <span class=n>res</span> <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=nb>string-ref</span> <span class=n>str</span> <span class=n>i</span><span class=p>)</span> <span class=n>res</span><span class=p>))</span> <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>values</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=nb>string-&gt;symbol</span> <span class=p>(</span><span class=nb>list-&gt;string</span> <span class=p>(</span><span class=nb>reverse</span> <span class=n>res</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                <span class=no>#f</span>
</span></span><span class=line><span class=cl>                <span class=s2>&#34;&#34;</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>=</span> <span class=p>(</span><span class=nb>string-length</span> <span class=n>str</span><span class=p>)</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>&#39;</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>s1</span> <span class=n>s2</span> <span class=nb>rest</span><span class=p>)</span> <span class=p>(</span><span class=n>get-a-token</span> <span class=n>str</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>                <span class=p>[(</span><span class=k>and</span> <span class=n>s1</span> <span class=n>s2</span><span class=p>)</span> <span class=p>(</span><span class=nb>cons</span> <span class=n>s1</span> <span class=p>(</span><span class=nb>cons</span> <span class=n>s2</span> <span class=p>(</span><span class=n>lexer</span> <span class=nb>rest</span><span class=p>)))]</span>
</span></span><span class=line><span class=cl>                <span class=p>[</span><span class=n>s1</span> <span class=p>(</span><span class=nb>list</span> <span class=n>s1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>                <span class=p>[</span><span class=n>s2</span> <span class=p>(</span><span class=nb>cons</span> <span class=n>s2</span> <span class=p>(</span><span class=n>lexer</span> <span class=nb>rest</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>                <span class=p>[</span><span class=k>else</span> <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;There&#39;s something wrong with lexer!&#34;</span><span class=p>)]))))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>写的非常唐，不过能用就行了。存在一个问题是换行符，但是这里又有 CRLF，CR 和 LF 的问题，就很难处理。索性不处理了，压行算了。</p><p>这里还有另一个更严重的问题：我们调用了很多 substring，这导致复杂度退化成平方了。如何解决呢？</p><p>其实很简单，我们的扫描步骤是顺序访问的，那么使用 racket 的经典数据结构列表就可以了。下面是重写之后的 lexer：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket</span>
</span></span><span class=line><span class=cl><span class=c1>;;; ======================================================</span>
</span></span><span class=line><span class=cl><span class=c1>;;;  新版 Lexer (基于列表处理的函数式风格)</span>
</span></span><span class=line><span class=cl><span class=c1>;;; ======================================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 辅助函数: 判断一个字符是否为分隔符</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>delimiter?</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>member</span> <span class=n>c</span> <span class=o>&#39;</span><span class=p>(</span><span class=sc>#\:</span> <span class=sc>#\(</span> <span class=sc>#\)</span> <span class=sc>#\=</span> <span class=sc>#\{</span> <span class=sc>#\}</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 辅助函数: 判断一个字符是否为空白符</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>whitespace?</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>char-whitespace?</span> <span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 核心辅助函数: 从字符列表开头读取一个完整的单词(标识符或关键字)</span>
</span></span><span class=line><span class=cl><span class=c1>;; 返回两个值: 1. 单词转换成的符号  2. 剩余的字符列表</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>read-word</span> <span class=n>char-list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>cs</span> <span class=n>char-list</span><span class=p>]</span> <span class=p>[</span><span class=n>acc</span> <span class=o>&#39;</span><span class=p>()])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=k>or</span> <span class=p>(</span><span class=nb>null?</span> <span class=n>cs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>c</span> <span class=p>(</span><span class=nb>car</span> <span class=n>cs</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=k>or</span> <span class=p>(</span><span class=n>whitespace?</span> <span class=n>c</span><span class=p>)</span> <span class=p>(</span><span class=n>delimiter?</span> <span class=n>c</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>        <span class=c1>;; 遇到空白或分隔符，或者列表为空，结束读取</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>values</span> <span class=p>(</span><span class=nb>string-&gt;symbol</span> <span class=p>(</span><span class=nb>list-&gt;string</span> <span class=p>(</span><span class=nb>reverse</span> <span class=n>acc</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                <span class=n>cs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>;; 否则，将当前字符加入累加器，继续处理剩余列表</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>cs</span><span class=p>)</span> <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=nb>car</span> <span class=n>cs</span><span class=p>)</span> <span class=n>acc</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 主词法分析循环</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>tokenize-loop</span> <span class=n>char-list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>null?</span> <span class=n>char-list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>&#39;</span><span class=p>()</span> <span class=c1>; 输入列表为空，返回空列表</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>c</span> <span class=p>(</span><span class=nb>car</span> <span class=n>char-list</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>          <span class=c1>;; 1. 如果是空白符，则忽略它，直接处理剩余部分</span>
</span></span><span class=line><span class=cl>          <span class=p>[(</span><span class=n>whitespace?</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=n>tokenize-loop</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>char-list</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=c1>;; 2. 如果是单个字符的分隔符，将其作为 token，然后处理剩余部分</span>
</span></span><span class=line><span class=cl>          <span class=p>[(</span><span class=n>delimiter?</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=nb>string-&gt;symbol</span> <span class=p>(</span><span class=nb>string</span> <span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=n>tokenize-loop</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>char-list</span><span class=p>)))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=c1>;; 3. 否则，它是一个单词的开始，调用 read-word 来读取它</span>
</span></span><span class=line><span class=cl>          <span class=p>[</span><span class=k>else</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>word</span> <span class=n>remaining-chars</span><span class=p>)</span> <span class=p>(</span><span class=n>read-word</span> <span class=n>char-list</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=nb>cons</span> <span class=n>word</span> <span class=p>(</span><span class=n>tokenize-loop</span> <span class=n>remaining-chars</span><span class=p>)))]))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; Lexer 的公共接口</span>
</span></span><span class=line><span class=cl><span class=c1>;; 它将字符串转换为字符列表，然后启动主循环</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>tokenize-loop</span> <span class=p>(</span><span class=nb>string-&gt;list</span> <span class=n>str</span><span class=p>)))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>下一步是可爱的 parser。把 token 流解析成 AST。这一步用 EOPL 模块的 define-datatype 会很好，但是我不想用。于是使用 racket 自己的 struct 作为 AST 节点。</p><p>另外在这一步我用了一些不是非常 lisp-style 的做法，具体而言把符号列表的 token 流转化为 vector 来操作，用下标区间来标定当前在解析哪部分。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl><span class=c1>;; 1. AST Node Definitions</span>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>identifier</span> <span class=p>(</span><span class=n>name</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>abstract-exp</span> <span class=p>(</span><span class=n>param</span> <span class=n>body</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>apply-exp</span> <span class=p>(</span><span class=n>rator</span> <span class=n>rand</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>bind-exp</span> <span class=p>(</span><span class=n>name</span> <span class=n>val</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>is-keyword?</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>member</span> <span class=n>s</span> <span class=o>&#39;</span><span class=p>(</span><span class=ss>func</span> <span class=ss>:</span> <span class=p>(</span> <span class=p>)</span> <span class=p>{</span> <span class=p>}</span> <span class=ss>return</span> <span class=ss>=</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>is-identifier-token?</span> <span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>symbol?</span> <span class=n>t</span><span class=p>)</span> <span class=p>(</span><span class=nb>not</span> <span class=p>(</span><span class=n>is-keyword?</span> <span class=n>t</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl><span class=c1>;; 2. Parser</span>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse</span> <span class=n>tokens</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>ast</span> <span class=n>next-i</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-lc-exp</span> <span class=p>(</span><span class=nb>list-&gt;vector</span> <span class=n>tokens</span><span class=p>)</span> <span class=mi>0</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>=</span> <span class=n>next-i</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=p>(</span><span class=nb>list-&gt;vector</span> <span class=n>tokens</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=n>ast</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Parsing failed: unexpected tokens remain at the end.&#34;</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=p>(</span><span class=nb>list-&gt;vector</span> <span class=n>tokens</span><span class=p>)</span> <span class=n>next-i</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse-lc-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>tok1</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=n>is-identifier-token?</span> <span class=n>tok1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=nb>&lt;</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>tokens</span><span class=p>))</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>=</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>parse-bind-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse-bind-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let*</span> <span class=p>([</span><span class=n>id-name</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>         <span class=p>[</span><span class=n>val-start-i</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>2</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>val-ast</span> <span class=n>next-i</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=n>val-start-i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>values</span> <span class=p>(</span><span class=n>bind-exp</span> <span class=p>(</span><span class=n>identifier</span> <span class=n>id-name</span><span class=p>)</span> <span class=n>val-ast</span><span class=p>)</span> <span class=n>next-i</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 使用 |(|, |)|, |{|, |}| 以防止与读取器冲突</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse-abstract-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let*</span> <span class=p>([</span><span class=n>param-name</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>3</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>         <span class=p>[</span><span class=n>body-start-i</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>7</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>unless</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>:</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>2</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>|(|</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=n>is-identifier-token?</span> <span class=n>param-name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>4</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>|)|</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>5</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>|{|</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>6</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>return</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Invalid function definition syntax&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>body-ast</span> <span class=n>body-end-i</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=n>body-start-i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>unless</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>body-end-i</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>tokens</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>body-end-i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>|}|</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Expected &#39;}&#39; at the end of function body&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>values</span> <span class=p>(</span><span class=n>abstract-exp</span> <span class=p>(</span><span class=n>identifier</span> <span class=n>param-name</span><span class=p>)</span> <span class=n>body-ast</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nb>+</span> <span class=n>body-end-i</span> <span class=mi>1</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>left-ast</span> <span class=n>next-i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>tok</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>                  <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>                    <span class=p>[(</span><span class=nb>eq?</span> <span class=n>tok</span> <span class=o>&#39;</span><span class=ss>func</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-abstract-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>                    <span class=p>[(</span><span class=n>is-identifier-token?</span> <span class=n>tok</span><span class=p>)</span> <span class=p>(</span><span class=nb>values</span> <span class=p>(</span><span class=n>identifier</span> <span class=n>tok</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>                    <span class=p>[</span><span class=k>else</span> <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Invalid value expression: expected identifier or function at index&#34;</span> <span class=n>i</span><span class=p>)]))])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>current-ast</span> <span class=n>left-ast</span><span class=p>]</span> <span class=p>[</span><span class=n>current-i</span> <span class=n>next-i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=c1>; 检查是否是函数应用</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>current-i</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>tokens</span><span class=p>))</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>current-i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>|(|</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1>; 是: 解析参数, 构建 apply-exp, 然后继续循环</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>arg-ast</span> <span class=n>arg-end-i</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>current-i</span> <span class=mi>1</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>unless</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>arg-end-i</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>tokens</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                       <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>arg-end-i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>|)|</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Expected &#39;)&#39; to close function application&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=n>apply-exp</span> <span class=n>current-ast</span> <span class=n>arg-ast</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=n>arg-end-i</span> <span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=c1>; 否: 循环结束, 返回当前积累的 AST 和索引</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>values</span> <span class=n>current-ast</span> <span class=n>current-i</span><span class=p>)))))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>看着有点令人头大。其实这是 AIGC 代码，感谢 Gemini 2.5 Pro 给予的帮助。</p><p>parser 写起来确实令人无比头大。各种神秘的位置编码和 hack……我开始怀疑自己为什么不使用（或者不打算使用）match 来进行分发。这段代码让人完全没有调试的想法。</p><p>这些解析大致使用了递归下降法。这是一种非常经典的方法，具体而言，我们一开始以归纳（inductive）的形式定义了语言的语法。然后我们将具体语法转换为抽象语法，为每种语法元素定义一种节点类型，为每种节点类型定义一个过程进行解析，解析的过程就变成了这些函数互相递归的过程。</p><p>也即是一种数据驱动的编程：一个语法元素对应一种 AST 节点和一个 struct 定义，解析它对应一个过程，元素可能的多种情形对应 cond 的不同分支，归纳的定义对应函数间的相互递归。</p><p>要进行更多的了解，推荐阅读《essential of programming languages》（即 EOPL）。</p><p>进行一些测试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl><span class=c1>;; 3. Testing</span>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>test-str-1</span> <span class=s2>&#34;id = func : (x) { return x }&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>test-str-2</span> <span class=s2>&#34;apply = func : (f) { return func : (x) { return f(x) } }&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>test-str-3</span> <span class=s2>&#34;id(y)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>test-str-4</span> <span class=s2>&#34;get-y(f)(x)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;--- Test 1: Binding ---&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>pretty-print</span> <span class=p>(</span><span class=n>parse</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>test-str-1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;--- Test 2: Currying ---&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>pretty-print</span> <span class=p>(</span><span class=n>parse</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>test-str-2</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;--- Test 3: Simple Application ---&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>pretty-print</span> <span class=p>(</span><span class=n>parse</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>test-str-3</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;--- Test 4: Chained Application ---&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>pretty-print</span> <span class=p>(</span><span class=n>parse</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>test-str-4</span><span class=p>)))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>--- Test 1: Binding ---
</span></span><span class=line><span class=cl>(bind-exp (identifier &#39;id) (abstract-exp (identifier &#39;x) (identifier &#39;x)))
</span></span><span class=line><span class=cl>--- Test 2: Currying ---
</span></span><span class=line><span class=cl>(bind-exp
</span></span><span class=line><span class=cl> (identifier &#39;apply)
</span></span><span class=line><span class=cl> (abstract-exp
</span></span><span class=line><span class=cl>  (identifier &#39;f)
</span></span><span class=line><span class=cl>  (abstract-exp (identifier &#39;x) (apply-exp (identifier &#39;f) (identifier &#39;x)))))
</span></span><span class=line><span class=cl>--- Test 3: Simple Application ---
</span></span><span class=line><span class=cl>(apply-exp (identifier &#39;id) (identifier &#39;y))
</span></span><span class=line><span class=cl>--- Test 4: Chained Application ---
</span></span><span class=line><span class=cl>(apply-exp (apply-exp (identifier &#39;get-y) (identifier &#39;f)) (identifier &#39;x))
</span></span></code></pre></td></tr></table></div></div><p>可以看到，parse 的结果是正确的。</p><p>在建出 AST 之后，进行语法转换就非常容易了。因为源语言和目标语言只不过是 lc-exp 的两种不同表示法（具体语法，concrete syntax）。有了抽象语法，转换为不同的具体语法易如反掌。</p><p>吸取了 parser 的惨痛教训，这次我们使用 match 进行操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>convert</span> <span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>match</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>bind-exp</span> <span class=n>name</span> <span class=n>val</span><span class=p>)</span> <span class=o>`</span><span class=p>(</span><span class=ss>define</span> <span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>name</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>val</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>apply-exp</span> <span class=n>rator</span> <span class=n>rand</span><span class=p>)</span> <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>rator</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>rand</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>abstract-exp</span> <span class=n>arg</span> <span class=n>body</span><span class=p>)</span> <span class=o>`</span><span class=p>(</span><span class=ss>lambda</span> <span class=p>(</span><span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>arg</span><span class=p>))</span> <span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>body</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>identifier</span> <span class=n>id</span><span class=p>)</span> <span class=n>id</span><span class=p>]))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>然后一些测试。我们用上次的老例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>test-str-1</span> <span class=s2>&#34;id = func : (x) { return x }&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>test-str-2</span> <span class=s2>&#34;apply = func : (f) { return func : (x) { return f(x) } }&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>test-str-3</span> <span class=s2>&#34;id(y)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=n>test-str-4</span> <span class=s2>&#34;get-y(f)(x)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;--- Test 1: Binding ---&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>convert</span> <span class=p>(</span><span class=n>parse</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>test-str-1</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;--- Test 2: Currying ---&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>convert</span> <span class=p>(</span><span class=n>parse</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>test-str-2</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;--- Test 3: Simple Application ---&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>convert</span> <span class=p>(</span><span class=n>parse</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>test-str-3</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=s2>&#34;--- Test 4: Chained Application ---&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>displayln</span> <span class=p>(</span><span class=n>convert</span> <span class=p>(</span><span class=n>parse</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>test-str-4</span><span class=p>))))</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>--- Test 1: Binding ---
</span></span><span class=line><span class=cl>(define id (lambda (x) x))
</span></span><span class=line><span class=cl>--- Test 2: Currying ---
</span></span><span class=line><span class=cl>(define apply (lambda (f) (lambda (x) (f x))))
</span></span><span class=line><span class=cl>--- Test 3: Simple Application ---
</span></span><span class=line><span class=cl>(id y)
</span></span><span class=line><span class=cl>--- Test 4: Chained Application ---
</span></span><span class=line><span class=cl>((get-y f) x)
</span></span></code></pre></td></tr></table></div></div><p>成功了！</p><hr><p>这样，我们就可以将伪代码直接送进 chez scheme 或者 racket 运行了！</p><p>更重要的是，我们亲手走了一遍扫描（词法分析）、解析（语法分析）和代码生成的编译流程。构建了一个简易的源到源编译器。</p><p>如果想要了解更多，推荐阅读 EOPL（《essential of programming languages》），friedman 教授的著作。其中第一章就是归纳式的语法，全书会带领你实现各种各样语言的解释器以学习种种语言特性。</p><p>最后是完整代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-racket data-lang=racket><span class=line><span class=cl><span class=kn>#lang </span><span class=nn>racket</span>
</span></span><span class=line><span class=cl><span class=c1>;;; ======================================================</span>
</span></span><span class=line><span class=cl><span class=c1>;;;  新版 Lexer (基于列表处理的函数式风格)</span>
</span></span><span class=line><span class=cl><span class=c1>;;; ======================================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 辅助函数: 判断一个字符是否为分隔符</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>delimiter?</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>member</span> <span class=n>c</span> <span class=o>&#39;</span><span class=p>(</span><span class=sc>#\:</span> <span class=sc>#\(</span> <span class=sc>#\)</span> <span class=sc>#\=</span> <span class=sc>#\{</span> <span class=sc>#\}</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 辅助函数: 判断一个字符是否为空白符</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>whitespace?</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>char-whitespace?</span> <span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 核心辅助函数: 从字符列表开头读取一个完整的单词(标识符或关键字)</span>
</span></span><span class=line><span class=cl><span class=c1>;; 返回两个值: 1. 单词转换成的符号  2. 剩余的字符列表</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>read-word</span> <span class=n>char-list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>cs</span> <span class=n>char-list</span><span class=p>]</span> <span class=p>[</span><span class=n>acc</span> <span class=o>&#39;</span><span class=p>()])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=k>or</span> <span class=p>(</span><span class=nb>null?</span> <span class=n>cs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>c</span> <span class=p>(</span><span class=nb>car</span> <span class=n>cs</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=k>or</span> <span class=p>(</span><span class=n>whitespace?</span> <span class=n>c</span><span class=p>)</span> <span class=p>(</span><span class=n>delimiter?</span> <span class=n>c</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>        <span class=c1>;; 遇到空白或分隔符，或者列表为空，结束读取</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>values</span> <span class=p>(</span><span class=nb>string-&gt;symbol</span> <span class=p>(</span><span class=nb>list-&gt;string</span> <span class=p>(</span><span class=nb>reverse</span> <span class=n>acc</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                <span class=n>cs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>;; 否则，将当前字符加入累加器，继续处理剩余列表</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>cs</span><span class=p>)</span> <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=nb>car</span> <span class=n>cs</span><span class=p>)</span> <span class=n>acc</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; 主词法分析循环</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>tokenize-loop</span> <span class=n>char-list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>null?</span> <span class=n>char-list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>&#39;</span><span class=p>()</span> <span class=c1>; 输入列表为空，返回空列表</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>c</span> <span class=p>(</span><span class=nb>car</span> <span class=n>char-list</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>          <span class=c1>;; 1. 如果是空白符，则忽略它，直接处理剩余部分</span>
</span></span><span class=line><span class=cl>          <span class=p>[(</span><span class=n>whitespace?</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=n>tokenize-loop</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>char-list</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=c1>;; 2. 如果是单个字符的分隔符，将其作为 token，然后处理剩余部分</span>
</span></span><span class=line><span class=cl>          <span class=p>[(</span><span class=n>delimiter?</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=nb>cons</span> <span class=p>(</span><span class=nb>string-&gt;symbol</span> <span class=p>(</span><span class=nb>string</span> <span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=n>tokenize-loop</span> <span class=p>(</span><span class=nb>cdr</span> <span class=n>char-list</span><span class=p>)))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=c1>;; 3. 否则，它是一个单词的开始，调用 read-word 来读取它</span>
</span></span><span class=line><span class=cl>          <span class=p>[</span><span class=k>else</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>word</span> <span class=n>remaining-chars</span><span class=p>)</span> <span class=p>(</span><span class=n>read-word</span> <span class=n>char-list</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=nb>cons</span> <span class=n>word</span> <span class=p>(</span><span class=n>tokenize-loop</span> <span class=n>remaining-chars</span><span class=p>)))]))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;; Lexer 的公共接口</span>
</span></span><span class=line><span class=cl><span class=c1>;; 它将字符串转换为字符列表，然后启动主循环</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>lexer</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=n>tokenize-loop</span> <span class=p>(</span><span class=nb>string-&gt;list</span> <span class=n>str</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl><span class=c1>;; 1. AST Node Definitions (保持不变)</span>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>identifier</span> <span class=p>(</span><span class=n>name</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>abstract-exp</span> <span class=p>(</span><span class=n>param</span> <span class=n>body</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>apply-exp</span> <span class=p>(</span><span class=n>rator</span> <span class=n>rand</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>struct</span> <span class=n>bind-exp</span> <span class=p>(</span><span class=n>name</span> <span class=n>val</span><span class=p>)</span> <span class=kd>#:transparent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>is-keyword?</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>member</span> <span class=n>s</span> <span class=o>&#39;</span><span class=p>(</span><span class=ss>func</span> <span class=ss>:</span> <span class=p>(</span> <span class=p>)</span> <span class=p>{</span> <span class=p>}</span> <span class=ss>return</span> <span class=ss>=</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>is-identifier-token?</span> <span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>symbol?</span> <span class=n>t</span><span class=p>)</span> <span class=p>(</span><span class=nb>not</span> <span class=p>(</span><span class=n>is-keyword?</span> <span class=n>t</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl><span class=c1>;; 2. Parser (修正版)</span>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse</span> <span class=n>tokens</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>ast</span> <span class=n>next-i</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-lc-exp</span> <span class=p>(</span><span class=nb>list-&gt;vector</span> <span class=n>tokens</span><span class=p>)</span> <span class=mi>0</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=nb>=</span> <span class=n>next-i</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=p>(</span><span class=nb>list-&gt;vector</span> <span class=n>tokens</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=n>ast</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Parsing failed: unexpected tokens remain at the end.&#34;</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=p>(</span><span class=nb>list-&gt;vector</span> <span class=n>tokens</span><span class=p>)</span> <span class=n>next-i</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse-lc-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>tok1</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=n>is-identifier-token?</span> <span class=n>tok1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=nb>&lt;</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>tokens</span><span class=p>))</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>=</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>parse-bind-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse-bind-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let*</span> <span class=p>([</span><span class=n>id-name</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>         <span class=p>[</span><span class=n>val-start-i</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>2</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>val-ast</span> <span class=n>next-i</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=n>val-start-i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>values</span> <span class=p>(</span><span class=n>bind-exp</span> <span class=p>(</span><span class=n>identifier</span> <span class=n>id-name</span><span class=p>)</span> <span class=n>val-ast</span><span class=p>)</span> <span class=n>next-i</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 修正: 使用 |(|, |)|, |{|, |}|</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse-abstract-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let*</span> <span class=p>([</span><span class=n>param-name</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>3</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>         <span class=p>[</span><span class=n>body-start-i</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>7</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>unless</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>:</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>2</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>|(|</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=n>is-identifier-token?</span> <span class=n>param-name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>4</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>|)|</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>5</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>|{|</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>6</span><span class=p>))</span> <span class=o>&#39;</span><span class=ss>return</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Invalid function definition syntax&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>body-ast</span> <span class=n>body-end-i</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=n>body-start-i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>unless</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>body-end-i</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>tokens</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                   <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>body-end-i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>|}|</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Expected &#39;}&#39; at the end of function body&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nb>values</span> <span class=p>(</span><span class=n>abstract-exp</span> <span class=p>(</span><span class=n>identifier</span> <span class=n>param-name</span><span class=p>)</span> <span class=n>body-ast</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=p>(</span><span class=nb>+</span> <span class=n>body-end-i</span> <span class=mi>1</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; 修正: 修复 loop 的逻辑, 确保有 else 分支, 并使用正确的符号</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>left-ast</span> <span class=n>next-i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>let</span> <span class=p>([</span><span class=n>tok</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>                  <span class=p>(</span><span class=k>cond</span>
</span></span><span class=line><span class=cl>                    <span class=p>[(</span><span class=nb>eq?</span> <span class=n>tok</span> <span class=o>&#39;</span><span class=ss>func</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-abstract-exp</span> <span class=n>tokens</span> <span class=n>i</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>                    <span class=p>[(</span><span class=n>is-identifier-token?</span> <span class=n>tok</span><span class=p>)</span> <span class=p>(</span><span class=nb>values</span> <span class=p>(</span><span class=n>identifier</span> <span class=n>tok</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=n>i</span> <span class=mi>1</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>                    <span class=p>[</span><span class=k>else</span> <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Invalid value expression: expected identifier or function at index&#34;</span> <span class=n>i</span><span class=p>)]))])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>let</span> <span class=n>loop</span> <span class=p>([</span><span class=n>current-ast</span> <span class=n>left-ast</span><span class=p>]</span> <span class=p>[</span><span class=n>current-i</span> <span class=n>next-i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=c1>; 检查是否是函数应用</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>current-i</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>tokens</span><span class=p>))</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>current-i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>|(|</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1>; 是: 解析参数, 构建 apply-exp, 然后继续循环</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=k>let-values</span> <span class=p>([(</span><span class=n>arg-ast</span> <span class=n>arg-end-i</span><span class=p>)</span> <span class=p>(</span><span class=n>parse-val-exp</span> <span class=n>tokens</span> <span class=p>(</span><span class=nb>+</span> <span class=n>current-i</span> <span class=mi>1</span><span class=p>))])</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=k>unless</span> <span class=p>(</span><span class=k>and</span> <span class=p>(</span><span class=nb>&lt;</span> <span class=n>arg-end-i</span> <span class=p>(</span><span class=nb>vector-length</span> <span class=n>tokens</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                       <span class=p>(</span><span class=nb>eq?</span> <span class=p>(</span><span class=nb>vector-ref</span> <span class=n>tokens</span> <span class=n>arg-end-i</span><span class=p>)</span> <span class=o>&#39;</span><span class=ss>|)|</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=nb>error</span> <span class=s2>&#34;Expected &#39;)&#39; to close function application&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>loop</span> <span class=p>(</span><span class=n>apply-exp</span> <span class=n>current-ast</span> <span class=n>arg-ast</span><span class=p>)</span> <span class=p>(</span><span class=nb>+</span> <span class=n>arg-end-i</span> <span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=c1>; 否: 循环结束, 返回当前积累的 AST 和索引</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=nb>values</span> <span class=n>current-ast</span> <span class=n>current-i</span><span class=p>)))))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>define</span> <span class=p>(</span><span class=n>convert</span> <span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>match</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>bind-exp</span> <span class=n>name</span> <span class=n>val</span><span class=p>)</span> <span class=o>`</span><span class=p>(</span><span class=ss>define</span> <span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>name</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>val</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>apply-exp</span> <span class=n>rator</span> <span class=n>rand</span><span class=p>)</span> <span class=o>`</span><span class=p>(</span><span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>rator</span><span class=p>)</span> <span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>rand</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>abstract-exp</span> <span class=n>arg</span> <span class=n>body</span><span class=p>)</span> <span class=o>`</span><span class=p>(</span><span class=ss>lambda</span> <span class=p>(</span><span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>arg</span><span class=p>))</span> <span class=o>,</span><span class=p>(</span><span class=n>convert</span> <span class=n>body</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>        <span class=p>[(</span><span class=n>identifier</span> <span class=n>id</span><span class=p>)</span> <span class=n>id</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl><span class=c1>;; 3. Testing</span>
</span></span><span class=line><span class=cl><span class=c1>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
</span></span><span class=line><span class=cl><span class=cm>#|
</span></span></span><span class=line><span class=cl><span class=cm>(define test-str-1 &#34;id = func : (x) { return x }&#34;)
</span></span></span><span class=line><span class=cl><span class=cm>(define test-str-2 &#34;apply = func : (f) { return func : (x) { return f(x) } }&#34;)
</span></span></span><span class=line><span class=cl><span class=cm>(define test-str-3 &#34;id(y)&#34;)
</span></span></span><span class=line><span class=cl><span class=cm>(define test-str-4 &#34;get-y(f)(x)&#34;)
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>(displayln &#34;--- Test 1: Binding ---&#34;)
</span></span></span><span class=line><span class=cl><span class=cm>(displayln (convert (parse (lexer test-str-1))))
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>(displayln &#34;--- Test 2: Currying ---&#34;)
</span></span></span><span class=line><span class=cl><span class=cm>(displayln (convert (parse (lexer test-str-2))))
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>(displayln &#34;--- Test 3: Simple Application ---&#34;)
</span></span></span><span class=line><span class=cl><span class=cm>(displayln (convert (parse (lexer test-str-3))))
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>(displayln &#34;--- Test 4: Chained Application ---&#34;)
</span></span></span><span class=line><span class=cl><span class=cm>(displayln (convert (parse (lexer test-str-4))))
</span></span></span><span class=line><span class=cl><span class=cm>|#</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://litjohn.github.io/tags/plt/>PLT</a></li><li><a href=https://litjohn.github.io/tags/lisp/scheme/racket/>Lisp/Scheme/Racket</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>litjohn's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>