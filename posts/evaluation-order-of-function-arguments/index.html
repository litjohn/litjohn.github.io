<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Evaluation Order of Function Arguments | 正确即是废话，废话亦是正确</title><meta name=keywords content><meta name=description content='You might assume that computers evaluate function arguments from left to right. However, that is not always the case.
In fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.
As shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).
The Behavior in C++ and Scheme
Consider the following C++ code:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


void foo(int x, int y) {
    cout << x << " " << y << "\n";
}

int counter() {
    static int x = 0;
    x++;
    return x;
}

int main() {
    foo(counter(), counter());
    return 0;
}


If you compile and run this using GCC 15.2 with -O2, you might notice the output is 2 1. The compiler chose to evaluate the arguments from right to left.'><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/evaluation-order-of-function-arguments/><link crossorigin=anonymous href=/assets/css/stylesheet.b915ce98f9f65cca5e346b24fc336009b3608a3eeb24ce4b0e53c4500eba9374.css integrity="sha256-uRXOmPn2XMpeNGsk/DNgCbNgij7rJM5LDlPEUA66k3Q=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/evaluation-order-of-function-arguments/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/evaluation-order-of-function-arguments/"><meta property="og:site_name" content="正确即是废话，废话亦是正确"><meta property="og:title" content="Evaluation Order of Function Arguments"><meta property="og:description" content='You might assume that computers evaluate function arguments from left to right. However, that is not always the case.
In fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.
As shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).
The Behavior in C++ and Scheme Consider the following C++ code:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 void foo(int x, int y) { cout << x << " " << y << "\n"; } int counter() { static int x = 0; x++; return x; } int main() { foo(counter(), counter()); return 0; } If you compile and run this using GCC 15.2 with -O2, you might notice the output is 2 1. The compiler chose to evaluate the arguments from right to left.'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-21T19:13:04+08:00"><meta property="article:modified_time" content="2025-12-21T19:13:04+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Evaluation Order of Function Arguments"><meta name=twitter:description content='You might assume that computers evaluate function arguments from left to right. However, that is not always the case.
In fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.
As shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).
The Behavior in C++ and Scheme
Consider the following C++ code:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


void foo(int x, int y) {
    cout << x << " " << y << "\n";
}

int counter() {
    static int x = 0;
    x++;
    return x;
}

int main() {
    foo(counter(), counter());
    return 0;
}


If you compile and run this using GCC 15.2 with -O2, you might notice the output is 2 1. The compiler chose to evaluate the arguments from right to left.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Evaluation Order of Function Arguments","item":"https://litjohn.github.io/posts/evaluation-order-of-function-arguments/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Evaluation Order of Function Arguments","name":"Evaluation Order of Function Arguments","description":"You might assume that computers evaluate function arguments from left to right. However, that is not always the case.\nIn fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.\nAs shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).\nThe Behavior in C++ and Scheme Consider the following C++ code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void foo(int x, int y) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int counter() { static int x = 0; x++; return x; } int main() { foo(counter(), counter()); return 0; } If you compile and run this using GCC 15.2 with -O2, you might notice the output is 2 1. The compiler chose to evaluate the arguments from right to left.\n","keywords":[],"articleBody":"You might assume that computers evaluate function arguments from left to right. However, that is not always the case.\nIn fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.\nAs shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).\nThe Behavior in C++ and Scheme Consider the following C++ code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void foo(int x, int y) { cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c \"\\n\"; } int counter() { static int x = 0; x++; return x; } int main() { foo(counter(), counter()); return 0; } If you compile and run this using GCC 15.2 with -O2, you might notice the output is 2 1. The compiler chose to evaluate the arguments from right to left.\nSimilarly, in Scheme:\n1 2 3 (let ([x (read)] [y (read)]) (display x) (display \" \") (display y)) If you type A then B into the console, you might find y gets A and x gets B, because the order in which (read) is called for each binding is unspecified.\nWhy the Ambiguity? This is not a bug, but a deliberate trade-off. Standards leave the order unspecified to grant compilers freedom for optimization. By not forcing a strict left-to-right order, compilers can better leverage instruction reordering, register allocation, and parallelization.\nIn older x86 C environments, evaluating from right to left was also a matter of efficiency. Since the stack grows downwards, pushing arguments from right to left ensures the leftmost argument ends up at the “top” of the stack, simplifying how functions like printf locate their first fixed argument.\nPrecise Semantics: C++17 and Scheme In C++ (pre-C++17), these evaluations were unsequenced. Modifying the same object twice resulted in Undefined Behavior (UB). Since C++17, they are indeterminately sequenced—the result is unspecified, but the behavior is no longer “undefined” (no nasal demons).\nThe RnRS Scheme standard goes a step further, stating:\n“When a procedure call is evaluated, the operator and operand expressions are evaluated (in an unspecified order) and the resulting procedure is passed the resulting arguments.”\nThis means even the function itself (the operator) could be evaluated after its arguments.\nThe “Nesting” Escape Hatch: Why let* Still Works If the order is so chaotic, you might wonder: How can Scheme implement let* (which guarantees sequential binding) if it’s just “syntactic sugar” for nested lambdas?\nThe answer lies in the distinction between evaluation order within a call and the execution flow of a closure.\nA let* expression:\n1 (let* ([x 1] [y (+ x 1)]) body) expands into nested lambdas:\n1 2 3 ((lambda (x) ((lambda (y) body) (+ x 1))) 1) In this nested structure, the inner expression (+ x 1) is part of the body of the outer lambda. According to Scheme semantics, the body of a procedure can only begin execution after the procedure has been called and its arguments have been fully evaluated.\nEven if the compiler evaluates the outer operator (lambda (x)...) after the outer operand (1), the inner call cannot even be “seen” by the evaluator until the outer call happens. Nesting transforms a “horizontal” ordering problem (where order is unspecified) into a “vertical” dependency (where order is guaranteed by the flow of data).\nConclusion When writing code that relies on side effects (like read, set!, or counter++), never assume a left-to-right order unless the language explicitly guarantees it (like Java or Python). If you need a specific sequence in Scheme or C++, use explicit sequencing constructs like let*, begin, or separate statements to ensure your code remains portable and predictable.\n","wordCount":"614","inLanguage":"en","datePublished":"2025-12-21T19:13:04+08:00","dateModified":"2025-12-21T19:13:04+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/evaluation-order-of-function-arguments/"},"publisher":{"@type":"Organization","name":"正确即是废话，废话亦是正确","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="正确即是废话，废话亦是正确 (Alt + H)">正确即是废话，废话亦是正确</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://litjohn.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Evaluation Order of Function Arguments</h1><div class=post-meta><span title='2025-12-21 19:13:04 +0800 +0800'>December 21, 2025</span></div></header><div class=post-content><p>You might assume that computers evaluate function arguments from left to right. However, that is not always the case.</p><p>In fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments <strong>unspecified</strong>.</p><p>As shown in <a href=https://www.luogu.com.cn/discuss/1220027>this post</a>, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).</p><h3 id=the-behavior-in-c-and-scheme>The Behavior in C++ and Scheme<a hidden class=anchor aria-hidden=true href=#the-behavior-in-c-and-scheme>#</a></h3><p>Consider the following C++ code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>y</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>counter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>foo</span><span class=p>(</span><span class=n>counter</span><span class=p>(),</span> <span class=n>counter</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>If you compile and run this using GCC 15.2 with <code>-O2</code>, you might notice the output is <code>2 1</code>. The compiler chose to evaluate the arguments from right to left.</p><p>Similarly, in Scheme:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>let </span><span class=p>([</span><span class=nv>x</span> <span class=p>(</span><span class=nf>read</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=nv>y</span> <span class=p>(</span><span class=nf>read</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>display </span><span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>display </span><span class=s>&#34; &#34;</span><span class=p>)</span> <span class=p>(</span><span class=nb>display </span><span class=nv>y</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>If you type <code>A</code> then <code>B</code> into the console, you might find <code>y</code> gets <code>A</code> and <code>x</code> gets <code>B</code>, because the order in which <code>(read)</code> is called for each binding is unspecified.</p><h3 id=why-the-ambiguity>Why the Ambiguity?<a hidden class=anchor aria-hidden=true href=#why-the-ambiguity>#</a></h3><p>This is not a bug, but a deliberate trade-off. Standards leave the order unspecified to grant compilers freedom for optimization. By not forcing a strict left-to-right order, compilers can better leverage instruction reordering, register allocation, and parallelization.</p><p>In older x86 C environments, evaluating from right to left was also a matter of efficiency. Since the stack grows downwards, pushing arguments from right to left ensures the leftmost argument ends up at the &ldquo;top&rdquo; of the stack, simplifying how functions like <code>printf</code> locate their first fixed argument.</p><h3 id=precise-semantics-c17-and-scheme>Precise Semantics: C++17 and Scheme<a hidden class=anchor aria-hidden=true href=#precise-semantics-c17-and-scheme>#</a></h3><p>In C++ (pre-C++17), these evaluations were <em>unsequenced</em>. Modifying the same object twice resulted in <strong>Undefined Behavior (UB)</strong>. Since C++17, they are <em>indeterminately sequenced</em>—the result is <strong>unspecified</strong>, but the behavior is no longer &ldquo;undefined&rdquo; (no nasal demons).</p><p>The RnRS Scheme standard goes a step further, stating:</p><blockquote><p>&ldquo;When a procedure call is evaluated, the <strong>operator and operand expressions are evaluated (in an unspecified order)</strong> and the resulting procedure is passed the resulting arguments.&rdquo;</p></blockquote><p>This means even the function itself (the operator) could be evaluated <em>after</em> its arguments.</p><h3 id=the-nesting-escape-hatch-why-let-still-works>The &ldquo;Nesting&rdquo; Escape Hatch: Why <code>let*</code> Still Works<a hidden class=anchor aria-hidden=true href=#the-nesting-escape-hatch-why-let-still-works>#</a></h3><p>If the order is so chaotic, you might wonder: <strong>How can Scheme implement <code>let*</code> (which guarantees sequential binding) if it&rsquo;s just &ldquo;syntactic sugar&rdquo; for nested lambdas?</strong></p><p>The answer lies in the distinction between <strong>evaluation order within a call</strong> and <strong>the execution flow of a closure</strong>.</p><p>A <code>let*</code> expression:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>let* </span><span class=p>([</span><span class=nv>x</span> <span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=nv>y</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>x</span> <span class=mi>1</span><span class=p>)])</span> <span class=nv>body</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>expands into nested lambdas:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>((</span><span class=k>lambda </span><span class=p>(</span><span class=nf>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>((</span><span class=k>lambda </span><span class=p>(</span><span class=nf>y</span><span class=p>)</span> <span class=nv>body</span><span class=p>)</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>x</span> <span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>In this nested structure, the inner expression <code>(+ x 1)</code> is part of the <strong>body</strong> of the outer lambda. According to Scheme semantics, the body of a procedure can only begin execution <strong>after</strong> the procedure has been called and its arguments have been fully evaluated.</p><p>Even if the compiler evaluates the outer operator (<code>lambda (x)...</code>) after the outer operand (<code>1</code>), the <em>inner</em> call cannot even be &ldquo;seen&rdquo; by the evaluator until the outer call happens. <strong>Nesting transforms a &ldquo;horizontal&rdquo; ordering problem (where order is unspecified) into a &ldquo;vertical&rdquo; dependency (where order is guaranteed by the flow of data).</strong></p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>When writing code that relies on side effects (like <code>read</code>, <code>set!</code>, or <code>counter++</code>), never assume a left-to-right order unless the language explicitly guarantees it (like Java or Python). If you need a specific sequence in Scheme or C++, use explicit sequencing constructs like <code>let*</code>, <code>begin</code>, or separate statements to ensure your code remains portable and predictable.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://litjohn.github.io/>正确即是废话，废话亦是正确</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>