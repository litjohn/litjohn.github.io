<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Evaluation Order of Function Arguments | 正确即是废话，废话亦是正确</title><meta name=keywords content><meta name=description content='You might assume that computers evaluate function arguments from left to right. However, that is not always the case.
In fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.
As shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).
Let’s break it down. Consider the following piece of code:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


void foo(int x, int y) {
    cout << x << " " << y << "\n";
}

int counter() {
    static int x = 0;
    x++;
    return x;
}

int main() {
    foo(counter(), counter());
    return 0;
}


Compile and run it using GCC 15.2 with -O2 and -std=c++20 flags.'><meta name=author content><link rel=canonical href=https://litjohn.github.io/posts/evaluation-order-of-function-arguments/><link crossorigin=anonymous href=/assets/css/stylesheet.b915ce98f9f65cca5e346b24fc336009b3608a3eeb24ce4b0e53c4500eba9374.css integrity="sha256-uRXOmPn2XMpeNGsk/DNgCbNgij7rJM5LDlPEUA66k3Q=" rel="preload stylesheet" as=style><link rel=icon href=https://litjohn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://litjohn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://litjohn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://litjohn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://litjohn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://litjohn.github.io/posts/evaluation-order-of-function-arguments/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://litjohn.github.io/posts/evaluation-order-of-function-arguments/"><meta property="og:site_name" content="正确即是废话，废话亦是正确"><meta property="og:title" content="Evaluation Order of Function Arguments"><meta property="og:description" content='You might assume that computers evaluate function arguments from left to right. However, that is not always the case.
In fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.
As shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).
Let’s break it down. Consider the following piece of code:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 void foo(int x, int y) { cout << x << " " << y << "\n"; } int counter() { static int x = 0; x++; return x; } int main() { foo(counter(), counter()); return 0; } Compile and run it using GCC 15.2 with -O2 and -std=c++20 flags.'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-21T19:13:04+08:00"><meta property="article:modified_time" content="2025-12-21T19:13:04+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Evaluation Order of Function Arguments"><meta name=twitter:description content='You might assume that computers evaluate function arguments from left to right. However, that is not always the case.
In fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.
As shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).
Let’s break it down. Consider the following piece of code:


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


void foo(int x, int y) {
    cout << x << " " << y << "\n";
}

int counter() {
    static int x = 0;
    x++;
    return x;
}

int main() {
    foo(counter(), counter());
    return 0;
}


Compile and run it using GCC 15.2 with -O2 and -std=c++20 flags.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://litjohn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Evaluation Order of Function Arguments","item":"https://litjohn.github.io/posts/evaluation-order-of-function-arguments/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Evaluation Order of Function Arguments","name":"Evaluation Order of Function Arguments","description":"You might assume that computers evaluate function arguments from left to right. However, that is not always the case.\nIn fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.\nAs shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).\nLet’s break it down. Consider the following piece of code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void foo(int x, int y) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int counter() { static int x = 0; x++; return x; } int main() { foo(counter(), counter()); return 0; } Compile and run it using GCC 15.2 with -O2 and -std=c++20 flags.\n","keywords":[],"articleBody":"You might assume that computers evaluate function arguments from left to right. However, that is not always the case.\nIn fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.\nAs shown in this post, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).\nLet’s break it down. Consider the following piece of code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void foo(int x, int y) { cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c \"\\n\"; } int counter() { static int x = 0; x++; return x; } int main() { foo(counter(), counter()); return 0; } Compile and run it using GCC 15.2 with -O2 and -std=c++20 flags.\nYou’ll notice that the output is 2 1.\nOr this scheme code snippet:\n1 2 3 (let ([x (read)] [y (read)]) (printf \"~a ~a\" x y)) will get a similar surprising result.\nThe reason is that compilers choose to evaluate arguments from right to left.\nWhy do the compilers do this? It’s not a bug, but a deliberate trade-off in the language design. The standards leave the evaluation order unspecified to give the compiler more room for optimization. By sacrificing the intuitiveness of a strict left-to-right order, compilers can leverage instruction reordering and parallelization to squeeze out better performance.\nAnother factor is the efficiency of calling conventions. In many x86 architectures, the stack grows downwards, and the rsp register points to the top of the stack. To ensure that the leftmost arguments are positioned closer to the top of the stack, the compiler often evaluates and pushes arguments from right to left. This arrangement simplifies how the callee accesses its parameters.\nThis right-to-left order is crucial for variadic functions like printf, as it ensures the fixed arguments are always at a known position relative to the stack pointer.\nMore precisely, evaluations of arguments (including their side effects) are unsequenced before C++17. If they modify the same object, it leads to Undefined Behavior (UB). Since C++17, they have become indeterminately sequenced. This means the behavior is no longer undefined, but unspecified: the compiler must choose one order among all $k!$ possible permutations (where $k$ is the number of arguments). Each argument must be fully evaluated before the next one starts, so the compiler can no longer trigger “nasal demons” (like shutting down your computer), though the result still depends on the implementation.\n","wordCount":"411","inLanguage":"en","datePublished":"2025-12-21T19:13:04+08:00","dateModified":"2025-12-21T19:13:04+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://litjohn.github.io/posts/evaluation-order-of-function-arguments/"},"publisher":{"@type":"Organization","name":"正确即是废话，废话亦是正确","logo":{"@type":"ImageObject","url":"https://litjohn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://litjohn.github.io/ accesskey=h title="正确即是废话，废话亦是正确 (Alt + H)">正确即是废话，废话亦是正确</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://litjohn.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://litjohn.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://litjohn.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://litjohn.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://litjohn.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Evaluation Order of Function Arguments</h1><div class=post-meta><span title='2025-12-21 19:13:04 +0800 +0800'>December 21, 2025</span></div></header><div class=post-content><p>You might assume that computers evaluate function arguments from left to right. However, that is not always the case.</p><p>In fact, many programming languages—such as C++ and RnRS Scheme—leave the evaluation order of arguments unspecified.</p><p>As shown in <a href=https://www.luogu.com.cn/discuss/1220027>this post</a>, ignoring this detail can trigger undefined behavior, leading to a Wrong Answer (WA) or Runtime Error (RE).</p><p>Let’s break it down. Consider the following piece of code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>y</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>counter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>foo</span><span class=p>(</span><span class=n>counter</span><span class=p>(),</span> <span class=n>counter</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Compile and run it using GCC 15.2 with -O2 and -std=c++20 flags.</p><p>You&rsquo;ll notice that the output is <code>2 1</code>.</p><p>Or this scheme code snippet:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scheme data-lang=scheme><span class=line><span class=cl><span class=p>(</span><span class=k>let </span><span class=p>([</span><span class=nv>x</span> <span class=p>(</span><span class=nf>read</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>      <span class=p>[</span><span class=nv>y</span> <span class=p>(</span><span class=nf>read</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nf>printf</span> <span class=s>&#34;~a ~a&#34;</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>will get a similar surprising result.</p><p>The reason is that compilers choose to evaluate arguments from right to left.</p><p>Why do the compilers do this? It&rsquo;s not a bug, but a deliberate trade-off in the language design. The standards leave the evaluation order unspecified to give the compiler more room for optimization. By sacrificing the intuitiveness of a strict left-to-right order, compilers can leverage instruction reordering and parallelization to squeeze out better performance.</p><p>Another factor is the efficiency of calling conventions. In many x86 architectures, the stack grows downwards, and the rsp register points to the top of the stack. To ensure that the leftmost arguments are positioned closer to the top of the stack, the compiler often evaluates and pushes arguments from right to left. This arrangement simplifies how the callee accesses its parameters.</p><p>This right-to-left order is crucial for variadic functions like <code>printf</code>, as it ensures the fixed arguments are always at a known position relative to the stack pointer.</p><p>More precisely, evaluations of arguments (including their side effects) are <em>unsequenced</em> before C++17. If they modify the same object, it leads to Undefined Behavior (UB). Since C++17, they have become <em>indeterminately sequenced</em>. This means the behavior is no longer undefined, but <em>unspecified</em>: the compiler must choose one order among all $k!$ possible permutations (where $k$ is the number of arguments). Each argument must be fully evaluated before the next one starts, so the compiler can no longer trigger &ldquo;nasal demons&rdquo; (like shutting down your computer), though the result still depends on the implementation.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://litjohn.github.io/>正确即是废话，废话亦是正确</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>